{"ts":1360266750206,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1360266752910,"patch":[[{"diffs":[[1,"d3 = function() {\r\n  var π = Math.PI, ε = 1e-6, d3 = {\r\n    version: \"3.0.6\"\r\n  }, d3_radians = π / 180, d3_degrees = 180 / π, d3_document = document, d3_window = window;\r\n  function d3_target(d) {\r\n    return d.target;\r\n  }\r\n  function d3_source(d) {\r\n    return d.source;\r\n  }\r\n  var d3_format_decimalPoint = \".\", d3_format_thousandsSeparator = \",\", d3_format_grouping = [ 3, 3 ];\r\n  if (!Date.now) Date.now = function() {\r\n    return +new Date();\r\n  };\r\n  try {\r\n    d3_document.createElement(\"div\").style.setProperty(\"opacity\", 0, \"\");\r\n  } catch (error) {\r\n    var d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;\r\n    d3_style_prototype.setProperty = function(name, value, priority) {\r\n      d3_style_setProperty.call(this, name, value + \"\", priority);\r\n    };\r\n  }\r\n  function d3_class(ctor, properties) {\r\n    try {\r\n      for (var key in properties) {\r\n        Object.defineProperty(ctor.prototype, key, {\r\n          value: properties[key],\r\n          enumerable: false\r\n        });\r\n      }\r\n    } catch (e) {\r\n      ctor.prototype = properties;\r\n    }\r\n  }\r\n  var d3_array = d3_arraySlice;\r\n  function d3_arrayCopy(pseudoarray) {\r\n    var i = -1, n = pseudoarray.length, array = [];\r\n    while (++i < n) array.push(pseudoarray[i]);\r\n    return array;\r\n  }\r\n  function d3_arraySlice(pseudoarray) {\r\n    return Array.prototype.slice.call(pseudoarray);\r\n  }\r\n  try {\r\n    d3_array(d3_document.documentElement.childNodes)[0].nodeType;\r\n  } catch (e) {\r\n    d3_array = d3_arrayCopy;\r\n  }\r\n  var d3_arraySubclass = [].__proto__ ? function(array, prototype) {\r\n    array.__proto__ = prototype;\r\n  } : function(array, prototype) {\r\n    for (var property in prototype) array[property] = prototype[property];\r\n  };\r\n  d3.map = function(object) {\r\n    var map = new d3_Map();\r\n    for (var key in object) map.set(key, object[key]);\r\n    return map;\r\n  };\r\n  function d3_Map() {}\r\n  d3_class(d3_Map, {\r\n    has: function(key) {\r\n      return d3_map_prefix + key in this;\r\n    },\r\n    get: function(key) {\r\n      return this[d3_map_prefix + key];\r\n    },\r\n    set: function(key, value) {\r\n      return this[d3_map_prefix + key] = value;\r\n    },\r\n    remove: function(key) {\r\n      key = d3_map_prefix + key;\r\n      return key in this && delete this[key];\r\n    },\r\n    keys: function() {\r\n      var keys = [];\r\n      this.forEach(function(key) {\r\n        keys.push(key);\r\n      });\r\n      return keys;\r\n    },\r\n    values: function() {\r\n      var values = [];\r\n      this.forEach(function(key, value) {\r\n        values.push(value);\r\n      });\r\n      return values;\r\n    },\r\n    entries: function() {\r\n      var entries = [];\r\n      this.forEach(function(key, value) {\r\n        entries.push({\r\n          key: key,\r\n          value: value\r\n        });\r\n      });\r\n      return entries;\r\n    },\r\n    forEach: function(f) {\r\n      for (var key in this) {\r\n        if (key.charCodeAt(0) === d3_map_prefixCode) {\r\n          f.call(this, key.substring(1), this[key]);\r\n        }\r\n      }\r\n    }\r\n  });\r\n  var d3_map_prefix = \"\\0\", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);\r\n  function d3_identity(d) {\r\n    return d;\r\n  }\r\n  function d3_true() {\r\n    return true;\r\n  }\r\n  function d3_functor(v) {\r\n    return typeof v === \"function\" ? v : function() {\r\n      return v;\r\n    };\r\n  }\r\n  d3.functor = d3_functor;\r\n  d3.rebind = function(target, source) {\r\n    var i = 1, n = arguments.length, method;\r\n    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\r\n    return target;\r\n  };\r\n  function d3_rebind(target, source, method) {\r\n    return function() {\r\n      var value = method.apply(source, arguments);\r\n      return arguments.length ? target : value;\r\n    };\r\n  }\r\n  d3.ascending = function(a, b) {\r\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\r\n  };\r\n  d3.descending = function(a, b) {\r\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\r\n  };\r\n  d3.mean = function(array, f) {\r\n    var n = array.length, a, m = 0, i = -1, j = 0;\r\n    if (arguments.length === 1) {\r\n      while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;\r\n    } else {\r\n      while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;\r\n    }\r\n    return j ? m : undefined;\r\n  };\r\n  d3.median = function(array, f) {\r\n    if (arguments.length > 1) array = array.map(f);\r\n    array = array.filter(d3_number);\r\n    return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;\r\n  };\r\n  d3.min = function(array, f) {\r\n    var i = -1, n = array.length, a, b;\r\n    if (arguments.length === 1) {\r\n      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\r\n      while (++i < n) if ((b = array[i]) != null && a > b) a = b;\r\n    } else {\r\n      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\r\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\r\n    }\r\n    return a;\r\n  };\r\n  d3.max = function(array, f) {\r\n    var i = -1, n = array.length, a, b;\r\n    if (arguments.length === 1) {\r\n      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\r\n      while (++i < n) if ((b = array[i]) != null && b > a) a = b;\r\n    } else {\r\n      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\r\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\r\n    }\r\n    return a;\r\n  };\r\n  d3.extent = function(array, f) {\r\n    var i = -1, n = array.length, a, b, c;\r\n    if (arguments.length === 1) {\r\n      while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;\r\n      while (++i < n) if ((b = array[i]) != null) {\r\n        if (a > b) a = b;\r\n        if (c < b) c = b;\r\n      }\r\n    } else {\r\n      while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;\r\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\r\n        if (a > b) a = b;\r\n        if (c < b) c = b;\r\n      }\r\n    }\r\n    return [ a, c ];\r\n  };\r\n  d3.random = {\r\n    normal: function(µ, σ) {\r\n      var n = arguments.length;\r\n      if (n < 2) σ = 1;\r\n      if (n < 1) µ = 0;\r\n      return function() {\r\n        var x, y, r;\r\n        do {\r\n          x = Math.random() * 2 - 1;\r\n          y = Math.random() * 2 - 1;\r\n          r = x * x + y * y;\r\n        } while (!r || r > 1);\r\n        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);\r\n      };\r\n    },\r\n    logNormal: function() {\r\n      var random = d3.random.normal.apply(d3, arguments);\r\n      return function() {\r\n        return Math.exp(random());\r\n      };\r\n    },\r\n    irwinHall: function(m) {\r\n      return function() {\r\n        for (var s = 0, j = 0; j < m; j++) s += Math.random();\r\n        return s / m;\r\n      };\r\n    }\r\n  };\r\n  function d3_number(x) {\r\n    return x != null && !isNaN(x);\r\n  }\r\n  d3.sum = function(array, f) {\r\n    var s = 0, n = array.length, a, i = -1;\r\n    if (arguments.length === 1) {\r\n      while (++i < n) if (!isNaN(a = +array[i])) s += a;\r\n    } else {\r\n      while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;\r\n    }\r\n    return s;\r\n  };\r\n  d3.quantile = function(values, p) {\r\n    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;\r\n    return e ? v + e * (values[h] - v) : v;\r\n  };\r\n  d3.shuffle = function(array) {\r\n    var m = array.length, t, i;\r\n    while (m) {\r\n      i = Math.random() * m-- | 0;\r\n      t = array[m], array[m] = array[i], array[i] = t;\r\n    }\r\n    return array;\r\n  };\r\n  d3.transpose = function(matrix) {\r\n    return d3.zip.apply(d3, matrix);\r\n  };\r\n  d3.zip = function() {\r\n    if (!(n = arguments.length)) return [];\r\n    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {\r\n      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {\r\n        zip[j] = arguments[j][i];\r\n      }\r\n    }\r\n    return zips;\r\n  };\r\n  function d3_zipLength(d) {\r\n    return d.length;\r\n  }\r\n  d3.bisector = function(f) {\r\n    return {\r\n      left: function(a, x, lo, hi) {\r\n        if (arguments.length < 3) lo = 0;\r\n        if (arguments.length < 4) hi = a.length;\r\n        while (lo < hi) {\r\n          var mid = lo + hi >>> 1;\r\n          if (f.call(a, a[mid], mid) < x) lo = mid + 1; else hi = mid;\r\n        }\r\n        return lo;\r\n      },\r\n      right: function(a, x, lo, hi) {\r\n        if (arguments.length < 3) lo = 0;\r\n        if (arguments.length < 4) hi = a.length;\r\n        while (lo < hi) {\r\n          var mid = lo + hi >>> 1;\r\n          if (x < f.call(a, a[mid], mid)) hi = mid; else lo = mid + 1;\r\n        }\r\n        return lo;\r\n      }\r\n    };\r\n  };\r\n  var d3_bisector = d3.bisector(function(d) {\r\n    return d;\r\n  });\r\n  d3.bisectLeft = d3_bisector.left;\r\n  d3.bisect = d3.bisectRight = d3_bisector.right;\r\n  d3.nest = function() {\r\n    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;\r\n    function map(array, depth) {\r\n      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\r\n      var i = -1, n = array.length, key = keys[depth++], keyValue, object, valuesByKey = new d3_Map(), values, o = {};\r\n      while (++i < n) {\r\n        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\r\n          values.push(object);\r\n        } else {\r\n          valuesByKey.set(keyValue, [ object ]);\r\n        }\r\n      }\r\n      valuesByKey.forEach(function(keyValue, values) {\r\n        o[keyValue] = map(values, depth);\r\n      });\r\n      return o;\r\n    }\r\n    function entries(map, depth) {\r\n      if (depth >= keys.length) return map;\r\n      var a = [], sortKey = sortKeys[depth++], key;\r\n      for (key in map) {\r\n        a.push({\r\n          key: key,\r\n          values: entries(map[key], depth)\r\n        });\r\n      }\r\n      if (sortKey) a.sort(function(a, b) {\r\n        return sortKey(a.key, b.key);\r\n      });\r\n      return a;\r\n    }\r\n    nest.map = function(array) {\r\n      return map(array, 0);\r\n    };\r\n    nest.entries = function(array) {\r\n      return entries(map(array, 0), 0);\r\n    };\r\n    nest.key = function(d) {\r\n      keys.push(d);\r\n      return nest;\r\n    };\r\n    nest.sortKeys = function(order) {\r\n      sortKeys[keys.length - 1] = order;\r\n      return nest;\r\n    };\r\n    nest.sortValues = function(order) {\r\n      sortValues = order;\r\n      return nest;\r\n    };\r\n    nest.rollup = function(f) {\r\n      rollup = f;\r\n      return nest;\r\n    };\r\n    return nest;\r\n  };\r\n  d3.keys = function(map) {\r\n    var keys = [];\r\n    for (var key in map) keys.push(key);\r\n    return keys;\r\n  };\r\n  d3.values = function(map) {\r\n    var values = [];\r\n    for (var key in map) values.push(map[key]);\r\n    return values;\r\n  };\r\n  d3.entries = function(map) {\r\n    var entries = [];\r\n    for (var key in map) entries.push({\r\n      key: key,\r\n      value: map[key]\r\n    });\r\n    return entries;\r\n  };\r\n  d3.permute = function(array, indexes) {\r\n    var permutes = [], i = -1, n = indexes.length;\r\n    while (++i < n) permutes[i] = array[indexes[i]];\r\n    return permutes;\r\n  };\r\n  d3.merge = function(arrays) {\r\n    return Array.prototype.concat.apply([], arrays);\r\n  };\r\n  function d3_collapse(s) {\r\n    return s.trim().replace(/\\s+/g, \" \");\r\n  }\r\n  d3.range = function(start, stop, step) {\r\n    if (arguments.length < 3) {\r\n      step = 1;\r\n      if (arguments.length < 2) {\r\n        stop = start;\r\n        start = 0;\r\n      }\r\n    }\r\n    if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\r\n    var range = [], k = d3_range_integerScale(Math.abs(step)), i = -1, j;\r\n    start *= k, stop *= k, step *= k;\r\n    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\r\n    return range;\r\n  };\r\n  function d3_range_integerScale(x) {\r\n    var k = 1;\r\n    while (x * k % 1) k *= 10;\r\n    return k;\r\n  }\r\n  d3.requote = function(s) {\r\n    return s.replace(d3_requote_re, \"\\\\$&\");\r\n  };\r\n  var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\r\n  d3.round = function(x, n) {\r\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\r\n  };\r\n  d3.xhr = function(url, mimeType, callback) {\r\n    var xhr = {}, dispatch = d3.dispatch(\"progress\", \"load\", \"error\"), headers = {}, response = d3_identity, request = new (d3_window.XDomainRequest && /^(http(s)?:)?\\/\\//.test(url) ? XDomainRequest : XMLHttpRequest)();\r\n    \"onload\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {\r\n      request.readyState > 3 && respond();\r\n    };\r\n    function respond() {\r\n      var s = request.status;\r\n      !s && request.responseText || s >= 200 && s < 300 || s === 304 ? dispatch.load.call(xhr, response.call(xhr, request)) : dispatch.error.call(xhr, request);\r\n    }\r\n    request.onprogress = function(event) {\r\n      var o = d3.event;\r\n      d3.event = event;\r\n      try {\r\n        dispatch.progress.call(xhr, request);\r\n      } finally {\r\n        d3.event = o;\r\n      }\r\n    };\r\n    xhr.header = function(name, value) {\r\n      name = (name + \"\").toLowerCase();\r\n      if (arguments.length < 2) return headers[name];\r\n      if (value == null) delete headers[name]; else headers[name] = value + \"\";\r\n      return xhr;\r\n    };\r\n    xhr.mimeType = function(value) {\r\n      if (!arguments.length) return mimeType;\r\n      mimeType = value == null ? null : value + \"\";\r\n      return xhr;\r\n    };\r\n    xhr.response = function(value) {\r\n      response = value;\r\n      return xhr;\r\n    };\r\n    [ \"get\", \"post\" ].forEach(function(method) {\r\n      xhr[method] = function() {\r\n        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));\r\n      };\r\n    });\r\n    xhr.send = function(method, data, callback) {\r\n      if (arguments.length === 2 && typeof data === \"function\") callback = data, data = null;\r\n      request.open(method, url, true);\r\n      if (mimeType != null && !(\"accept\" in headers)) headers[\"accept\"] = mimeType + \",*/*\";\r\n      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\r\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\r\n      if (callback != null) xhr.on(\"error\", callback).on(\"load\", function(request) {\r\n        callback(null, request);\r\n      });\r\n      request.send(data == null ? null : data);\r\n      return xhr;\r\n    };\r\n    xhr.abort = function() {\r\n      request.abort();\r\n      return xhr;\r\n    };\r\n    d3.rebind(xhr, dispatch, \"on\");\r\n    if (arguments.length === 2 && typeof mimeType === \"function\") callback = mimeType, \r\n    mimeType = null;\r\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\r\n  };\r\n  function d3_xhr_fixCallback(callback) {\r\n    return callback.length === 1 ? function(error, request) {\r\n      callback(error == null ? request : null);\r\n    } : callback;\r\n  }\r\n  d3.text = function() {\r\n    return d3.xhr.apply(d3, arguments).response(d3_text);\r\n  };\r\n  function d3_text(request) {\r\n    return request.responseText;\r\n  }\r\n  d3.json = function(url, callback) {\r\n    return d3.xhr(url, \"application/json\", callback).response(d3_json);\r\n  };\r\n  function d3_json(request) {\r\n    return JSON.parse(request.responseText);\r\n  }\r\n  d3.html = function(url, callback) {\r\n    return d3.xhr(url, \"text/html\", callback).response(d3_html);\r\n  };\r\n  function d3_html(request) {\r\n    var range = d3_document.createRange();\r\n    range.selectNode(d3_document.body);\r\n    return range.createContextualFragment(request.responseText);\r\n  }\r\n  d3.xml = function() {\r\n    return d3.xhr.apply(d3, arguments).response(d3_xml);\r\n  };\r\n  function d3_xml(request) {\r\n    return request.responseXML;\r\n  }\r\n  var d3_nsPrefix = {\r\n    svg: \"http://www.w3.org/2000/svg\",\r\n    xhtml: \"http://www.w3.org/1999/xhtml\",\r\n    xlink: \"http://www.w3.org/1999/xlink\",\r\n    xml: \"http://www.w3.org/XML/1998/namespace\",\r\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\r\n  };\r\n  d3.ns = {\r\n    prefix: d3_nsPrefix,\r\n    qualify: function(name) {\r\n      var i = name.indexOf(\":\"), prefix = name;\r\n      if (i >= 0) {\r\n        prefix = name.substring(0, i);\r\n        name = name.substring(i + 1);\r\n      }\r\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\r\n        space: d3_nsPrefix[prefix],\r\n        local: name\r\n      } : name;\r\n    }\r\n  };\r\n  d3.dispatch = function() {\r\n    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;\r\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\r\n    return dispatch;\r\n  };\r\n  function d3_dispatch() {}\r\n  d3_dispatch.prototype.on = function(type, listener) {\r\n    var i = type.indexOf(\".\"), name = \"\";\r\n    if (i > 0) {\r\n      name = type.substring(i + 1);\r\n      type = type.substring(0, i);\r\n    }\r\n    return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\r\n  };\r\n  function d3_dispatch_event(dispatch) {\r\n    var listeners = [], listenerByName = new d3_Map();\r\n    function event() {\r\n      var z = listeners, i = -1, n = z.length, l;\r\n      while (++i < n) if (l = z[i].on) l.apply(this, arguments);\r\n      return dispatch;\r\n    }\r\n    event.on = function(name, listener) {\r\n      var l = listenerByName.get(name), i;\r\n      if (arguments.length < 2) return l && l.on;\r\n      if (l) {\r\n        l.on = null;\r\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\r\n        listenerByName.remove(name);\r\n      }\r\n      if (listener) listeners.push(listenerByName.set(name, {\r\n        on: listener\r\n      }));\r\n      return dispatch;\r\n    };\r\n    return event;\r\n  }\r\n  d3.format = function(specifier) {\r\n    var match = d3_format_re.exec(specifier), fill = match[1] || \" \", align = match[2] || \">\", sign = match[3] || \"\", basePrefix = match[4] || \"\", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, suffix = \"\", integer = false;\r\n    if (precision) precision = +precision.substring(1);\r\n    if (zfill || fill === \"0\" && align === \"=\") {\r\n      zfill = fill = \"0\";\r\n      align = \"=\";\r\n      if (comma) width -= Math.floor((width - 1) / 4);\r\n    }\r\n    switch (type) {\r\n     case \"n\":\r\n      comma = true;\r\n      type = \"g\";\r\n      break;\r\n\r\n     case \"%\":\r\n      scale = 100;\r\n      suffix = \"%\";\r\n      type = \"f\";\r\n      break;\r\n\r\n     case \"p\":\r\n      scale = 100;\r\n      suffix = \"%\";\r\n      type = \"r\";\r\n      break;\r\n\r\n     case \"b\":\r\n     case \"o\":\r\n     case \"x\":\r\n     case \"X\":\r\n      if (basePrefix) basePrefix = \"0\" + type.toLowerCase();\r\n\r\n     case \"c\":\r\n     case \"d\":\r\n      integer = true;\r\n      precision = 0;\r\n      break;\r\n\r\n     case \"s\":\r\n      scale = -1;\r\n      type = \"r\";\r\n      break;\r\n    }\r\n    if (basePrefix === \"#\") basePrefix = \"\";\r\n    if (type == \"r\" && !precision) type = \"g\";\r\n    type = d3_format_types.get(type) || d3_format_typeDefault;\r\n    var zcomma = zfill && comma;\r\n    return function(value) {\r\n      if (integer && value % 1) return \"\";\r\n      var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign;\r\n      if (scale < 0) {\r\n        var prefix = d3.formatPrefix(value, precision);\r\n        value = prefix.scale(value);\r\n        suffix = prefix.symbol;\r\n      } else {\r\n        value *= scale;\r\n      }\r\n      value = type(value, precision);\r\n      if (!zfill && comma) value = d3_format_group(value);\r\n      var length = basePrefix.length + value.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\r\n      if (zcomma) value = d3_format_group(padding + value);\r\n      if (d3_format_decimalPoint) value.replace(\".\", d3_format_decimalPoint);\r\n      negative += basePrefix;\r\n      return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix;\r\n    };\r\n  };\r\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?(#)?(0)?([0-9]+)?(,)?(\\.[0-9]+)?([a-zA-Z%])?/;\r\n  var d3_format_types = d3.map({\r\n    b: function(x) {\r\n      return x.toString(2);\r\n    },\r\n    c: function(x) {\r\n      return String.fromCharCode(x);\r\n    },\r\n    o: function(x) {\r\n      return x.toString(8);\r\n    },\r\n    x: function(x) {\r\n      return x.toString(16);\r\n    },\r\n    X: function(x) {\r\n      return x.toString(16).toUpperCase();\r\n    },\r\n    g: function(x, p) {\r\n      return x.toPrecision(p);\r\n    },\r\n    e: function(x, p) {\r\n      return x.toExponential(p);\r\n    },\r\n    f: function(x, p) {\r\n      return x.toFixed(p);\r\n    },\r\n    r: function(x, p) {\r\n      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\r\n    }\r\n  });\r\n  function d3_format_precision(x, p) {\r\n    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\r\n  }\r\n  function d3_format_typeDefault(x) {\r\n    return x + \"\";\r\n  }\r\n  var d3_format_group = d3_identity;\r\n  if (d3_format_grouping) {\r\n    var d3_format_groupingLength = d3_format_grouping.length;\r\n    d3_format_group = function(value) {\r\n      var i = value.lastIndexOf(\".\"), f = i >= 0 ? \".\" + value.substring(i + 1) : (i = value.length, \r\n      \"\"), t = [], j = 0, g = d3_format_grouping[0];\r\n      while (i > 0 && g > 0) {\r\n        t.push(value.substring(i -= g, i + g));\r\n        g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];\r\n      }\r\n      return t.reverse().join(d3_format_thousandsSeparator || \"\") + f;\r\n    };\r\n  }\r\n  var d3_formatPrefixes = [ \"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"µ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\" ].map(d3_formatPrefix);\r\n  d3.formatPrefix = function(value, precision) {\r\n    var i = 0;\r\n    if (value) {\r\n      if (value < 0) value *= -1;\r\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\r\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\r\n      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\r\n    }\r\n    return d3_formatPrefixes[8 + i / 3];\r\n  };\r\n  function d3_formatPrefix(d, i) {\r\n    var k = Math.pow(10, Math.abs(8 - i) * 3);\r\n    return {\r\n      scale: i > 8 ? function(d) {\r\n        return d / k;\r\n      } : function(d) {\r\n        return d * k;\r\n      },\r\n      symbol: d\r\n    };\r\n  }\r\n  var d3_ease_default = function() {\r\n    return d3_identity;\r\n  };\r\n  var d3_ease = d3.map({\r\n    linear: d3_ease_default,\r\n    poly: d3_ease_poly,\r\n    quad: function() {\r\n      return d3_ease_quad;\r\n    },\r\n    cubic: function() {\r\n      return d3_ease_cubic;\r\n    },\r\n    sin: function() {\r\n      return d3_ease_sin;\r\n    },\r\n    exp: function() {\r\n      return d3_ease_exp;\r\n    },\r\n    circle: function() {\r\n      return d3_ease_circle;\r\n    },\r\n    elastic: d3_ease_elastic,\r\n    back: d3_ease_back,\r\n    bounce: function() {\r\n      return d3_ease_bounce;\r\n    }\r\n  });\r\n  var d3_ease_mode = d3.map({\r\n    \"in\": d3_identity,\r\n    out: d3_ease_reverse,\r\n    \"in-out\": d3_ease_reflect,\r\n    \"out-in\": function(f) {\r\n      return d3_ease_reflect(d3_ease_reverse(f));\r\n    }\r\n  });\r\n  d3.ease = function(name) {\r\n    var i = name.indexOf(\"-\"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : \"in\";\r\n    t = d3_ease.get(t) || d3_ease_default;\r\n    m = d3_ease_mode.get(m) || d3_identity;\r\n    return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));\r\n  };\r\n  function d3_ease_clamp(f) {\r\n    return function(t) {\r\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\r\n    };\r\n  }\r\n  function d3_ease_reverse(f) {\r\n    return function(t) {\r\n      return 1 - f(1 - t);\r\n    };\r\n  }\r\n  function d3_ease_reflect(f) {\r\n    return function(t) {\r\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\r\n    };\r\n  }\r\n  function d3_ease_quad(t) {\r\n    return t * t;\r\n  }\r\n  function d3_ease_cubic(t) {\r\n    return t * t * t;\r\n  }\r\n  function d3_ease_cubicInOut(t) {\r\n    if (t <= 0) return 0;\r\n    if (t >= 1) return 1;\r\n    var t2 = t * t, t3 = t2 * t;\r\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\r\n  }\r\n  function d3_ease_poly(e) {\r\n    return function(t) {\r\n      return Math.pow(t, e);\r\n    };\r\n  }\r\n  function d3_ease_sin(t) {\r\n    return 1 - Math.cos(t * π / 2);\r\n  }\r\n  function d3_ease_exp(t) {\r\n    return Math.pow(2, 10 * (t - 1));\r\n  }\r\n  function d3_ease_circle(t) {\r\n    return 1 - Math.sqrt(1 - t * t);\r\n  }\r\n  function d3_ease_elastic(a, p) {\r\n    var s;\r\n    if (arguments.length < 2) p = .45;\r\n    if (arguments.length) s = p / (2 * π) * Math.asin(1 / a); else a = 1, s = p / 4;\r\n    return function(t) {\r\n      return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * π / p);\r\n    };\r\n  }\r\n  function d3_ease_back(s) {\r\n    if (!s) s = 1.70158;\r\n    return function(t) {\r\n      return t * t * ((s + 1) * t - s);\r\n    };\r\n  }\r\n  function d3_ease_bounce(t) {\r\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\r\n  }\r\n  d3.event = null;\r\n  function d3_eventCancel() {\r\n    d3.event.stopPropagation();\r\n    d3.event.preventDefault();\r\n  }\r\n  function d3_eventSource() {\r\n    var e = d3.event, s;\r\n    while (s = e.sourceEvent) e = s;\r\n    return e;\r\n  }\r\n  function d3_eventDispatch(target) {\r\n    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;\r\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\r\n    dispatch.of = function(thiz, argumentz) {\r\n      return function(e1) {\r\n        try {\r\n          var e0 = e1.sourceEvent = d3.event;\r\n          e1.target = target;\r\n          d3.event = e1;\r\n          dispatch[e1.type].apply(thiz, argumentz);\r\n        } finally {\r\n          d3.event = e0;\r\n        }\r\n      };\r\n    };\r\n    return dispatch;\r\n  }\r\n  d3.transform = function(string) {\r\n    var g = d3_document.createElementNS(d3.ns.prefix.svg, \"g\");\r\n    return (d3.transform = function(string) {\r\n      g.setAttribute(\"transform\", string);\r\n      var t = g.transform.baseVal.consolidate();\r\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\r\n    })(string);\r\n  };\r\n  function d3_transform(m) {\r\n    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\r\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\r\n      r0[0] *= -1;\r\n      r0[1] *= -1;\r\n      kx *= -1;\r\n      kz *= -1;\r\n    }\r\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\r\n    this.translate = [ m.e, m.f ];\r\n    this.scale = [ kx, ky ];\r\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\r\n  }\r\n  d3_transform.prototype.toString = function() {\r\n    return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\";\r\n  };\r\n  function d3_transformDot(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1];\r\n  }\r\n  function d3_transformNormalize(a) {\r\n    var k = Math.sqrt(d3_transformDot(a, a));\r\n    if (k) {\r\n      a[0] /= k;\r\n      a[1] /= k;\r\n    }\r\n    return k;\r\n  }\r\n  function d3_transformCombine(a, b, k) {\r\n    a[0] += k * b[0];\r\n    a[1] += k * b[1];\r\n    return a;\r\n  }\r\n  var d3_transformIdentity = {\r\n    a: 1,\r\n    b: 0,\r\n    c: 0,\r\n    d: 1,\r\n    e: 0,\r\n    f: 0\r\n  };\r\n  d3.interpolate = function(a, b) {\r\n    var i = d3.interpolators.length, f;\r\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;\r\n    return f;\r\n  };\r\n  d3.interpolateNumber = function(a, b) {\r\n    b -= a;\r\n    return function(t) {\r\n      return a + b * t;\r\n    };\r\n  };\r\n  d3.interpolateRound = function(a, b) {\r\n    b -= a;\r\n    return function(t) {\r\n      return Math.round(a + b * t);\r\n    };\r\n  };\r\n  d3.interpolateString = function(a, b) {\r\n    var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;\r\n    d3_interpolate_number.lastIndex = 0;\r\n    for (i = 0; m = d3_interpolate_number.exec(b); ++i) {\r\n      if (m.index) s.push(b.substring(s0, s1 = m.index));\r\n      q.push({\r\n        i: s.length,\r\n        x: m[0]\r\n      });\r\n      s.push(null);\r\n      s0 = d3_interpolate_number.lastIndex;\r\n    }\r\n    if (s0 < b.length) s.push(b.substring(s0));\r\n    for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {\r\n      o = q[i];\r\n      if (o.x == m[0]) {\r\n        if (o.i) {\r\n          if (s[o.i + 1] == null) {\r\n            s[o.i - 1] += o.x;\r\n            s.splice(o.i, 1);\r\n            for (j = i + 1; j < n; ++j) q[j].i--;\r\n          } else {\r\n            s[o.i - 1] += o.x + s[o.i + 1];\r\n            s.splice(o.i, 2);\r\n            for (j = i + 1; j < n; ++j) q[j].i -= 2;\r\n          }\r\n        } else {\r\n          if (s[o.i + 1] == null) {\r\n            s[o.i] = o.x;\r\n          } else {\r\n            s[o.i] = o.x + s[o.i + 1];\r\n            s.splice(o.i + 1, 1);\r\n            for (j = i + 1; j < n; ++j) q[j].i--;\r\n          }\r\n        }\r\n        q.splice(i, 1);\r\n        n--;\r\n        i--;\r\n      } else {\r\n        o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));\r\n      }\r\n    }\r\n    while (i < n) {\r\n      o = q.pop();\r\n      if (s[o.i + 1] == null) {\r\n        s[o.i] = o.x;\r\n      } else {\r\n        s[o.i] = o.x + s[o.i + 1];\r\n        s.splice(o.i + 1, 1);\r\n      }\r\n      n--;\r\n    }\r\n    if (s.length === 1) {\r\n      return s[0] == null ? q[0].x : function() {\r\n        return b;\r\n      };\r\n    }\r\n    return function(t) {\r\n      for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);\r\n      return s.join(\"\");\r\n    };\r\n  };\r\n  d3.interpolateTransform = function(a, b) {\r\n    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;\r\n    if (ta[0] != tb[0] || ta[1] != tb[1]) {\r\n      s.push(\"translate(\", null, \",\", null, \")\");\r\n      q.push({\r\n        i: 1,\r\n        x: d3.interpolateNumber(ta[0], tb[0])\r\n      }, {\r\n        i: 3,\r\n        x: d3.interpolateNumber(ta[1], tb[1])\r\n      });\r\n    } else if (tb[0] || tb[1]) {\r\n      s.push(\"translate(\" + tb + \")\");\r\n    } else {\r\n      s.push(\"\");\r\n    }\r\n    if (ra != rb) {\r\n      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;\r\n      q.push({\r\n        i: s.push(s.pop() + \"rotate(\", null, \")\") - 2,\r\n        x: d3.interpolateNumber(ra, rb)\r\n      });\r\n    } else if (rb) {\r\n      s.push(s.pop() + \"rotate(\" + rb + \")\");\r\n    }\r\n    if (wa != wb) {\r\n      q.push({\r\n        i: s.push(s.pop() + \"skewX(\", null, \")\") - 2,\r\n        x: d3.interpolateNumber(wa, wb)\r\n      });\r\n    } else if (wb) {\r\n      s.push(s.pop() + \"skewX(\" + wb + \")\");\r\n    }\r\n    if (ka[0] != kb[0] || ka[1] != kb[1]) {\r\n      n = s.push(s.pop() + \"scale(\", null, \",\", null, \")\");\r\n      q.push({\r\n        i: n - 4,\r\n        x: d3.interpolateNumber(ka[0], kb[0])\r\n      }, {\r\n        i: n - 2,\r\n        x: d3.interpolateNumber(ka[1], kb[1])\r\n      });\r\n    } else if (kb[0] != 1 || kb[1] != 1) {\r\n      s.push(s.pop() + \"scale(\" + kb + \")\");\r\n    }\r\n    n = q.length;\r\n    return function(t) {\r\n      var i = -1, o;\r\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\r\n      return s.join(\"\");\r\n    };\r\n  };\r\n  d3.interpolateRgb = function(a, b) {\r\n    a = d3.rgb(a);\r\n    b = d3.rgb(b);\r\n    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;\r\n    return function(t) {\r\n      return \"#\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\r\n    };\r\n  };\r\n  d3.interpolateHsl = function(a, b) {\r\n    a = d3.hsl(a);\r\n    b = d3.hsl(b);\r\n    var h0 = a.h, s0 = a.s, l0 = a.l, h1 = b.h - h0, s1 = b.s - s0, l1 = b.l - l0;\r\n    if (h1 > 180) h1 -= 360; else if (h1 < -180) h1 += 360;\r\n    return function(t) {\r\n      return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t) + \"\";\r\n    };\r\n  };\r\n  d3.interpolateLab = function(a, b) {\r\n    a = d3.lab(a);\r\n    b = d3.lab(b);\r\n    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;\r\n    return function(t) {\r\n      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\r\n    };\r\n  };\r\n  d3.interpolateHcl = function(a, b) {\r\n    a = d3.hcl(a);\r\n    b = d3.hcl(b);\r\n    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;\r\n    if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\r\n    return function(t) {\r\n      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\r\n    };\r\n  };\r\n  d3.interpolateArray = function(a, b) {\r\n    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;\r\n    for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));\r\n    for (;i < na; ++i) c[i] = a[i];\r\n    for (;i < nb; ++i) c[i] = b[i];\r\n    return function(t) {\r\n      for (i = 0; i < n0; ++i) c[i] = x[i](t);\r\n      return c;\r\n    };\r\n  };\r\n  d3.interpolateObject = function(a, b) {\r\n    var i = {}, c = {}, k;\r\n    for (k in a) {\r\n      if (k in b) {\r\n        i[k] = d3_interpolateByName(k)(a[k], b[k]);\r\n      } else {\r\n        c[k] = a[k];\r\n      }\r\n    }\r\n    for (k in b) {\r\n      if (!(k in a)) {\r\n        c[k] = b[k];\r\n      }\r\n    }\r\n    return function(t) {\r\n      for (k in i) c[k] = i[k](t);\r\n      return c;\r\n    };\r\n  };\r\n  var d3_interpolate_number = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\r\n  function d3_interpolateByName(name) {\r\n    return name == \"transform\" ? d3.interpolateTransform : d3.interpolate;\r\n  }\r\n  d3.interpolators = [ d3.interpolateObject, function(a, b) {\r\n    return b instanceof Array && d3.interpolateArray(a, b);\r\n  }, function(a, b) {\r\n    return (typeof a === \"string\" || typeof b === \"string\") && d3.interpolateString(a + \"\", b + \"\");\r\n  }, function(a, b) {\r\n    return (typeof b === \"string\" ? d3_rgb_names.has(b) || /^(#|rgb\\(|hsl\\()/.test(b) : b instanceof d3_Color) && d3.interpolateRgb(a, b);\r\n  }, function(a, b) {\r\n    return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b);\r\n  } ];\r\n  function d3_uninterpolateNumber(a, b) {\r\n    b = b - (a = +a) ? 1 / (b - a) : 0;\r\n    return function(x) {\r\n      return (x - a) * b;\r\n    };\r\n  }\r\n  function d3_uninterpolateClamp(a, b) {\r\n    b = b - (a = +a) ? 1 / (b - a) : 0;\r\n    return function(x) {\r\n      return Math.max(0, Math.min(1, (x - a) * b));\r\n    };\r\n  }\r\n  function d3_Color() {}\r\n  d3_Color.prototype.toString = function() {\r\n    return this.rgb() + \"\";\r\n  };\r\n  d3.rgb = function(r, g, b) {\r\n    return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);\r\n  };\r\n  function d3_rgb(r, g, b) {\r\n    return new d3_Rgb(r, g, b);\r\n  }\r\n  function d3_Rgb(r, g, b) {\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n  }\r\n  var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();\r\n  d3_rgbPrototype.brighter = function(k) {\r\n    k = Math.pow(.7, arguments.length ? k : 1);\r\n    var r = this.r, g = this.g, b = this.b, i = 30;\r\n    if (!r && !g && !b) return d3_rgb(i, i, i);\r\n    if (r && r < i) r = i;\r\n    if (g && g < i) g = i;\r\n    if (b && b < i) b = i;\r\n    return d3_rgb(Math.min(255, Math.floor(r / k)), Math.min(255, Math.floor(g / k)), Math.min(255, Math.floor(b / k)));\r\n  };\r\n  d3_rgbPrototype.darker = function(k) {\r\n    k = Math.pow(.7, arguments.length ? k : 1);\r\n    return d3_rgb(Math.floor(k * this.r), Math.floor(k * this.g), Math.floor(k * this.b));\r\n  };\r\n  d3_rgbPrototype.hsl = function() {\r\n    return d3_rgb_hsl(this.r, this.g, this.b);\r\n  };\r\n  d3_rgbPrototype.toString = function() {\r\n    return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\r\n  };\r\n  function d3_rgb_hex(v) {\r\n    return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\r\n  }\r\n  function d3_rgb_parse(format, rgb, hsl) {\r\n    var r = 0, g = 0, b = 0, m1, m2, name;\r\n    m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\r\n    if (m1) {\r\n      m2 = m1[2].split(\",\");\r\n      switch (m1[1]) {\r\n       case \"hsl\":\r\n        {\r\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\r\n        }\r\n\r\n       case \"rgb\":\r\n        {\r\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\r\n        }\r\n      }\r\n    }\r\n    if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);\r\n    if (format != null && format.charAt(0) === \"#\") {\r\n      if (format.length === 4) {\r\n        r = format.charAt(1);\r\n        r += r;\r\n        g = format.charAt(2);\r\n        g += g;\r\n        b = format.charAt(3);\r\n        b += b;\r\n      } else if (format.length === 7) {\r\n        r = format.substring(1, 3);\r\n        g = format.substring(3, 5);\r\n        b = format.substring(5, 7);\r\n      }\r\n      r = parseInt(r, 16);\r\n      g = parseInt(g, 16);\r\n      b = parseInt(b, 16);\r\n    }\r\n    return rgb(r, g, b);\r\n  }\r\n  function d3_rgb_hsl(r, g, b) {\r\n    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;\r\n    if (d) {\r\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\r\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;\r\n      h *= 60;\r\n    } else {\r\n      s = h = 0;\r\n    }\r\n    return d3_hsl(h, s, l);\r\n  }\r\n  function d3_rgb_lab(r, g, b) {\r\n    r = d3_rgb_xyz(r);\r\n    g = d3_rgb_xyz(g);\r\n    b = d3_rgb_xyz(b);\r\n    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\r\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\r\n  }\r\n  function d3_rgb_xyz(r) {\r\n    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\r\n  }\r\n  function d3_rgb_parseNumber(c) {\r\n    var f = parseFloat(c);\r\n    return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\r\n  }\r\n  var d3_rgb_names = d3.map({\r\n    aliceblue: \"#f0f8ff\",\r\n    antiquewhite: \"#faebd7\",\r\n    aqua: \"#00ffff\",\r\n    aquamarine: \"#7fffd4\",\r\n    azure: \"#f0ffff\",\r\n    beige: \"#f5f5dc\",\r\n    bisque: \"#ffe4c4\",\r\n    black: \"#000000\",\r\n    blanchedalmond: \"#ffebcd\",\r\n    blue: \"#0000ff\",\r\n    blueviolet: \"#8a2be2\",\r\n    brown: \"#a52a2a\",\r\n    burlywood: \"#deb887\",\r\n    cadetblue: \"#5f9ea0\",\r\n    chartreuse: \"#7fff00\",\r\n    chocolate: \"#d2691e\",\r\n    coral: \"#ff7f50\",\r\n    cornflowerblue: \"#6495ed\",\r\n    cornsilk: \"#fff8dc\",\r\n    crimson: \"#dc143c\",\r\n    cyan: \"#00ffff\",\r\n    darkblue: \"#00008b\",\r\n    darkcyan: \"#008b8b\",\r\n    darkgoldenrod: \"#b8860b\",\r\n    darkgray: \"#a9a9a9\",\r\n    darkgreen: \"#006400\",\r\n    darkgrey: \"#a9a9a9\",\r\n    darkkhaki: \"#bdb76b\",\r\n    darkmagenta: \"#8b008b\",\r\n    darkolivegreen: \"#556b2f\",\r\n    darkorange: \"#ff8c00\",\r\n    darkorchid: \"#9932cc\",\r\n    darkred: \"#8b0000\",\r\n    darksalmon: \"#e9967a\",\r\n    darkseagreen: \"#8fbc8f\",\r\n    darkslateblue: \"#483d8b\",\r\n    darkslategray: \"#2f4f4f\",\r\n    darkslategrey: \"#2f4f4f\",\r\n    darkturquoise: \"#00ced1\",\r\n    darkviolet: \"#9400d3\",\r\n    deeppink: \"#ff1493\",\r\n    deepskyblue: \"#00bfff\",\r\n    dimgray: \"#696969\",\r\n    dimgrey: \"#696969\",\r\n    dodgerblue: \"#1e90ff\",\r\n    firebrick: \"#b22222\",\r\n    floralwhite: \"#fffaf0\",\r\n    forestgreen: \"#228b22\",\r\n    fuchsia: \"#ff00ff\",\r\n    gainsboro: \"#dcdcdc\",\r\n    ghostwhite: \"#f8f8ff\",\r\n    gold: \"#ffd700\",\r\n    goldenrod: \"#daa520\",\r\n    gray: \"#808080\",\r\n    green: \"#008000\",\r\n    greenyellow: \"#adff2f\",\r\n    grey: \"#808080\",\r\n    honeydew: \"#f0fff0\",\r\n    hotpink: \"#ff69b4\",\r\n    indianred: \"#cd5c5c\",\r\n    indigo: \"#4b0082\",\r\n    ivory: \"#fffff0\",\r\n    khaki: \"#f0e68c\",\r\n    lavender: \"#e6e6fa\",\r\n    lavenderblush: \"#fff0f5\",\r\n    lawngreen: \"#7cfc00\",\r\n    lemonchiffon: \"#fffacd\",\r\n    lightblue: \"#add8e6\",\r\n    lightcoral: \"#f08080\",\r\n    lightcyan: \"#e0ffff\",\r\n    lightgoldenrodyellow: \"#fafad2\",\r\n    lightgray: \"#d3d3d3\",\r\n    lightgreen: \"#90ee90\",\r\n    lightgrey: \"#d3d3d3\",\r\n    lightpink: \"#ffb6c1\",\r\n    lightsalmon: \"#ffa07a\",\r\n    lightseagreen: \"#20b2aa\",\r\n    lightskyblue: \"#87cefa\",\r\n    lightslategray: \"#778899\",\r\n    lightslategrey: \"#778899\",\r\n    lightsteelblue: \"#b0c4de\",\r\n    lightyellow: \"#ffffe0\",\r\n    lime: \"#00ff00\",\r\n    limegreen: \"#32cd32\",\r\n    linen: \"#faf0e6\",\r\n    magenta: \"#ff00ff\",\r\n    maroon: \"#800000\",\r\n    mediumaquamarine: \"#66cdaa\",\r\n    mediumblue: \"#0000cd\",\r\n    mediumorchid: \"#ba55d3\",\r\n    mediumpurple: \"#9370db\",\r\n    mediumseagreen: \"#3cb371\",\r\n    mediumslateblue: \"#7b68ee\",\r\n    mediumspringgreen: \"#00fa9a\",\r\n    mediumturquoise: \"#48d1cc\",\r\n    mediumvioletred: \"#c71585\",\r\n    midnightblue: \"#191970\",\r\n    mintcream: \"#f5fffa\",\r\n    mistyrose: \"#ffe4e1\",\r\n    moccasin: \"#ffe4b5\",\r\n    navajowhite: \"#ffdead\",\r\n    navy: \"#000080\",\r\n    oldlace: \"#fdf5e6\",\r\n    olive: \"#808000\",\r\n    olivedrab: \"#6b8e23\",\r\n    orange: \"#ffa500\",\r\n    orangered: \"#ff4500\",\r\n    orchid: \"#da70d6\",\r\n    palegoldenrod: \"#eee8aa\",\r\n    palegreen: \"#98fb98\",\r\n    paleturquoise: \"#afeeee\",\r\n    palevioletred: \"#db7093\",\r\n    papayawhip: \"#ffefd5\",\r\n    peachpuff: \"#ffdab9\",\r\n    peru: \"#cd853f\",\r\n    pink: \"#ffc0cb\",\r\n    plum: \"#dda0dd\",\r\n    powderblue: \"#b0e0e6\",\r\n    purple: \"#800080\",\r\n    red: \"#ff0000\",\r\n    rosybrown: \"#bc8f8f\",\r\n    royalblue: \"#4169e1\",\r\n    saddlebrown: \"#8b4513\",\r\n    salmon: \"#fa8072\",\r\n    sandybrown: \"#f4a460\",\r\n    seagreen: \"#2e8b57\",\r\n    seashell: \"#fff5ee\",\r\n    sienna: \"#a0522d\",\r\n    silver: \"#c0c0c0\",\r\n    skyblue: \"#87ceeb\",\r\n    slateblue: \"#6a5acd\",\r\n    slategray: \"#708090\",\r\n    slategrey: \"#708090\",\r\n    snow: \"#fffafa\",\r\n    springgreen: \"#00ff7f\",\r\n    steelblue: \"#4682b4\",\r\n    tan: \"#d2b48c\",\r\n    teal: \"#008080\",\r\n    thistle: \"#d8bfd8\",\r\n    tomato: \"#ff6347\",\r\n    turquoise: \"#40e0d0\",\r\n    violet: \"#ee82ee\",\r\n    wheat: \"#f5deb3\",\r\n    white: \"#ffffff\",\r\n    whitesmoke: \"#f5f5f5\",\r\n    yellow: \"#ffff00\",\r\n    yellowgreen: \"#9acd32\"\r\n  });\r\n  d3_rgb_names.forEach(function(key, value) {\r\n    d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));\r\n  });\r\n  d3.hsl = function(h, s, l) {\r\n    return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);\r\n  };\r\n  function d3_hsl(h, s, l) {\r\n    return new d3_Hsl(h, s, l);\r\n  }\r\n  function d3_Hsl(h, s, l) {\r\n    this.h = h;\r\n    this.s = s;\r\n    this.l = l;\r\n  }\r\n  var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();\r\n  d3_hslPrototype.brighter = function(k) {\r\n    k = Math.pow(.7, arguments.length ? k : 1);\r\n    return d3_hsl(this.h, this.s, this.l / k);\r\n  };\r\n  d3_hslPrototype.darker = function(k) {\r\n    k = Math.pow(.7, arguments.length ? k : 1);\r\n    return d3_hsl(this.h, this.s, k * this.l);\r\n  };\r\n  d3_hslPrototype.rgb = function() {\r\n    return d3_hsl_rgb(this.h, this.s, this.l);\r\n  };\r\n  function d3_hsl_rgb(h, s, l) {\r\n    var m1, m2;\r\n    h = h % 360;\r\n    if (h < 0) h += 360;\r\n    s = s < 0 ? 0 : s > 1 ? 1 : s;\r\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\r\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\r\n    m1 = 2 * l - m2;\r\n    function v(h) {\r\n      if (h > 360) h -= 360; else if (h < 0) h += 360;\r\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\r\n      if (h < 180) return m2;\r\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\r\n      return m1;\r\n    }\r\n    function vv(h) {\r\n      return Math.round(v(h) * 255);\r\n    }\r\n    return d3_rgb(vv(h + 120), vv(h), vv(h - 120));\r\n  }\r\n  d3.hcl = function(h, c, l) {\r\n    return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);\r\n  };\r\n  function d3_hcl(h, c, l) {\r\n    return new d3_Hcl(h, c, l);\r\n  }\r\n  function d3_Hcl(h, c, l) {\r\n    this.h = h;\r\n    this.c = c;\r\n    this.l = l;\r\n  }\r\n  var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();\r\n  d3_hclPrototype.brighter = function(k) {\r\n    return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\r\n  };\r\n  d3_hclPrototype.darker = function(k) {\r\n    return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\r\n  };\r\n  d3_hclPrototype.rgb = function() {\r\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\r\n  };\r\n  function d3_hcl_lab(h, c, l) {\r\n    return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\r\n  }\r\n  d3.lab = function(l, a, b) {\r\n    return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);\r\n  };\r\n  function d3_lab(l, a, b) {\r\n    return new d3_Lab(l, a, b);\r\n  }\r\n  function d3_Lab(l, a, b) {\r\n    this.l = l;\r\n    this.a = a;\r\n    this.b = b;\r\n  }\r\n  var d3_lab_K = 18;\r\n  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;\r\n  var d3_labPrototype = d3_Lab.prototype = new d3_Color();\r\n  d3_labPrototype.brighter = function(k) {\r\n    return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\r\n  };\r\n  d3_labPrototype.darker = function(k) {\r\n    return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\r\n  };\r\n  d3_labPrototype.rgb = function() {\r\n    return d3_lab_rgb(this.l, this.a, this.b);\r\n  };\r\n  function d3_lab_rgb(l, a, b) {\r\n    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;\r\n    x = d3_lab_xyz(x) * d3_lab_X;\r\n    y = d3_lab_xyz(y) * d3_lab_Y;\r\n    z = d3_lab_xyz(z) * d3_lab_Z;\r\n    return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\r\n  }\r\n  function d3_lab_hcl(l, a, b) {\r\n    return d3_hcl(Math.atan2(b, a) / π * 180, Math.sqrt(a * a + b * b), l);\r\n  }\r\n  function d3_lab_xyz(x) {\r\n    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\r\n  }\r\n  function d3_xyz_lab(x) {\r\n    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\r\n  }\r\n  function d3_xyz_rgb(r) {\r\n    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\r\n  }\r\n  function d3_selection(groups) {\r\n    d3_arraySubclass(groups, d3_selectionPrototype);\r\n    return groups;\r\n  }\r\n  var d3_select = function(s, n) {\r\n    return n.querySelector(s);\r\n  }, d3_selectAll = function(s, n) {\r\n    return n.querySelectorAll(s);\r\n  }, d3_selectRoot = d3_document.documentElement, d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector, d3_selectMatches = function(n, s) {\r\n    return d3_selectMatcher.call(n, s);\r\n  };\r\n  if (typeof Sizzle === \"function\") {\r\n    d3_select = function(s, n) {\r\n      return Sizzle(s, n)[0] || null;\r\n    };\r\n    d3_selectAll = function(s, n) {\r\n      return Sizzle.uniqueSort(Sizzle(s, n));\r\n    };\r\n    d3_selectMatches = Sizzle.matchesSelector;\r\n  }\r\n  var d3_selectionPrototype = [];\r\n  d3.selection = function() {\r\n    return d3_selectionRoot;\r\n  };\r\n  d3.selection.prototype = d3_selectionPrototype;\r\n  d3_selectionPrototype.select = function(selector) {\r\n    var subgroups = [], subgroup, subnode, group, node;\r\n    if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\r\n    for (var j = -1, m = this.length; ++j < m; ) {\r\n      subgroups.push(subgroup = []);\r\n      subgroup.parentNode = (group = this[j]).parentNode;\r\n      for (var i = -1, n = group.length; ++i < n; ) {\r\n        if (node = group[i]) {\r\n          subgroup.push(subnode = selector.call(node, node.__data__, i));\r\n          if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\r\n        } else {\r\n          subgroup.push(null);\r\n        }\r\n      }\r\n    }\r\n    return d3_selection(subgroups);\r\n  };\r\n  function d3_selection_selector(selector) {\r\n    return function() {\r\n      return d3_select(selector, this);\r\n    };\r\n  }\r\n  d3_selectionPrototype.selectAll = function(selector) {\r\n    var subgroups = [], subgroup, node;\r\n    if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\r\n    for (var j = -1, m = this.length; ++j < m; ) {\r\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\r\n        if (node = group[i]) {\r\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));\r\n          subgroup.parentNode = node;\r\n        }\r\n      }\r\n    }\r\n    return d3_selection(subgroups);\r\n  };\r\n  function d3_selection_selectorAll(selector) {\r\n    return function() {\r\n      return d3_selectAll(selector, this);\r\n    };\r\n  }\r\n  d3_selectionPrototype.attr = function(name, value) {\r\n    if (arguments.length < 2) {\r\n      if (typeof name === \"string\") {\r\n        var node = this.node();\r\n        name = d3.ns.qualify(name);\r\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\r\n      }\r\n      for (value in name) this.each(d3_selection_attr(value, name[value]));\r\n      return this;\r\n    }\r\n    return this.each(d3_selection_attr(name, value));\r\n  };\r\n  function d3_selection_attr(name, value) {\r\n    name = d3.ns.qualify(name);\r\n    function attrNull() {\r\n      this.removeAttribute(name);\r\n    }\r\n    function attrNullNS() {\r\n      this.removeAttributeNS(name.space, name.local);\r\n    }\r\n    function attrConstant() {\r\n      this.setAttribute(name, value);\r\n    }\r\n    function attrConstantNS() {\r\n      this.setAttributeNS(name.space, name.local, value);\r\n    }\r\n    function attrFunction() {\r\n      var x = value.apply(this, arguments);\r\n      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);\r\n    }\r\n    function attrFunctionNS() {\r\n      var x = value.apply(this, arguments);\r\n      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);\r\n    }\r\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === \"function\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\r\n  }\r\n  d3_selectionPrototype.classed = function(name, value) {\r\n    if (arguments.length < 2) {\r\n      if (typeof name === \"string\") {\r\n        var node = this.node(), n = (name = name.trim().split(/^|\\s+/g)).length, i = -1;\r\n        if (value = node.classList) {\r\n          while (++i < n) if (!value.contains(name[i])) return false;\r\n        } else {\r\n          value = node.className;\r\n          if (value.baseVal != null) value = value.baseVal;\r\n          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\r\n        }\r\n        return true;\r\n      }\r\n      for (value in name) this.each(d3_selection_classed(value, name[value]));\r\n      return this;\r\n    }\r\n    return this.each(d3_selection_classed(name, value));\r\n  };\r\n  function d3_selection_classedRe(name) {\r\n    return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\r\n  }\r\n  function d3_selection_classed(name, value) {\r\n    name = name.trim().split(/\\s+/).map(d3_selection_classedName);\r\n    var n = name.length;\r\n    function classedConstant() {\r\n      var i = -1;\r\n      while (++i < n) name[i](this, value);\r\n    }\r\n    function classedFunction() {\r\n      var i = -1, x = value.apply(this, arguments);\r\n      while (++i < n) name[i](this, x);\r\n    }\r\n    return typeof value === \"function\" ? classedFunction : classedConstant;\r\n  }\r\n  function d3_selection_classedName(name) {\r\n    var re = d3_selection_classedRe(name);\r\n    return function(node, value) {\r\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\r\n      var c = node.className, cb = c.baseVal != null, cv = cb ? c.baseVal : c;\r\n      if (value) {\r\n        re.lastIndex = 0;\r\n        if (!re.test(cv)) {\r\n          cv = d3_collapse(cv + \" \" + name);\r\n          if (cb) c.baseVal = cv; else node.className = cv;\r\n        }\r\n      } else if (cv) {\r\n        cv = d3_collapse(cv.replace(re, \" \"));\r\n        if (cb) c.baseVal = cv; else node.className = cv;\r\n      }\r\n    };\r\n  }\r\n  d3_selectionPrototype.style = function(name, value, priority) {\r\n    var n = arguments.length;\r\n    if (n < 3) {\r\n      if (typeof name !== \"string\") {\r\n        if (n < 2) value = \"\";\r\n        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\r\n        return this;\r\n      }\r\n      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);\r\n      priority = \"\";\r\n    }\r\n    return this.each(d3_selection_style(name, value, priority));\r\n  };\r\n  function d3_selection_style(name, value, priority) {\r\n    function styleNull() {\r\n      this.style.removeProperty(name);\r\n    }\r\n    function styleConstant() {\r\n      this.style.setProperty(name, value, priority);\r\n    }\r\n    function styleFunction() {\r\n      var x = value.apply(this, arguments);\r\n      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);\r\n    }\r\n    return value == null ? styleNull : typeof value === \"function\" ? styleFunction : styleConstant;\r\n  }\r\n  d3_selectionPrototype.property = function(name, value) {\r\n    if (arguments.length < 2) {\r\n      if (typeof name === \"string\") return this.node()[name];\r\n      for (value in name) this.each(d3_selection_property(value, name[value]));\r\n      return this;\r\n    }\r\n    return this.each(d3_selection_property(name, value));\r\n  };\r\n  function d3_selection_property(name, value) {\r\n    function propertyNull() {\r\n      delete this[name];\r\n    }\r\n    function propertyConstant() {\r\n      this[name] = value;\r\n    }\r\n    function propertyFunction() {\r\n      var x = value.apply(this, arguments);\r\n      if (x == null) delete this[name]; else this[name] = x;\r\n    }\r\n    return value == null ? propertyNull : typeof value === \"function\" ? propertyFunction : propertyConstant;\r\n  }\r\n  d3_selectionPrototype.text = function(value) {\r\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\r\n      var v = value.apply(this, arguments);\r\n      this.textContent = v == null ? \"\" : v;\r\n    } : value == null ? function() {\r\n      this.textContent = \"\";\r\n    } : function() {\r\n      this.textContent = value;\r\n    }) : this.node().textContent;\r\n  };\r\n  d3_selectionPrototype.html = function(value) {\r\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\r\n      var v = value.apply(this, arguments);\r\n      this.innerHTML = v == null ? \"\" : v;\r\n    } : value == null ? function() {\r\n      this.innerHTML = \"\";\r\n    } : function() {\r\n      this.innerHTML = value;\r\n    }) : this.node().innerHTML;\r\n  };\r\n  d3_selectionPrototype.append = function(name) {\r\n    name = d3.ns.qualify(name);\r\n    function append() {\r\n      return this.appendChild(d3_document.createElementNS(this.namespaceURI, name));\r\n    }\r\n    function appendNS() {\r\n      return this.appendChild(d3_document.createElementNS(name.space, name.local));\r\n    }\r\n    return this.select(name.local ? appendNS : append);\r\n  };\r\n  d3_selectionPrototype.insert = function(name, before) {\r\n    name = d3.ns.qualify(name);\r\n    function insert() {\r\n      return this.insertBefore(d3_document.createElementNS(this.namespaceURI, name), d3_select(before, this));\r\n    }\r\n    function insertNS() {\r\n      return this.insertBefore(d3_document.createElementNS(name.space, name.local), d3_select(before, this));\r\n    }\r\n    return this.select(name.local ? insertNS : insert);\r\n  };\r\n  d3_selectionPrototype.remove = function() {\r\n    return this.each(function() {\r\n      var parent = this.parentNode;\r\n      if (parent) parent.removeChild(this);\r\n    });\r\n  };\r\n  d3_selectionPrototype.data = function(value, key) {\r\n    var i = -1, n = this.length, group, node;\r\n    if (!arguments.length) {\r\n      value = new Array(n = (group = this[0]).length);\r\n      while (++i < n) {\r\n        if (node = group[i]) {\r\n          value[i] = node.__data__;\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n    function bind(group, groupData) {\r\n      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;\r\n      if (key) {\r\n        var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;\r\n        for (i = -1; ++i < n; ) {\r\n          keyValue = key.call(node = group[i], node.__data__, i);\r\n          if (nodeByKeyValue.has(keyValue)) {\r\n            exitNodes[i] = node;\r\n          } else {\r\n            nodeByKeyValue.set(keyValue, node);\r\n          }\r\n          keyValues.push(keyValue);\r\n        }\r\n        for (i = -1; ++i < m; ) {\r\n          keyValue = key.call(groupData, nodeData = groupData[i], i);\r\n          if (node = nodeByKeyValue.get(keyValue)) {\r\n            updateNodes[i] = node;\r\n            node.__data__ = nodeData;\r\n          } else if (!dataByKeyValue.has(keyValue)) {\r\n            enterNodes[i] = d3_selection_dataNode(nodeData);\r\n          }\r\n          dataByKeyValue.set(keyValue, nodeData);\r\n          nodeByKeyValue.remove(keyValue);\r\n        }\r\n        for (i = -1; ++i < n; ) {\r\n          if (nodeByKeyValue.has(keyValues[i])) {\r\n            exitNodes[i] = group[i];\r\n          }\r\n        }\r\n      } else {\r\n        for (i = -1; ++i < n0; ) {\r\n          node = group[i];\r\n          nodeData = groupData[i];\r\n          if (node) {\r\n            node.__data__ = nodeData;\r\n            updateNodes[i] = node;\r\n          } else {\r\n            enterNodes[i] = d3_selection_dataNode(nodeData);\r\n          }\r\n        }\r\n        for (;i < m; ++i) {\r\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\r\n        }\r\n        for (;i < n; ++i) {\r\n          exitNodes[i] = group[i];\r\n        }\r\n      }\r\n      enterNodes.update = updateNodes;\r\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\r\n      enter.push(enterNodes);\r\n      update.push(updateNodes);\r\n      exit.push(exitNodes);\r\n    }\r\n    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);\r\n    if (typeof value === \"function\") {\r\n      while (++i < n) {\r\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\r\n      }\r\n    } else {\r\n      while (++i < n) {\r\n        bind(group = this[i], value);\r\n      }\r\n    }\r\n    update.enter = function() {\r\n      return enter;\r\n    };\r\n    update.exit = function() {\r\n      return exit;\r\n    };\r\n    return update;\r\n  };\r\n  function d3_selection_dataNode(data) {\r\n    return {\r\n      __data__: data\r\n    };\r\n  }\r\n  d3_selectionPrototype.datum = function(value) {\r\n    return arguments.length ? this.property(\"__data__\", value) : this.property(\"__data__\");\r\n  };\r\n  d3_selectionPrototype.filter = function(filter) {\r\n    var subgroups = [], subgroup, group, node;\r\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\r\n    for (var j = 0, m = this.length; j < m; j++) {\r\n      subgroups.push(subgroup = []);\r\n      subgroup.parentNode = (group = this[j]).parentNode;\r\n      for (var i = 0, n = group.length; i < n; i++) {\r\n        if ((node = group[i]) && filter.call(node, node.__data__, i)) {\r\n          subgroup.push(node);\r\n        }\r\n      }\r\n    }\r\n    return d3_selection(subgroups);\r\n  };\r\n  function d3_selection_filter(selector) {\r\n    return function() {\r\n      return d3_selectMatches(this, selector);\r\n    };\r\n  }\r\n  d3_selectionPrototype.order = function() {\r\n    for (var j = -1, m = this.length; ++j < m; ) {\r\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\r\n        if (node = group[i]) {\r\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\r\n          next = node;\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n  d3_selectionPrototype.sort = function(comparator) {\r\n    comparator = d3_selection_sortComparator.apply(this, arguments);\r\n    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);\r\n    return this.order();\r\n  };\r\n  function d3_selection_sortComparator(comparator) {\r\n    if (!arguments.length) comparator = d3.ascending;\r\n    return function(a, b) {\r\n      return !a - !b || comparator(a.__data__, b.__data__);\r\n    };\r\n  }\r\n  d3_selectionPrototype.on = function(type, listener, capture) {\r\n    var n = arguments.length;\r\n    if (n < 3) {\r\n      if (typeof type !== \"string\") {\r\n        if (n < 2) listener = false;\r\n        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\r\n        return this;\r\n      }\r\n      if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\r\n      capture = false;\r\n    }\r\n    return this.each(d3_selection_on(type, listener, capture));\r\n  };\r\n  function d3_selection_on(type, listener, capture) {\r\n    var name = \"__on\" + type, i = type.indexOf(\".\");\r\n    if (i > 0) type = type.substring(0, i);\r\n    function onRemove() {\r\n      var wrapper = this[name];\r\n      if (wrapper) {\r\n        this.removeEventListener(type, wrapper, wrapper.$);\r\n        delete this[name];\r\n      }\r\n    }\r\n    function onAdd() {\r\n      var node = this, args = d3_array(arguments);\r\n      onRemove.call(this);\r\n      this.addEventListener(type, this[name] = wrapper, wrapper.$ = capture);\r\n      wrapper._ = listener;\r\n      function wrapper(e) {\r\n        var o = d3.event;\r\n        d3.event = e;\r\n        args[0] = node.__data__;\r\n        try {\r\n          listener.apply(node, args);\r\n        } finally {\r\n          d3.event = o;\r\n        }\r\n      }\r\n    }\r\n    return listener ? onAdd : onRemove;\r\n  }\r\n  d3_selectionPrototype.each = function(callback) {\r\n    return d3_selection_each(this, function(node, i, j) {\r\n      callback.call(node, node.__data__, i, j);\r\n    });\r\n  };\r\n  function d3_selection_each(groups, callback) {\r\n    for (var j = 0, m = groups.length; j < m; j++) {\r\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\r\n        if (node = group[i]) callback(node, i, j);\r\n      }\r\n    }\r\n    return groups;\r\n  }\r\n  d3_selectionPrototype.call = function(callback) {\r\n    var args = d3_array(arguments);\r\n    callback.apply(args[0] = this, args);\r\n    return this;\r\n  };\r\n  d3_selectionPrototype.empty = function() {\r\n    return !this.node();\r\n  };\r\n  d3_selectionPrototype.node = function() {\r\n    for (var j = 0, m = this.length; j < m; j++) {\r\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\r\n        var node = group[i];\r\n        if (node) return node;\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n  d3_selectionPrototype.transition = function() {\r\n    var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = Object.create(d3_transitionInherit);\r\n    transition.time = Date.now();\r\n    for (var j = -1, m = this.length; ++j < m; ) {\r\n      subgroups.push(subgroup = []);\r\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\r\n        if (node = group[i]) d3_transitionNode(node, i, id, transition);\r\n        subgroup.push(node);\r\n      }\r\n    }\r\n    return d3_transition(subgroups, id);\r\n  };\r\n  var d3_selectionRoot = d3_selection([ [ d3_document ] ]);\r\n  d3_selectionRoot[0].parentNode = d3_selectRoot;\r\n  d3.select = function(selector) {\r\n    return typeof selector === \"string\" ? d3_selectionRoot.select(selector) : d3_selection([ [ selector ] ]);\r\n  };\r\n  d3.selectAll = function(selector) {\r\n    return typeof selector === \"string\" ? d3_selectionRoot.selectAll(selector) : d3_selection([ d3_array(selector) ]);\r\n  };\r\n  function d3_selection_enter(selection) {\r\n    d3_arraySubclass(selection, d3_selection_enterPrototype);\r\n    return selection;\r\n  }\r\n  var d3_selection_enterPrototype = [];\r\n  d3.selection.enter = d3_selection_enter;\r\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\r\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\r\n  d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;\r\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\r\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\r\n  d3_selection_enterPrototype.select = function(selector) {\r\n    var subgroups = [], subgroup, subnode, upgroup, group, node;\r\n    for (var j = -1, m = this.length; ++j < m; ) {\r\n      upgroup = (group = this[j]).update;\r\n      subgroups.push(subgroup = []);\r\n      subgroup.parentNode = group.parentNode;\r\n      for (var i = -1, n = group.length; ++i < n; ) {\r\n        if (node = group[i]) {\r\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));\r\n          subnode.__data__ = node.__data__;\r\n        } else {\r\n          subgroup.push(null);\r\n        }\r\n      }\r\n    }\r\n    return d3_selection(subgroups);\r\n  };\r\n  function d3_transition(groups, id) {\r\n    d3_arraySubclass(groups, d3_transitionPrototype);\r\n    groups.id = id;\r\n    return groups;\r\n  }\r\n  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit = {\r\n    ease: d3_ease_cubicInOut,\r\n    delay: 0,\r\n    duration: 250\r\n  };\r\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\r\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\r\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\r\n  d3.transition = function(selection) {\r\n    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();\r\n  };\r\n  d3.transition.prototype = d3_transitionPrototype;\r\n  function d3_transitionNode(node, i, id, inherit) {\r\n    var lock = node.__transition__ || (node.__transition__ = {\r\n      active: 0,\r\n      count: 0\r\n    }), transition = lock[id];\r\n    if (!transition) {\r\n      var time = inherit.time;\r\n      transition = lock[id] = {\r\n        tween: new d3_Map(),\r\n        event: d3.dispatch(\"start\", \"end\"),\r\n        time: time,\r\n        ease: inherit.ease,\r\n        delay: inherit.delay,\r\n        duration: inherit.duration\r\n      };\r\n      ++lock.count;\r\n      d3.timer(function(elapsed) {\r\n        var d = node.__data__, ease = transition.ease, event = transition.event, delay = transition.delay, duration = transition.duration, tweened = [];\r\n        return delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time), 1;\r\n        function start(elapsed) {\r\n          if (lock.active > id) return stop();\r\n          lock.active = id;\r\n          event.start.call(node, d, i);\r\n          transition.tween.forEach(function(key, value) {\r\n            if (value = value.call(node, d, i)) {\r\n              tweened.push(value);\r\n            }\r\n          });\r\n          if (!tick(elapsed)) d3.timer(tick, 0, time);\r\n          return 1;\r\n        }\r\n        function tick(elapsed) {\r\n          if (lock.active !== id) return stop();\r\n          var t = (elapsed - delay) / duration, e = ease(t), n = tweened.length;\r\n          while (n > 0) {\r\n            tweened[--n].call(node, e);\r\n          }\r\n          if (t >= 1) {\r\n            stop();\r\n            event.end.call(node, d, i);\r\n            return 1;\r\n          }\r\n        }\r\n        function stop() {\r\n          if (--lock.count) delete lock[id]; else delete node.__transition__;\r\n          return 1;\r\n        }\r\n      }, 0, time);\r\n      return transition;\r\n    }\r\n  }\r\n  d3_transitionPrototype.select = function(selector) {\r\n    var id = this.id, subgroups = [], subgroup, subnode, node;\r\n    if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\r\n    for (var j = -1, m = this.length; ++j < m; ) {\r\n      subgroups.push(subgroup = []);\r\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\r\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i))) {\r\n          if (\"__data__\" in node) subnode.__data__ = node.__data__;\r\n          d3_transitionNode(subnode, i, id, node.__transition__[id]);\r\n          subgroup.push(subnode);\r\n        } else {\r\n          subgroup.push(null);\r\n        }\r\n      }\r\n    }\r\n    return d3_transition(subgroups, id);\r\n  };\r\n  d3_transitionPrototype.selectAll = function(selector) {\r\n    var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;\r\n    if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\r\n    for (var j = -1, m = this.length; ++j < m; ) {\r\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\r\n        if (node = group[i]) {\r\n          transition = node.__transition__[id];\r\n          subnodes = selector.call(node, node.__data__, i);\r\n          subgroups.push(subgroup = []);\r\n          for (var k = -1, o = subnodes.length; ++k < o; ) {\r\n            d3_transitionNode(subnode = subnodes[k], k, id, transition);\r\n            subgroup.push(subnode);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return d3_transition(subgroups, id);\r\n  };\r\n  d3_transitionPrototype.filter = function(filter) {\r\n    var subgroups = [], subgroup, group, node;\r\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\r\n    for (var j = 0, m = this.length; j < m; j++) {\r\n      subgroups.push(subgroup = []);\r\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\r\n        if ((node = group[i]) && filter.call(node, node.__data__, i)) {\r\n          subgroup.push(node);\r\n        }\r\n      }\r\n    }\r\n    return d3_transition(subgroups, this.id, this.time).ease(this.ease());\r\n  };\r\n  d3_transitionPrototype.attr = function(nameNS, value) {\r\n    if (arguments.length < 2) {\r\n      for (value in nameNS) this.attr(value, nameNS[value]);\r\n      return this;\r\n    }\r\n    var interpolate = d3_interpolateByName(nameNS), name = d3.ns.qualify(nameNS);\r\n    function attrNull() {\r\n      this.removeAttribute(name);\r\n    }\r\n    function attrNullNS() {\r\n      this.removeAttributeNS(name.space, name.local);\r\n    }\r\n    return d3_transition_tween(this, \"attr.\" + nameNS, value, function(b) {\r\n      function attrString() {\r\n        var a = this.getAttribute(name), i;\r\n        return a !== b && (i = interpolate(a, b), function(t) {\r\n          this.setAttribute(name, i(t));\r\n        });\r\n      }\r\n      function attrStringNS() {\r\n        var a = this.getAttributeNS(name.space, name.local), i;\r\n        return a !== b && (i = interpolate(a, b), function(t) {\r\n          this.setAttributeNS(name.space, name.local, i(t));\r\n        });\r\n      }\r\n      return b == null ? name.local ? attrNullNS : attrNull : (b += \"\", name.local ? attrStringNS : attrString);\r\n    });\r\n  };\r\n  d3_transitionPrototype.attrTween = function(nameNS, tween) {\r\n    var name = d3.ns.qualify(nameNS);\r\n    function attrTween(d, i) {\r\n      var f = tween.call(this, d, i, this.getAttribute(name));\r\n      return f && function(t) {\r\n        this.setAttribute(name, f(t));\r\n      };\r\n    }\r\n    function attrTweenNS(d, i) {\r\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\r\n      return f && function(t) {\r\n        this.setAttributeNS(name.space, name.local, f(t));\r\n      };\r\n    }\r\n    return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\r\n  };\r\n  d3_transitionPrototype.style = function(name, value, priority) {\r\n    var n = arguments.length;\r\n    if (n < 3) {\r\n      if (typeof name !== \"string\") {\r\n        if (n < 2) value = \"\";\r\n        for (priority in name) this.style(priority, name[priority], value);\r\n        return this;\r\n      }\r\n      priority = \"\";\r\n    }\r\n    var interpolate = d3_interpolateByName(name);\r\n    function styleNull() {\r\n      this.style.removeProperty(name);\r\n    }\r\n    return d3_transition_tween(this, \"style.\" + name, value, function(b) {\r\n      function styleString() {\r\n        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;\r\n        return a !== b && (i = interpolate(a, b), function(t) {\r\n          this.style.setProperty(name, i(t), priority);\r\n        });\r\n      }\r\n      return b == null ? styleNull : (b += \"\", styleString);\r\n    });\r\n  };\r\n  d3_transitionPrototype.styleTween = function(name, tween, priority) {\r\n    if (arguments.length < 3) priority = \"\";\r\n    return this.tween(\"style.\" + name, function(d, i) {\r\n      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));\r\n      return f && function(t) {\r\n        this.style.setProperty(name, f(t), priority);\r\n      };\r\n    });\r\n  };\r\n  d3_transitionPrototype.text = function(value) {\r\n    return d3_transition_tween(this, \"text\", value, d3_transition_text);\r\n  };\r\n  function d3_transition_text(b) {\r\n    if (b == null) b = \"\";\r\n    return function() {\r\n      this.textContent = b;\r\n    };\r\n  }\r\n  d3_transitionPrototype.remove = function() {\r\n    return this.each(\"end.transition\", function() {\r\n      var p;\r\n      if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);\r\n    });\r\n  };\r\n  d3_transitionPrototype.ease = function(value) {\r\n    var id = this.id;\r\n    if (arguments.length < 1) return this.node().__transition__[id].ease;\r\n    if (typeof value !== \"function\") value = d3.ease.apply(d3, arguments);\r\n    return d3_selection_each(this, function(node) {\r\n      node.__transition__[id].ease = value;\r\n    });\r\n  };\r\n  d3_transitionPrototype.delay = function(value) {\r\n    var id = this.id;\r\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\r\n      node.__transition__[id].delay = value.call(node, node.__data__, i, j) | 0;\r\n    } : (value |= 0, function(node) {\r\n      node.__transition__[id].delay = value;\r\n    }));\r\n  };\r\n  d3_transitionPrototype.duration = function(value) {\r\n    var id = this.id;\r\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\r\n      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j) | 0);\r\n    } : (value = Math.max(1, value | 0), function(node) {\r\n      node.__transition__[id].duration = value;\r\n    }));\r\n  };\r\n  d3_transitionPrototype.each = function(type, listener) {\r\n    var id = this.id;\r\n    if (arguments.length < 2) {\r\n      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;\r\n      d3_transitionInheritId = id;\r\n      d3_selection_each(this, function(node, i, j) {\r\n        d3_transitionInherit = node.__transition__[id];\r\n        type.call(node, node.__data__, i, j);\r\n      });\r\n      d3_transitionInherit = inherit;\r\n      d3_transitionInheritId = inheritId;\r\n    } else {\r\n      d3_selection_each(this, function(node) {\r\n        node.__transition__[id].event.on(type, listener);\r\n      });\r\n    }\r\n    return this;\r\n  };\r\n  d3_transitionPrototype.transition = function() {\r\n    var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;\r\n    for (var j = 0, m = this.length; j < m; j++) {\r\n      subgroups.push(subgroup = []);\r\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\r\n        if (node = group[i]) {\r\n          transition = Object.create(node.__transition__[id0]);\r\n          transition.delay += transition.duration;\r\n          d3_transitionNode(node, i, id1, transition);\r\n        }\r\n        subgroup.push(node);\r\n      }\r\n    }\r\n    return d3_transition(subgroups, id1);\r\n  };\r\n  d3_transitionPrototype.tween = function(name, tween) {\r\n    var id = this.id;\r\n    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);\r\n    return d3_selection_each(this, tween == null ? function(node) {\r\n      node.__transition__[id].tween.remove(name);\r\n    } : function(node) {\r\n      node.__transition__[id].tween.set(name, tween);\r\n    });\r\n  };\r\n  function d3_transition_tween(groups, name, value, tween) {\r\n    var id = groups.id;\r\n    return d3_selection_each(groups, typeof value === \"function\" ? function(node, i, j) {\r\n      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\r\n    } : (value = tween(value), function(node) {\r\n      node.__transition__[id].tween.set(name, value);\r\n    }));\r\n  }\r\n  var d3_timer_id = 0, d3_timer_byId = {}, d3_timer_queue = null, d3_timer_interval, d3_timer_timeout;\r\n  d3.timer = function(callback, delay, then) {\r\n    if (arguments.length < 3) {\r\n      if (arguments.length < 2) delay = 0; else if (!isFinite(delay)) return;\r\n      then = Date.now();\r\n    }\r\n    var timer = d3_timer_byId[callback.id];\r\n    if (timer && timer.callback === callback) {\r\n      timer.then = then;\r\n      timer.delay = delay;\r\n    } else d3_timer_byId[callback.id = ++d3_timer_id] = d3_timer_queue = {\r\n      callback: callback,\r\n      then: then,\r\n      delay: delay,\r\n      next: d3_timer_queue\r\n    };\r\n    if (!d3_timer_interval) {\r\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\r\n      d3_timer_interval = 1;\r\n      d3_timer_frame(d3_timer_step);\r\n    }\r\n  };\r\n  function d3_timer_step() {\r\n    var elapsed, now = Date.now(), t1 = d3_timer_queue;\r\n    while (t1) {\r\n      elapsed = now - t1.then;\r\n      if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);\r\n      t1 = t1.next;\r\n    }\r\n    var delay = d3_timer_flush() - now;\r\n    if (delay > 24) {\r\n      if (isFinite(delay)) {\r\n        clearTimeout(d3_timer_timeout);\r\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\r\n      }\r\n      d3_timer_interval = 0;\r\n    } else {\r\n      d3_timer_interval = 1;\r\n      d3_timer_frame(d3_timer_step);\r\n    }\r\n  }\r\n  d3.timer.flush = function() {\r\n    var elapsed, now = Date.now(), t1 = d3_timer_queue;\r\n    while (t1) {\r\n      elapsed = now - t1.then;\r\n      if (!t1.delay) t1.flush = t1.callback(elapsed);\r\n      t1 = t1.next;\r\n    }\r\n    d3_timer_flush();\r\n  };\r\n  function d3_timer_flush() {\r\n    var t0 = null, t1 = d3_timer_queue, then = Infinity;\r\n    while (t1) {\r\n      if (t1.flush) {\r\n        delete d3_timer_byId[t1.callback.id];\r\n        t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;\r\n      } else {\r\n        then = Math.min(then, t1.then + t1.delay);\r\n        t1 = (t0 = t1).next;\r\n      }\r\n    }\r\n    return then;\r\n  }\r\n  var d3_timer_frame = d3_window.requestAnimationFrame || d3_window.webkitRequestAnimationFrame || d3_window.mozRequestAnimationFrame || d3_window.oRequestAnimationFrame || d3_window.msRequestAnimationFrame || function(callback) {\r\n    setTimeout(callback, 17);\r\n  };\r\n  d3.mouse = function(container) {\r\n    return d3_mousePoint(container, d3_eventSource());\r\n  };\r\n  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;\r\n  function d3_mousePoint(container, e) {\r\n    var svg = container.ownerSVGElement || container;\r\n    if (svg.createSVGPoint) {\r\n      var point = svg.createSVGPoint();\r\n      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {\r\n        svg = d3.select(d3_document.body).append(\"svg\").style(\"position\", \"absolute\").style(\"top\", 0).style(\"left\", 0);\r\n        var ctm = svg[0][0].getScreenCTM();\r\n        d3_mouse_bug44083 = !(ctm.f || ctm.e);\r\n        svg.remove();\r\n      }\r\n      if (d3_mouse_bug44083) {\r\n        point.x = e.pageX;\r\n        point.y = e.pageY;\r\n      } else {\r\n        point.x = e.clientX;\r\n        point.y = e.clientY;\r\n      }\r\n      point = point.matrixTransform(container.getScreenCTM().inverse());\r\n      return [ point.x, point.y ];\r\n    }\r\n    var rect = container.getBoundingClientRect();\r\n    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];\r\n  }\r\n  d3.touches = function(container, touches) {\r\n    if (arguments.length < 2) touches = d3_eventSource().touches;\r\n    return touches ? d3_array(touches).map(function(touch) {\r\n      var point = d3_mousePoint(container, touch);\r\n      point.identifier = touch.identifier;\r\n      return point;\r\n    }) : [];\r\n  };\r\n  function d3_noop() {}\r\n  d3.scale = {};\r\n  function d3_scaleExtent(domain) {\r\n    var start = domain[0], stop = domain[domain.length - 1];\r\n    return start < stop ? [ start, stop ] : [ stop, start ];\r\n  }\r\n  function d3_scaleRange(scale) {\r\n    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\r\n  }\r\n  function d3_scale_nice(domain, nice) {\r\n    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;\r\n    if (x1 < x0) {\r\n      dx = i0, i0 = i1, i1 = dx;\r\n      dx = x0, x0 = x1, x1 = dx;\r\n    }\r\n    if (nice = nice(x1 - x0)) {\r\n      domain[i0] = nice.floor(x0);\r\n      domain[i1] = nice.ceil(x1);\r\n    }\r\n    return domain;\r\n  }\r\n  function d3_scale_niceDefault() {\r\n    return Math;\r\n  }\r\n  d3.scale.linear = function() {\r\n    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3.interpolate, false);\r\n  };\r\n  function d3_scale_linear(domain, range, interpolate, clamp) {\r\n    var output, input;\r\n    function rescale() {\r\n      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\r\n      output = linear(domain, range, uninterpolate, interpolate);\r\n      input = linear(range, domain, uninterpolate, d3.interpolate);\r\n      return scale;\r\n    }\r\n    function scale(x) {\r\n      return output(x);\r\n    }\r\n    scale.invert = function(y) {\r\n      return input(y);\r\n    };\r\n    scale.domain = function(x) {\r\n      if (!arguments.length) return domain;\r\n      domain = x.map(Number);\r\n      return rescale();\r\n    };\r\n    scale.range = function(x) {\r\n      if (!arguments.length) return range;\r\n      range = x;\r\n      return rescale();\r\n    };\r\n    scale.rangeRound = function(x) {\r\n      return scale.range(x).interpolate(d3.interpolateRound);\r\n    };\r\n    scale.clamp = function(x) {\r\n      if (!arguments.length) return clamp;\r\n      clamp = x;\r\n      return rescale();\r\n    };\r\n    scale.interpolate = function(x) {\r\n      if (!arguments.length) return interpolate;\r\n      interpolate = x;\r\n      return rescale();\r\n    };\r\n    scale.ticks = function(m) {\r\n      return d3_scale_linearTicks(domain, m);\r\n    };\r\n    scale.tickFormat = function(m) {\r\n      return d3_scale_linearTickFormat(domain, m);\r\n    };\r\n    scale.nice = function() {\r\n      d3_scale_nice(domain, d3_scale_linearNice);\r\n      return rescale();\r\n    };\r\n    scale.copy = function() {\r\n      return d3_scale_linear(domain, range, interpolate, clamp);\r\n    };\r\n    return rescale();\r\n  }\r\n  function d3_scale_linearRebind(scale, linear) {\r\n    return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\r\n  }\r\n  function d3_scale_linearNice(dx) {\r\n    dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);\r\n    return dx && {\r\n      floor: function(x) {\r\n        return Math.floor(x / dx) * dx;\r\n      },\r\n      ceil: function(x) {\r\n        return Math.ceil(x / dx) * dx;\r\n      }\r\n    };\r\n  }\r\n  function d3_scale_linearTickRange(domain, m) {\r\n    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;\r\n    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;\r\n    extent[0] = Math.ceil(extent[0] / step) * step;\r\n    extent[1] = Math.floor(extent[1] / step) * step + step * .5;\r\n    extent[2] = step;\r\n    return extent;\r\n  }\r\n  function d3_scale_linearTicks(domain, m) {\r\n    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\r\n  }\r\n  function d3_scale_linearTickFormat(domain, m) {\r\n    return d3.format(\",.\" + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + \"f\");\r\n  }\r\n  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\r\n    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);\r\n    return function(x) {\r\n      return i(u(x));\r\n    };\r\n  }\r\n  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\r\n    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;\r\n    if (domain[k] < domain[0]) {\r\n      domain = domain.slice().reverse();\r\n      range = range.slice().reverse();\r\n    }\r\n    while (++j <= k) {\r\n      u.push(uninterpolate(domain[j - 1], domain[j]));\r\n      i.push(interpolate(range[j - 1], range[j]));\r\n    }\r\n    return function(x) {\r\n      var j = d3.bisect(domain, x, 1, k) - 1;\r\n      return i[j](u[j](x));\r\n    };\r\n  }\r\n  d3.scale.log = function() {\r\n    return d3_scale_log(d3.scale.linear(), d3_scale_logp);\r\n  };\r\n  function d3_scale_log(linear, log) {\r\n    var pow = log.pow;\r\n    function scale(x) {\r\n      return linear(log(x));\r\n    }\r\n    scale.invert = function(x) {\r\n      return pow(linear.invert(x));\r\n    };\r\n    scale.domain = function(x) {\r\n      if (!arguments.length) return linear.domain().map(pow);\r\n      log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;\r\n      pow = log.pow;\r\n      linear.domain(x.map(log));\r\n      return scale;\r\n    };\r\n    scale.nice = function() {\r\n      linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));\r\n      return scale;\r\n    };\r\n    scale.ticks = function() {\r\n      var extent = d3_scaleExtent(linear.domain()), ticks = [];\r\n      if (extent.every(isFinite)) {\r\n        var i = Math.floor(extent[0]), j = Math.ceil(extent[1]), u = pow(extent[0]), v = pow(extent[1]);\r\n        if (log === d3_scale_logn) {\r\n          ticks.push(pow(i));\r\n          for (;i++ < j; ) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);\r\n        } else {\r\n          for (;i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);\r\n          ticks.push(pow(i));\r\n        }\r\n        for (i = 0; ticks[i] < u; i++) {}\r\n        for (j = ticks.length; ticks[j - 1] > v; j--) {}\r\n        ticks = ticks.slice(i, j);\r\n      }\r\n      return ticks;\r\n    };\r\n    scale.tickFormat = function(n, format) {\r\n      if (arguments.length < 2) format = d3_scale_logFormat;\r\n      if (!arguments.length) return format;\r\n      var k = Math.max(.1, n / scale.ticks().length), f = log === d3_scale_logn ? (e = -1e-12, \r\n      Math.floor) : (e = 1e-12, Math.ceil), e;\r\n      return function(d) {\r\n        return d / pow(f(log(d) + e)) <= k ? format(d) : \"\";\r\n      };\r\n    };\r\n    scale.copy = function() {\r\n      return d3_scale_log(linear.copy(), log);\r\n    };\r\n    return d3_scale_linearRebind(scale, linear);\r\n  }\r\n  var d3_scale_logFormat = d3.format(\".0e\");\r\n  function d3_scale_logp(x) {\r\n    return Math.log(x < 0 ? 0 : x) / Math.LN10;\r\n  }\r\n  function d3_scale_logn(x) {\r\n    return -Math.log(x > 0 ? 0 : -x) / Math.LN10;\r\n  }\r\n  d3_scale_logp.pow = function(x) {\r\n    return Math.pow(10, x);\r\n  };\r\n  d3_scale_logn.pow = function(x) {\r\n    return -Math.pow(10, -x);\r\n  };\r\n  d3.scale.pow = function() {\r\n    return d3_scale_pow(d3.scale.linear(), 1);\r\n  };\r\n  function d3_scale_pow(linear, exponent) {\r\n    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);\r\n    function scale(x) {\r\n      return linear(powp(x));\r\n    }\r\n    scale.invert = function(x) {\r\n      return powb(linear.invert(x));\r\n    };\r\n    scale.domain = function(x) {\r\n      if (!arguments.length) return linear.domain().map(powb);\r\n      linear.domain(x.map(powp));\r\n      return scale;\r\n    };\r\n    scale.ticks = function(m) {\r\n      return d3_scale_linearTicks(scale.domain(), m);\r\n    };\r\n    scale.tickFormat = function(m) {\r\n      return d3_scale_linearTickFormat(scale.domain(), m);\r\n    };\r\n    scale.nice = function() {\r\n      return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));\r\n    };\r\n    scale.exponent = function(x) {\r\n      if (!arguments.length) return exponent;\r\n      var domain = scale.domain();\r\n      powp = d3_scale_powPow(exponent = x);\r\n      powb = d3_scale_powPow(1 / exponent);\r\n      return scale.domain(domain);\r\n    };\r\n    scale.copy = function() {\r\n      return d3_scale_pow(linear.copy(), exponent);\r\n    };\r\n    return d3_scale_linearRebind(scale, linear);\r\n  }\r\n  function d3_scale_powPow(e) {\r\n    return function(x) {\r\n      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\r\n    };\r\n  }\r\n  d3.scale.sqrt = function() {\r\n    return d3.scale.pow().exponent(.5);\r\n  };\r\n  d3.scale.ordinal = function() {\r\n    return d3_scale_ordinal([], {\r\n      t: \"range\",\r\n      a: [ [] ]\r\n    });\r\n  };\r\n  function d3_scale_ordinal(domain, ranger) {\r\n    var index, range, rangeBand;\r\n    function scale(x) {\r\n      return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];\r\n    }\r\n    function steps(start, step) {\r\n      return d3.range(domain.length).map(function(i) {\r\n        return start + step * i;\r\n      });\r\n    }\r\n    scale.domain = function(x) {\r\n      if (!arguments.length) return domain;\r\n      domain = [];\r\n      index = new d3_Map();\r\n      var i = -1, n = x.length, xi;\r\n      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\r\n      return scale[ranger.t].apply(scale, ranger.a);\r\n    };\r\n    scale.range = function(x) {\r\n      if (!arguments.length) return range;\r\n      range = x;\r\n      rangeBand = 0;\r\n      ranger = {\r\n        t: \"range\",\r\n        a: arguments\r\n      };\r\n      return scale;\r\n    };\r\n    scale.rangePoints = function(x, padding) {\r\n      if (arguments.length < 2) padding = 0;\r\n      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);\r\n      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);\r\n      rangeBand = 0;\r\n      ranger = {\r\n        t: \"rangePoints\",\r\n        a: arguments\r\n      };\r\n      return scale;\r\n    };\r\n    scale.rangeBands = function(x, padding, outerPadding) {\r\n      if (arguments.length < 2) padding = 0;\r\n      if (arguments.length < 3) outerPadding = padding;\r\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);\r\n      range = steps(start + step * outerPadding, step);\r\n      if (reverse) range.reverse();\r\n      rangeBand = step * (1 - padding);\r\n      ranger = {\r\n        t: \"rangeBands\",\r\n        a: arguments\r\n      };\r\n      return scale;\r\n    };\r\n    scale.rangeRoundBands = function(x, padding, outerPadding) {\r\n      if (arguments.length < 2) padding = 0;\r\n      if (arguments.length < 3) outerPadding = padding;\r\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;\r\n      range = steps(start + Math.round(error / 2), step);\r\n      if (reverse) range.reverse();\r\n      rangeBand = Math.round(step * (1 - padding));\r\n      ranger = {\r\n        t: \"rangeRoundBands\",\r\n        a: arguments\r\n      };\r\n      return scale;\r\n    };\r\n    scale.rangeBand = function() {\r\n      return rangeBand;\r\n    };\r\n    scale.rangeExtent = function() {\r\n      return d3_scaleExtent(ranger.a[0]);\r\n    };\r\n    scale.copy = function() {\r\n      return d3_scale_ordinal(domain, ranger);\r\n    };\r\n    return scale.domain(domain);\r\n  }\r\n  d3.scale.category10 = function() {\r\n    return d3.scale.ordinal().range(d3_category10);\r\n  };\r\n  d3.scale.category20 = function() {\r\n    return d3.scale.ordinal().range(d3_category20);\r\n  };\r\n  d3.scale.category20b = function() {\r\n    return d3.scale.ordinal().range(d3_category20b);\r\n  };\r\n  d3.scale.category20c = function() {\r\n    return d3.scale.ordinal().range(d3_category20c);\r\n  };\r\n  var d3_category10 = [ \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\" ];\r\n  var d3_category20 = [ \"#1f77b4\", \"#aec7e8\", \"#ff7f0e\", \"#ffbb78\", \"#2ca02c\", \"#98df8a\", \"#d62728\", \"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\", \"#f7b6d2\", \"#7f7f7f\", \"#c7c7c7\", \"#bcbd22\", \"#dbdb8d\", \"#17becf\", \"#9edae5\" ];\r\n  var d3_category20b = [ \"#393b79\", \"#5254a3\", \"#6b6ecf\", \"#9c9ede\", \"#637939\", \"#8ca252\", \"#b5cf6b\", \"#cedb9c\", \"#8c6d31\", \"#bd9e39\", \"#e7ba52\", \"#e7cb94\", \"#843c39\", \"#ad494a\", \"#d6616b\", \"#e7969c\", \"#7b4173\", \"#a55194\", \"#ce6dbd\", \"#de9ed6\" ];\r\n  var d3_category20c = [ \"#3182bd\", \"#6baed6\", \"#9ecae1\", \"#c6dbef\", \"#e6550d\", \"#fd8d3c\", \"#fdae6b\", \"#fdd0a2\", \"#31a354\", \"#74c476\", \"#a1d99b\", \"#c7e9c0\", \"#756bb1\", \"#9e9ac8\", \"#bcbddc\", \"#dadaeb\", \"#636363\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\" ];\r\n  d3.scale.quantile = function() {\r\n    return d3_scale_quantile([], []);\r\n  };\r\n  function d3_scale_quantile(domain, range) {\r\n    var thresholds;\r\n    function rescale() {\r\n      var k = 0, q = range.length;\r\n      thresholds = [];\r\n      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\r\n      return scale;\r\n    }\r\n    function scale(x) {\r\n      if (isNaN(x = +x)) return NaN;\r\n      return range[d3.bisect(thresholds, x)];\r\n    }\r\n    scale.domain = function(x) {\r\n      if (!arguments.length) return domain;\r\n      domain = x.filter(function(d) {\r\n        return !isNaN(d);\r\n      }).sort(d3.ascending);\r\n      return rescale();\r\n    };\r\n    scale.range = function(x) {\r\n      if (!arguments.length) return range;\r\n      range = x;\r\n      return rescale();\r\n    };\r\n    scale.quantiles = function() {\r\n      return thresholds;\r\n    };\r\n    scale.copy = function() {\r\n      return d3_scale_quantile(domain, range);\r\n    };\r\n    return rescale();\r\n  }\r\n  d3.scale.quantize = function() {\r\n    return d3_scale_quantize(0, 1, [ 0, 1 ]);\r\n  };\r\n  function d3_scale_quantize(x0, x1, range) {\r\n    var kx, i;\r\n    function scale(x) {\r\n      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\r\n    }\r\n    function rescale() {\r\n      kx = range.length / (x1 - x0);\r\n      i = range.length - 1;\r\n      return scale;\r\n    }\r\n    scale.domain = function(x) {\r\n      if (!arguments.length) return [ x0, x1 ];\r\n      x0 = +x[0];\r\n      x1 = +x[x.length - 1];\r\n      return rescale();\r\n    };\r\n    scale.range = function(x) {\r\n      if (!arguments.length) return range;\r\n      range = x;\r\n      return rescale();\r\n    };\r\n    scale.copy = function() {\r\n      return d3_scale_quantize(x0, x1, range);\r\n    };\r\n    return rescale();\r\n  }\r\n  d3.scale.threshold = function() {\r\n    return d3_scale_threshold([ .5 ], [ 0, 1 ]);\r\n  };\r\n  function d3_scale_threshold(domain, range) {\r\n    function scale(x) {\r\n      return range[d3.bisect(domain, x)];\r\n    }\r\n    scale.domain = function(_) {\r\n      if (!arguments.length) return domain;\r\n      domain = _;\r\n      return scale;\r\n    };\r\n    scale.range = function(_) {\r\n      if (!arguments.length) return range;\r\n      range = _;\r\n      return scale;\r\n    };\r\n    scale.copy = function() {\r\n      return d3_scale_threshold(domain, range);\r\n    };\r\n    return scale;\r\n  }\r\n  d3.scale.identity = function() {\r\n    return d3_scale_identity([ 0, 1 ]);\r\n  };\r\n  function d3_scale_identity(domain) {\r\n    function identity(x) {\r\n      return +x;\r\n    }\r\n    identity.invert = identity;\r\n    identity.domain = identity.range = function(x) {\r\n      if (!arguments.length) return domain;\r\n      domain = x.map(identity);\r\n      return identity;\r\n    };\r\n    identity.ticks = function(m) {\r\n      return d3_scale_linearTicks(domain, m);\r\n    };\r\n    identity.tickFormat = function(m) {\r\n      return d3_scale_linearTickFormat(domain, m);\r\n    };\r\n    identity.copy = function() {\r\n      return d3_scale_identity(domain);\r\n    };\r\n    return identity;\r\n  }\r\n  d3.svg = {};\r\n  d3.svg.arc = function() {\r\n    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\r\n    function arc() {\r\n      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, \r\n      a0 = a1, a1 = da), a1 - a0), df = da < π ? \"0\" : \"1\", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);\r\n      return da >= d3_svg_arcMax ? r0 ? \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1 + \"M0,\" + r0 + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + -r0 + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + r0 + \"Z\" : \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1 + \"Z\" : r0 ? \"M\" + r1 * c0 + \",\" + r1 * s0 + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1 + \"L\" + r0 * c1 + \",\" + r0 * s1 + \"A\" + r0 + \",\" + r0 + \" 0 \" + df + \",0 \" + r0 * c0 + \",\" + r0 * s0 + \"Z\" : \"M\" + r1 * c0 + \",\" + r1 * s0 + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1 + \"L0,0\" + \"Z\";\r\n    }\r\n    arc.innerRadius = function(v) {\r\n      if (!arguments.length) return innerRadius;\r\n      innerRadius = d3_functor(v);\r\n      return arc;\r\n    };\r\n    arc.outerRadius = function(v) {\r\n      if (!arguments.length) return outerRadius;\r\n      outerRadius = d3_functor(v);\r\n      return arc;\r\n    };\r\n    arc.startAngle = function(v) {\r\n      if (!arguments.length) return startAngle;\r\n      startAngle = d3_functor(v);\r\n      return arc;\r\n    };\r\n    arc.endAngle = function(v) {\r\n      if (!arguments.length) return endAngle;\r\n      endAngle = d3_functor(v);\r\n      return arc;\r\n    };\r\n    arc.centroid = function() {\r\n      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;\r\n      return [ Math.cos(a) * r, Math.sin(a) * r ];\r\n    };\r\n    return arc;\r\n  };\r\n  var d3_svg_arcOffset = -π / 2, d3_svg_arcMax = 2 * π - 1e-6;\r\n  function d3_svg_arcInnerRadius(d) {\r\n    return d.innerRadius;\r\n  }\r\n  function d3_svg_arcOuterRadius(d) {\r\n    return d.outerRadius;\r\n  }\r\n  function d3_svg_arcStartAngle(d) {\r\n    return d.startAngle;\r\n  }\r\n  function d3_svg_arcEndAngle(d) {\r\n    return d.endAngle;\r\n  }\r\n  function d3_svg_line(projection) {\r\n    var x = d3_svg_lineX, y = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;\r\n    function line(data) {\r\n      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);\r\n      function segment() {\r\n        segments.push(\"M\", interpolate(projection(points), tension));\r\n      }\r\n      while (++i < n) {\r\n        if (defined.call(this, d = data[i], i)) {\r\n          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);\r\n        } else if (points.length) {\r\n          segment();\r\n          points = [];\r\n        }\r\n      }\r\n      if (points.length) segment();\r\n      return segments.length ? segments.join(\"\") : null;\r\n    }\r\n    line.x = function(_) {\r\n      if (!arguments.length) return x;\r\n      x = _;\r\n      return line;\r\n    };\r\n    line.y = function(_) {\r\n      if (!arguments.length) return y;\r\n      y = _;\r\n      return line;\r\n    };\r\n    line.defined = function(_) {\r\n      if (!arguments.length) return defined;\r\n      defined = _;\r\n      return line;\r\n    };\r\n    line.interpolate = function(_) {\r\n      if (!arguments.length) return interpolateKey;\r\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\r\n      return line;\r\n    };\r\n    line.tension = function(_) {\r\n      if (!arguments.length) return tension;\r\n      tension = _;\r\n      return line;\r\n    };\r\n    return line;\r\n  }\r\n  d3.svg.line = function() {\r\n    return d3_svg_line(d3_identity);\r\n  };\r\n  function d3_svg_lineX(d) {\r\n    return d[0];\r\n  }\r\n  function d3_svg_lineY(d) {\r\n    return d[1];\r\n  }\r\n  var d3_svg_lineInterpolators = d3.map({\r\n    linear: d3_svg_lineLinear,\r\n    \"linear-closed\": d3_svg_lineLinearClosed,\r\n    \"step-before\": d3_svg_lineStepBefore,\r\n    \"step-after\": d3_svg_lineStepAfter,\r\n    basis: d3_svg_lineBasis,\r\n    \"basis-open\": d3_svg_lineBasisOpen,\r\n    \"basis-closed\": d3_svg_lineBasisClosed,\r\n    bundle: d3_svg_lineBundle,\r\n    cardinal: d3_svg_lineCardinal,\r\n    \"cardinal-open\": d3_svg_lineCardinalOpen,\r\n    \"cardinal-closed\": d3_svg_lineCardinalClosed,\r\n    monotone: d3_svg_lineMonotone\r\n  });\r\n  d3_svg_lineInterpolators.forEach(function(key, value) {\r\n    value.key = key;\r\n    value.closed = /-closed$/.test(key);\r\n  });\r\n  function d3_svg_lineLinear(points) {\r\n    return points.join(\"L\");\r\n  }\r\n  function d3_svg_lineLinearClosed(points) {\r\n    return d3_svg_lineLinear(points) + \"Z\";\r\n  }\r\n  function d3_svg_lineStepBefore(points) {\r\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\r\n    while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\r\n    return path.join(\"\");\r\n  }\r\n  function d3_svg_lineStepAfter(points) {\r\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\r\n    while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\r\n    return path.join(\"\");\r\n  }\r\n  function d3_svg_lineCardinalOpen(points, tension) {\r\n    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));\r\n  }\r\n  function d3_svg_lineCardinalClosed(points, tension) {\r\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), \r\n    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));\r\n  }\r\n  function d3_svg_lineCardinal(points, tension) {\r\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\r\n  }\r\n  function d3_svg_lineHermite(points, tangents) {\r\n    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\r\n      return d3_svg_lineLinear(points);\r\n    }\r\n    var quad = points.length != tangents.length, path = \"\", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;\r\n    if (quad) {\r\n      path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3) + \",\" + p[0] + \",\" + p[1];\r\n      p0 = points[1];\r\n      pi = 2;\r\n    }\r\n    if (tangents.length > 1) {\r\n      t = tangents[1];\r\n      p = points[pi];\r\n      pi++;\r\n      path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1]) + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\r\n      for (var i = 2; i < tangents.length; i++, pi++) {\r\n        p = points[pi];\r\n        t = tangents[i];\r\n        path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\r\n      }\r\n    }\r\n    if (quad) {\r\n      var lp = points[pi];\r\n      path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3) + \",\" + lp[0] + \",\" + lp[1];\r\n    }\r\n    return path;\r\n  }\r\n  function d3_svg_lineCardinalTangents(points, tension) {\r\n    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;\r\n    while (++i < n) {\r\n      p0 = p1;\r\n      p1 = p2;\r\n      p2 = points[i];\r\n      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);\r\n    }\r\n    return tangents;\r\n  }\r\n  function d3_svg_lineBasis(points) {\r\n    if (points.length < 3) return d3_svg_lineLinear(points);\r\n    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, \",\", y0 ];\r\n    d3_svg_lineBasisBezier(path, px, py);\r\n    while (++i < n) {\r\n      pi = points[i];\r\n      px.shift();\r\n      px.push(pi[0]);\r\n      py.shift();\r\n      py.push(pi[1]);\r\n      d3_svg_lineBasisBezier(path, px, py);\r\n    }\r\n    i = -1;\r\n    while (++i < 2) {\r\n      px.shift();\r\n      px.push(pi[0]);\r\n      py.shift();\r\n      py.push(pi[1]);\r\n      d3_svg_lineBasisBezier(path, px, py);\r\n    }\r\n    return path.join(\"\");\r\n  }\r\n  function d3_svg_lineBasisOpen(points) {\r\n    if (points.length < 4) return d3_svg_lineLinear(points);\r\n    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];\r\n    while (++i < 3) {\r\n      pi = points[i];\r\n      px.push(pi[0]);\r\n      py.push(pi[1]);\r\n    }\r\n    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\r\n    --i;\r\n    while (++i < n) {\r\n      pi = points[i];\r\n      px.shift();\r\n      px.push(pi[0]);\r\n      py.shift();\r\n      py.push(pi[1]);\r\n      d3_svg_lineBasisBezier(path, px, py);\r\n    }\r\n    return path.join(\"\");\r\n  }\r\n  function d3_svg_lineBasisClosed(points) {\r\n    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];\r\n    while (++i < 4) {\r\n      pi = points[i % n];\r\n      px.push(pi[0]);\r\n      py.push(pi[1]);\r\n    }\r\n    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\r\n    --i;\r\n    while (++i < m) {\r\n      pi = points[i % n];\r\n      px.shift();\r\n      px.push(pi[0]);\r\n      py.shift();\r\n      py.push(pi[1]);\r\n      d3_svg_lineBasisBezier(path, px, py);\r\n    }\r\n    return path.join(\"\");\r\n  }\r\n  function d3_svg_lineBundle(points, tension) {\r\n    var n = points.length - 1;\r\n    if (n) {\r\n      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;\r\n      while (++i <= n) {\r\n        p = points[i];\r\n        t = i / n;\r\n        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\r\n        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\r\n      }\r\n    }\r\n    return d3_svg_lineBasis(points);\r\n  }\r\n  function d3_svg_lineDot4(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\r\n  }\r\n  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];\r\n  function d3_svg_lineBasisBezier(path, x, y) {\r\n    path.push(\"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\r\n  }\r\n  function d3_svg_lineSlope(p0, p1) {\r\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\r\n  }\r\n  function d3_svg_lineFiniteDifferences(points) {\r\n    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);\r\n    while (++i < j) {\r\n      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\r\n    }\r\n    m[i] = d;\r\n    return m;\r\n  }\r\n  function d3_svg_lineMonotoneTangents(points) {\r\n    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;\r\n    while (++i < j) {\r\n      d = d3_svg_lineSlope(points[i], points[i + 1]);\r\n      if (Math.abs(d) < 1e-6) {\r\n        m[i] = m[i + 1] = 0;\r\n      } else {\r\n        a = m[i] / d;\r\n        b = m[i + 1] / d;\r\n        s = a * a + b * b;\r\n        if (s > 9) {\r\n          s = d * 3 / Math.sqrt(s);\r\n          m[i] = s * a;\r\n          m[i + 1] = s * b;\r\n        }\r\n      }\r\n    }\r\n    i = -1;\r\n    while (++i <= j) {\r\n      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\r\n      tangents.push([ s || 0, m[i] * s || 0 ]);\r\n    }\r\n    return tangents;\r\n  }\r\n  function d3_svg_lineMonotone(points) {\r\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\r\n  }\r\n  d3.svg.line.radial = function() {\r\n    var line = d3_svg_line(d3_svg_lineRadial);\r\n    line.radius = line.x, delete line.x;\r\n    line.angle = line.y, delete line.y;\r\n    return line;\r\n  };\r\n  function d3_svg_lineRadial(points) {\r\n    var point, i = -1, n = points.length, r, a;\r\n    while (++i < n) {\r\n      point = points[i];\r\n      r = point[0];\r\n      a = point[1] + d3_svg_arcOffset;\r\n      point[0] = r * Math.cos(a);\r\n      point[1] = r * Math.sin(a);\r\n    }\r\n    return points;\r\n  }\r\n  function d3_svg_area(projection) {\r\n    var x0 = d3_svg_lineX, x1 = d3_svg_lineX, y0 = 0, y1 = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = \"L\", tension = .7;\r\n    function area(data) {\r\n      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {\r\n        return x;\r\n      } : d3_functor(x1), fy1 = y0 === y1 ? function() {\r\n        return y;\r\n      } : d3_functor(y1), x, y;\r\n      function segment() {\r\n        segments.push(\"M\", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), \"Z\");\r\n      }\r\n      while (++i < n) {\r\n        if (defined.call(this, d = data[i], i)) {\r\n          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);\r\n          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);\r\n        } else if (points0.length) {\r\n          segment();\r\n          points0 = [];\r\n          points1 = [];\r\n        }\r\n      }\r\n      if (points0.length) segment();\r\n      return segments.length ? segments.join(\"\") : null;\r\n    }\r\n    area.x = function(_) {\r\n      if (!arguments.length) return x1;\r\n      x0 = x1 = _;\r\n      return area;\r\n    };\r\n    area.x0 = function(_) {\r\n      if (!arguments.length) return x0;\r\n      x0 = _;\r\n      return area;\r\n    };\r\n    area.x1 = function(_) {\r\n      if (!arguments.length) return x1;\r\n      x1 = _;\r\n      return area;\r\n    };\r\n    area.y = function(_) {\r\n      if (!arguments.length) return y1;\r\n      y0 = y1 = _;\r\n      return area;\r\n    };\r\n    area.y0 = function(_) {\r\n      if (!arguments.length) return y0;\r\n      y0 = _;\r\n      return area;\r\n    };\r\n    area.y1 = function(_) {\r\n      if (!arguments.length) return y1;\r\n      y1 = _;\r\n      return area;\r\n    };\r\n    area.defined = function(_) {\r\n      if (!arguments.length) return defined;\r\n      defined = _;\r\n      return area;\r\n    };\r\n    area.interpolate = function(_) {\r\n      if (!arguments.length) return interpolateKey;\r\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\r\n      interpolateReverse = interpolate.reverse || interpolate;\r\n      L = interpolate.closed ? \"M\" : \"L\";\r\n      return area;\r\n    };\r\n    area.tension = function(_) {\r\n      if (!arguments.length) return tension;\r\n      tension = _;\r\n      return area;\r\n    };\r\n    return area;\r\n  }\r\n  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\r\n  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\r\n  d3.svg.area = function() {\r\n    return d3_svg_area(d3_identity);\r\n  };\r\n  d3.svg.area.radial = function() {\r\n    var area = d3_svg_area(d3_svg_lineRadial);\r\n    area.radius = area.x, delete area.x;\r\n    area.innerRadius = area.x0, delete area.x0;\r\n    area.outerRadius = area.x1, delete area.x1;\r\n    area.angle = area.y, delete area.y;\r\n    area.startAngle = area.y0, delete area.y0;\r\n    area.endAngle = area.y1, delete area.y1;\r\n    return area;\r\n  };\r\n  d3.svg.chord = function() {\r\n    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\r\n    function chord(d, i) {\r\n      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);\r\n      return \"M\" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + \"Z\";\r\n    }\r\n    function subgroup(self, f, d, i) {\r\n      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;\r\n      return {\r\n        r: r,\r\n        a0: a0,\r\n        a1: a1,\r\n        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],\r\n        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]\r\n      };\r\n    }\r\n    function equals(a, b) {\r\n      return a.a0 == b.a0 && a.a1 == b.a1;\r\n    }\r\n    function arc(r, p, a) {\r\n      return \"A\" + r + \",\" + r + \" 0 \" + +(a > π) + \",1 \" + p;\r\n    }\r\n    function curve(r0, p0, r1, p1) {\r\n      return \"Q 0,0 \" + p1;\r\n    }\r\n    chord.radius = function(v) {\r\n      if (!arguments.length) return radius;\r\n      radius = d3_functor(v);\r\n      return chord;\r\n    };\r\n    chord.source = function(v) {\r\n      if (!arguments.length) return source;\r\n      source = d3_functor(v);\r\n      return chord;\r\n    };\r\n    chord.target = function(v) {\r\n      if (!arguments.length) return target;\r\n      target = d3_functor(v);\r\n      return chord;\r\n    };\r\n    chord.startAngle = function(v) {\r\n      if (!arguments.length) return startAngle;\r\n      startAngle = d3_functor(v);\r\n      return chord;\r\n    };\r\n    chord.endAngle = function(v) {\r\n      if (!arguments.length) return endAngle;\r\n      endAngle = d3_functor(v);\r\n      return chord;\r\n    };\r\n    return chord;\r\n  };\r\n  function d3_svg_chordRadius(d) {\r\n    return d.radius;\r\n  }\r\n  d3.svg.diagonal = function() {\r\n    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;\r\n    function diagonal(d, i) {\r\n      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {\r\n        x: p0.x,\r\n        y: m\r\n      }, {\r\n        x: p3.x,\r\n        y: m\r\n      }, p3 ];\r\n      p = p.map(projection);\r\n      return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\r\n    }\r\n    diagonal.source = function(x) {\r\n      if (!arguments.length) return source;\r\n      source = d3_functor(x);\r\n      return diagonal;\r\n    };\r\n    diagonal.target = function(x) {\r\n      if (!arguments.length) return target;\r\n      target = d3_functor(x);\r\n      return diagonal;\r\n    };\r\n    diagonal.projection = function(x) {\r\n      if (!arguments.length) return projection;\r\n      projection = x;\r\n      return diagonal;\r\n    };\r\n    return diagonal;\r\n  };\r\n  function d3_svg_diagonalProjection(d) {\r\n    return [ d.x, d.y ];\r\n  }\r\n  d3.svg.diagonal.radial = function() {\r\n    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;\r\n    diagonal.projection = function(x) {\r\n      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\r\n    };\r\n    return diagonal;\r\n  };\r\n  function d3_svg_diagonalRadialProjection(projection) {\r\n    return function() {\r\n      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;\r\n      return [ r * Math.cos(a), r * Math.sin(a) ];\r\n    };\r\n  }\r\n  d3.svg.symbol = function() {\r\n    var type = d3_svg_symbolType, size = d3_svg_symbolSize;\r\n    function symbol(d, i) {\r\n      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\r\n    }\r\n    symbol.type = function(x) {\r\n      if (!arguments.length) return type;\r\n      type = d3_functor(x);\r\n      return symbol;\r\n    };\r\n    symbol.size = function(x) {\r\n      if (!arguments.length) return size;\r\n      size = d3_functor(x);\r\n      return symbol;\r\n    };\r\n    return symbol;\r\n  };\r\n  function d3_svg_symbolSize() {\r\n    return 64;\r\n  }\r\n  function d3_svg_symbolType() {\r\n    return \"circle\";\r\n  }\r\n  function d3_svg_symbolCircle(size) {\r\n    var r = Math.sqrt(size / π);\r\n    return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + -r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\r\n  }\r\n  var d3_svg_symbols = d3.map({\r\n    circle: d3_svg_symbolCircle,\r\n    cross: function(size) {\r\n      var r = Math.sqrt(size / 5) / 2;\r\n      return \"M\" + -3 * r + \",\" + -r + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\r\n    },\r\n    diamond: function(size) {\r\n      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;\r\n      return \"M0,\" + -ry + \"L\" + rx + \",0\" + \" 0,\" + ry + \" \" + -rx + \",0\" + \"Z\";\r\n    },\r\n    square: function(size) {\r\n      var r = Math.sqrt(size) / 2;\r\n      return \"M\" + -r + \",\" + -r + \"L\" + r + \",\" + -r + \" \" + r + \",\" + r + \" \" + -r + \",\" + r + \"Z\";\r\n    },\r\n    \"triangle-down\": function(size) {\r\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\r\n      return \"M0,\" + ry + \"L\" + rx + \",\" + -ry + \" \" + -rx + \",\" + -ry + \"Z\";\r\n    },\r\n    \"triangle-up\": function(size) {\r\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\r\n      return \"M0,\" + -ry + \"L\" + rx + \",\" + ry + \" \" + -rx + \",\" + ry + \"Z\";\r\n    }\r\n  });\r\n  d3.svg.symbolTypes = d3_svg_symbols.keys();\r\n  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\r\n  d3.svg.axis = function() {\r\n    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, tickMajorSize = 6, tickMinorSize = 6, tickEndSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_, tickSubdivide = 0;\r\n    function axis(g) {\r\n      g.each(function() {\r\n        var g = d3.select(this);\r\n        var ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain() : tickValues, tickFormat = tickFormat_ == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String : tickFormat_;\r\n        var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide), subtick = g.selectAll(\".tick.minor\").data(subticks, String), subtickEnter = subtick.enter().insert(\"line\", \".tick\").attr(\"class\", \"tick minor\").style(\"opacity\", 1e-6), subtickExit = d3.transition(subtick.exit()).style(\"opacity\", 1e-6).remove(), subtickUpdate = d3.transition(subtick).style(\"opacity\", 1);\r\n        var tick = g.selectAll(\".tick.major\").data(ticks, String), tickEnter = tick.enter().insert(\"g\", \"path\").attr(\"class\", \"tick major\").style(\"opacity\", 1e-6), tickExit = d3.transition(tick.exit()).style(\"opacity\", 1e-6).remove(), tickUpdate = d3.transition(tick).style(\"opacity\", 1), tickTransform;\r\n        var range = d3_scaleRange(scale), path = g.selectAll(\".domain\").data([ 0 ]), pathUpdate = (path.enter().append(\"path\").attr(\"class\", \"domain\"), \r\n        d3.transition(path));\r\n        var scale1 = scale.copy(), scale0 = this.__chart__ || scale1;\r\n        this.__chart__ = scale1;\r\n        tickEnter.append(\"line\");\r\n        tickEnter.append(\"text\");\r\n        var lineEnter = tickEnter.select(\"line\"), lineUpdate = tickUpdate.select(\"line\"), text = tick.select(\"text\").text(tickFormat), textEnter = tickEnter.select(\"text\"), textUpdate = tickUpdate.select(\"text\");\r\n        switch (orient) {\r\n         case \"bottom\":\r\n          {\r\n            tickTransform = d3_svg_axisX;\r\n            subtickEnter.attr(\"y2\", tickMinorSize);\r\n            subtickUpdate.attr(\"x2\", 0).attr(\"y2\", tickMinorSize);\r\n            lineEnter.attr(\"y2\", tickMajorSize);\r\n            textEnter.attr(\"y\", Math.max(tickMajorSize, 0) + tickPadding);\r\n            lineUpdate.attr(\"x2\", 0).attr(\"y2\", tickMajorSize);\r\n            textUpdate.attr(\"x\", 0).attr(\"y\", Math.max(tickMajorSize, 0) + tickPadding);\r\n            text.attr(\"dy\", \".71em\").style(\"text-anchor\", \"middle\");\r\n            pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + tickEndSize + \"V0H\" + range[1] + \"V\" + tickEndSize);\r\n            break;\r\n          }\r\n\r\n         case \"top\":\r\n          {\r\n            tickTransform = d3_svg_axisX;\r\n            subtickEnter.attr(\"y2\", -tickMinorSize);\r\n            subtickUpdate.attr(\"x2\", 0).attr(\"y2\", -tickMinorSize);\r\n            lineEnter.attr(\"y2\", -tickMajorSize);\r\n            textEnter.attr(\"y\", -(Math.max(tickMajorSize, 0) + tickPadding));\r\n            lineUpdate.attr(\"x2\", 0).attr(\"y2\", -tickMajorSize);\r\n            textUpdate.attr(\"x\", 0).attr(\"y\", -(Math.max(tickMajorSize, 0) + tickPadding));\r\n            text.attr(\"dy\", \"0em\").style(\"text-anchor\", \"middle\");\r\n            pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + -tickEndSize + \"V0H\" + range[1] + \"V\" + -tickEndSize);\r\n            break;\r\n          }\r\n\r\n         case \"left\":\r\n          {\r\n            tickTransform = d3_svg_axisY;\r\n            subtickEnter.attr(\"x2\", -tickMinorSize);\r\n            subtickUpdate.attr(\"x2\", -tickMinorSize).attr(\"y2\", 0);\r\n            lineEnter.attr(\"x2\", -tickMajorSize);\r\n            textEnter.attr(\"x\", -(Math.max(tickMajorSize, 0) + tickPadding));\r\n            lineUpdate.attr(\"x2\", -tickMajorSize).attr(\"y2\", 0);\r\n            textUpdate.attr(\"x\", -(Math.max(tickMajorSize, 0) + tickPadding)).attr(\"y\", 0);\r\n            text.attr(\"dy\", \".32em\").style(\"text-anchor\", \"end\");\r\n            pathUpdate.attr(\"d\", \"M\" + -tickEndSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + -tickEndSize);\r\n            break;\r\n          }\r\n\r\n         case \"right\":\r\n          {\r\n            tickTransform = d3_svg_axisY;\r\n            subtickEnter.attr(\"x2\", tickMinorSize);\r\n            subtickUpdate.attr(\"x2\", tickMinorSize).attr(\"y2\", 0);\r\n            lineEnter.attr(\"x2\", tickMajorSize);\r\n            textEnter.attr(\"x\", Math.max(tickMajorSize, 0) + tickPadding);\r\n            lineUpdate.attr(\"x2\", tickMajorSize).attr(\"y2\", 0);\r\n            textUpdate.attr(\"x\", Math.max(tickMajorSize, 0) + tickPadding).attr(\"y\", 0);\r\n            text.attr(\"dy\", \".32em\").style(\"text-anchor\", \"start\");\r\n            pathUpdate.attr(\"d\", \"M\" + tickEndSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + tickEndSize);\r\n            break;\r\n          }\r\n        }\r\n        if (scale.ticks) {\r\n          tickEnter.call(tickTransform, scale0);\r\n          tickUpdate.call(tickTransform, scale1);\r\n          tickExit.call(tickTransform, scale1);\r\n          subtickEnter.call(tickTransform, scale0);\r\n          subtickUpdate.call(tickTransform, scale1);\r\n          subtickExit.call(tickTransform, scale1);\r\n        } else {\r\n          var dx = scale1.rangeBand() / 2, x = function(d) {\r\n            return scale1(d) + dx;\r\n          };\r\n          tickEnter.call(tickTransform, x);\r\n          tickUpdate.call(tickTransform, x);\r\n        }\r\n      });\r\n    }\r\n    axis.scale = function(x) {\r\n      if (!arguments.length) return scale;\r\n      scale = x;\r\n      return axis;\r\n    };\r\n    axis.orient = function(x) {\r\n      if (!arguments.length) return orient;\r\n      orient = x in d3_svg_axisOrients ? x + \"\" : d3_svg_axisDefaultOrient;\r\n      return axis;\r\n    };\r\n    axis.ticks = function() {\r\n      if (!arguments.length) return tickArguments_;\r\n      tickArguments_ = arguments;\r\n      return axis;\r\n    };\r\n    axis.tickValues = function(x) {\r\n      if (!arguments.length) return tickValues;\r\n      tickValues = x;\r\n      return axis;\r\n    };\r\n    axis.tickFormat = function(x) {\r\n      if (!arguments.length) return tickFormat_;\r\n      tickFormat_ = x;\r\n      return axis;\r\n    };\r\n    axis.tickSize = function(x, y) {\r\n      if (!arguments.length) return tickMajorSize;\r\n      var n = arguments.length - 1;\r\n      tickMajorSize = +x;\r\n      tickMinorSize = n > 1 ? +y : tickMajorSize;\r\n      tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;\r\n      return axis;\r\n    };\r\n    axis.tickPadding = function(x) {\r\n      if (!arguments.length) return tickPadding;\r\n      tickPadding = +x;\r\n      return axis;\r\n    };\r\n    axis.tickSubdivide = function(x) {\r\n      if (!arguments.length) return tickSubdivide;\r\n      tickSubdivide = +x;\r\n      return axis;\r\n    };\r\n    return axis;\r\n  };\r\n  var d3_svg_axisDefaultOrient = \"bottom\", d3_svg_axisOrients = {\r\n    top: 1,\r\n    right: 1,\r\n    bottom: 1,\r\n    left: 1\r\n  };\r\n  function d3_svg_axisX(selection, x) {\r\n    selection.attr(\"transform\", function(d) {\r\n      return \"translate(\" + x(d) + \",0)\";\r\n    });\r\n  }\r\n  function d3_svg_axisY(selection, y) {\r\n    selection.attr(\"transform\", function(d) {\r\n      return \"translate(0,\" + y(d) + \")\";\r\n    });\r\n  }\r\n  function d3_svg_axisSubdivide(scale, ticks, m) {\r\n    subticks = [];\r\n    if (m && ticks.length > 1) {\r\n      var extent = d3_scaleExtent(scale.domain()), subticks, i = -1, n = ticks.length, d = (ticks[1] - ticks[0]) / ++m, j, v;\r\n      while (++i < n) {\r\n        for (j = m; --j > 0; ) {\r\n          if ((v = +ticks[i] - j * d) >= extent[0]) {\r\n            subticks.push(v);\r\n          }\r\n        }\r\n      }\r\n      for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1]; ) {\r\n        subticks.push(v);\r\n      }\r\n    }\r\n    return subticks;\r\n  }\r\n  d3.svg.brush = function() {\r\n    var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"), x = null, y = null, resizes = d3_svg_brushResizes[0], extent = [ [ 0, 0 ], [ 0, 0 ] ], extentDomain;\r\n    function brush(g) {\r\n      g.each(function() {\r\n        var g = d3.select(this), bg = g.selectAll(\".background\").data([ 0 ]), fg = g.selectAll(\".extent\").data([ 0 ]), tz = g.selectAll(\".resize\").data(resizes, String), e;\r\n        g.style(\"pointer-events\", \"all\").on(\"mousedown.brush\", brushstart).on(\"touchstart.brush\", brushstart);\r\n        bg.enter().append(\"rect\").attr(\"class\", \"background\").style(\"visibility\", \"hidden\").style(\"cursor\", \"crosshair\");\r\n        fg.enter().append(\"rect\").attr(\"class\", \"extent\").style(\"cursor\", \"move\");\r\n        tz.enter().append(\"g\").attr(\"class\", function(d) {\r\n          return \"resize \" + d;\r\n        }).style(\"cursor\", function(d) {\r\n          return d3_svg_brushCursor[d];\r\n        }).append(\"rect\").attr(\"x\", function(d) {\r\n          return /[ew]$/.test(d) ? -3 : null;\r\n        }).attr(\"y\", function(d) {\r\n          return /^[ns]/.test(d) ? -3 : null;\r\n        }).attr(\"width\", 6).attr(\"height\", 6).style(\"visibility\", \"hidden\");\r\n        tz.style(\"display\", brush.empty() ? \"none\" : null);\r\n        tz.exit().remove();\r\n        if (x) {\r\n          e = d3_scaleRange(x);\r\n          bg.attr(\"x\", e[0]).attr(\"width\", e[1] - e[0]);\r\n          redrawX(g);\r\n        }\r\n        if (y) {\r\n          e = d3_scaleRange(y);\r\n          bg.attr(\"y\", e[0]).attr(\"height\", e[1] - e[0]);\r\n          redrawY(g);\r\n        }\r\n        redraw(g);\r\n      });\r\n    }\r\n    function redraw(g) {\r\n      g.selectAll(\".resize\").attr(\"transform\", function(d) {\r\n        return \"translate(\" + extent[+/e$/.test(d)][0] + \",\" + extent[+/^s/.test(d)][1] + \")\";\r\n      });\r\n    }\r\n    function redrawX(g) {\r\n      g.select(\".extent\").attr(\"x\", extent[0][0]);\r\n      g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", extent[1][0] - extent[0][0]);\r\n    }\r\n    function redrawY(g) {\r\n      g.select(\".extent\").attr(\"y\", extent[0][1]);\r\n      g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", extent[1][1] - extent[0][1]);\r\n    }\r\n    function brushstart() {\r\n      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed(\"extent\"), center, origin = mouse(), offset;\r\n      var w = d3.select(d3_window).on(\"mousemove.brush\", brushmove).on(\"mouseup.brush\", brushend).on(\"touchmove.brush\", brushmove).on(\"touchend.brush\", brushend).on(\"keydown.brush\", keydown).on(\"keyup.brush\", keyup);\r\n      if (dragging) {\r\n        origin[0] = extent[0][0] - origin[0];\r\n        origin[1] = extent[0][1] - origin[1];\r\n      } else if (resizing) {\r\n        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);\r\n        offset = [ extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1] ];\r\n        origin[0] = extent[ex][0];\r\n        origin[1] = extent[ey][1];\r\n      } else if (d3.event.altKey) center = origin.slice();\r\n      g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\r\n      d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\r\n      event_({\r\n        type: \"brushstart\"\r\n      });\r\n      brushmove();\r\n      d3_eventCancel();\r\n      function mouse() {\r\n        var touches = d3.event.changedTouches;\r\n        return touches ? d3.touches(target, touches)[0] : d3.mouse(target);\r\n      }\r\n      function keydown() {\r\n        if (d3.event.keyCode == 32) {\r\n          if (!dragging) {\r\n            center = null;\r\n            origin[0] -= extent[1][0];\r\n            origin[1] -= extent[1][1];\r\n            dragging = 2;\r\n          }\r\n          d3_eventCancel();\r\n        }\r\n      }\r\n      function keyup() {\r\n        if (d3.event.keyCode == 32 && dragging == 2) {\r\n          origin[0] += extent[1][0];\r\n          origin[1] += extent[1][1];\r\n          dragging = 0;\r\n          d3_eventCancel();\r\n        }\r\n      }\r\n      function brushmove() {\r\n        var point = mouse(), moved = false;\r\n        if (offset) {\r\n          point[0] += offset[0];\r\n          point[1] += offset[1];\r\n        }\r\n        if (!dragging) {\r\n          if (d3.event.altKey) {\r\n            if (!center) center = [ (extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2 ];\r\n            origin[0] = extent[+(point[0] < center[0])][0];\r\n            origin[1] = extent[+(point[1] < center[1])][1];\r\n          } else center = null;\r\n        }\r\n        if (resizingX && move1(point, x, 0)) {\r\n          redrawX(g);\r\n          moved = true;\r\n        }\r\n        if (resizingY && move1(point, y, 1)) {\r\n          redrawY(g);\r\n          moved = true;\r\n        }\r\n        if (moved) {\r\n          redraw(g);\r\n          event_({\r\n            type: \"brush\",\r\n            mode: dragging ? \"move\" : \"resize\"\r\n          });\r\n        }\r\n      }\r\n      function move1(point, scale, i) {\r\n        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], size = extent[1][i] - extent[0][i], min, max;\r\n        if (dragging) {\r\n          r0 -= position;\r\n          r1 -= size + position;\r\n        }\r\n        min = Math.max(r0, Math.min(r1, point[i]));\r\n        if (dragging) {\r\n          max = (min += position) + size;\r\n        } else {\r\n          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\r\n          if (position < min) {\r\n            max = min;\r\n            min = position;\r\n          } else {\r\n            max = position;\r\n          }\r\n        }\r\n        if (extent[0][i] !== min || extent[1][i] !== max) {\r\n          extentDomain = null;\r\n          extent[0][i] = min;\r\n          extent[1][i] = max;\r\n          return true;\r\n        }\r\n      }\r\n      function brushend() {\r\n        brushmove();\r\n        g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\r\n        d3.select(\"body\").style(\"cursor\", null);\r\n        w.on(\"mousemove.brush\", null).on(\"mouseup.brush\", null).on(\"touchmove.brush\", null).on(\"touchend.brush\", null).on(\"keydown.brush\", null).on(\"keyup.brush\", null);\r\n        event_({\r\n          type: \"brushend\"\r\n        });\r\n        d3_eventCancel();\r\n      }\r\n    }\r\n    brush.x = function(z) {\r\n      if (!arguments.length) return x;\r\n      x = z;\r\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\r\n      return brush;\r\n    };\r\n    brush.y = function(z) {\r\n      if (!arguments.length) return y;\r\n      y = z;\r\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\r\n      return brush;\r\n    };\r\n    brush.extent = function(z) {\r\n      var x0, x1, y0, y1, t;\r\n      if (!arguments.length) {\r\n        z = extentDomain || extent;\r\n        if (x) {\r\n          x0 = z[0][0], x1 = z[1][0];\r\n          if (!extentDomain) {\r\n            x0 = extent[0][0], x1 = extent[1][0];\r\n            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\r\n            if (x1 < x0) t = x0, x0 = x1, x1 = t;\r\n          }\r\n        }\r\n        if (y) {\r\n          y0 = z[0][1], y1 = z[1][1];\r\n          if (!extentDomain) {\r\n            y0 = extent[0][1], y1 = extent[1][1];\r\n            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\r\n            if (y1 < y0) t = y0, y0 = y1, y1 = t;\r\n          }\r\n        }\r\n        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];\r\n      }\r\n      extentDomain = [ [ 0, 0 ], [ 0, 0 ] ];\r\n      if (x) {\r\n        x0 = z[0], x1 = z[1];\r\n        if (y) x0 = x0[0], x1 = x1[0];\r\n        extentDomain[0][0] = x0, extentDomain[1][0] = x1;\r\n        if (x.invert) x0 = x(x0), x1 = x(x1);\r\n        if (x1 < x0) t = x0, x0 = x1, x1 = t;\r\n        extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;\r\n      }\r\n      if (y) {\r\n        y0 = z[0], y1 = z[1];\r\n        if (x) y0 = y0[1], y1 = y1[1];\r\n        extentDomain[0][1] = y0, extentDomain[1][1] = y1;\r\n        if (y.invert) y0 = y(y0), y1 = y(y1);\r\n        if (y1 < y0) t = y0, y0 = y1, y1 = t;\r\n        extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;\r\n      }\r\n      return brush;\r\n    };\r\n    brush.clear = function() {\r\n      extentDomain = null;\r\n      extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;\r\n      return brush;\r\n    };\r\n    brush.empty = function() {\r\n      return x && extent[0][0] === extent[1][0] || y && extent[0][1] === extent[1][1];\r\n    };\r\n    return d3.rebind(brush, event, \"on\");\r\n  };\r\n  var d3_svg_brushCursor = {\r\n    n: \"ns-resize\",\r\n    e: \"ew-resize\",\r\n    s: \"ns-resize\",\r\n    w: \"ew-resize\",\r\n    nw: \"nwse-resize\",\r\n    ne: \"nesw-resize\",\r\n    se: \"nwse-resize\",\r\n    sw: \"nesw-resize\"\r\n  };\r\n  var d3_svg_brushResizes = [ [ \"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\" ], [ \"e\", \"w\" ], [ \"n\", \"s\" ], [] ];\r\n  d3.behavior = {};\r\n  d3.behavior.drag = function() {\r\n    var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"), origin = null;\r\n    function drag() {\r\n      this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", mousedown);\r\n    }\r\n    function mousedown() {\r\n      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, touchId = d3.event.touches ? d3.event.changedTouches[0].identifier : null, offset, origin_ = point(), moved = 0;\r\n      var w = d3.select(d3_window).on(touchId != null ? \"touchmove.drag-\" + touchId : \"mousemove.drag\", dragmove).on(touchId != null ? \"touchend.drag-\" + touchId : \"mouseup.drag\", dragend, true);\r\n      if (origin) {\r\n        offset = origin.apply(target, arguments);\r\n        offset = [ offset.x - origin_[0], offset.y - origin_[1] ];\r\n      } else {\r\n        offset = [ 0, 0 ];\r\n      }\r\n      if (touchId == null) d3_eventCancel();\r\n      event_({\r\n        type: \"dragstart\"\r\n      });\r\n      function point() {\r\n        var p = target.parentNode;\r\n        return touchId != null ? d3.touches(p).filter(function(p) {\r\n          return p.identifier === touchId;\r\n        })[0] : d3.mouse(p);\r\n      }\r\n      function dragmove() {\r\n        if (!target.parentNode) return dragend();\r\n        var p = point(), dx = p[0] - origin_[0], dy = p[1] - origin_[1];\r\n        moved |= dx | dy;\r\n        origin_ = p;\r\n        d3_eventCancel();\r\n        event_({\r\n          type: \"drag\",\r\n          x: p[0] + offset[0],\r\n          y: p[1] + offset[1],\r\n          dx: dx,\r\n          dy: dy\r\n        });\r\n      }\r\n      function dragend() {\r\n        event_({\r\n          type: \"dragend\"\r\n        });\r\n        if (moved) {\r\n          d3_eventCancel();\r\n          if (d3.event.target === eventTarget) w.on(\"click.drag\", click, true);\r\n        }\r\n        w.on(touchId != null ? \"touchmove.drag-\" + touchId : \"mousemove.drag\", null).on(touchId != null ? \"touchend.drag-\" + touchId : \"mouseup.drag\", null);\r\n      }\r\n      function click() {\r\n        d3_eventCancel();\r\n        w.on(\"click.drag\", null);\r\n      }\r\n    }\r\n    drag.origin = function(x) {\r\n      if (!arguments.length) return origin;\r\n      origin = x;\r\n      return drag;\r\n    };\r\n    return d3.rebind(drag, event, \"on\");\r\n  };\r\n  d3.behavior.zoom = function() {\r\n    var translate = [ 0, 0 ], translate0, scale = 1, scale0, scaleExtent = d3_behavior_zoomInfinity, event = d3_eventDispatch(zoom, \"zoom\"), x0, x1, y0, y1, touchtime;\r\n    function zoom() {\r\n      this.on(\"mousedown.zoom\", mousedown).on(\"mousemove.zoom\", mousemove).on(d3_behavior_zoomWheel + \".zoom\", mousewheel).on(\"dblclick.zoom\", dblclick).on(\"touchstart.zoom\", touchstart).on(\"touchmove.zoom\", touchmove).on(\"touchend.zoom\", touchstart);\r\n    }\r\n    zoom.translate = function(x) {\r\n      if (!arguments.length) return translate;\r\n      translate = x.map(Number);\r\n      rescale();\r\n      return zoom;\r\n    };\r\n    zoom.scale = function(x) {\r\n      if (!arguments.length) return scale;\r\n      scale = +x;\r\n      rescale();\r\n      return zoom;\r\n    };\r\n    zoom.scaleExtent = function(x) {\r\n      if (!arguments.length) return scaleExtent;\r\n      scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);\r\n      return zoom;\r\n    };\r\n    zoom.x = function(z) {\r\n      if (!arguments.length) return x1;\r\n      x1 = z;\r\n      x0 = z.copy();\r\n      translate = [ 0, 0 ];\r\n      scale = 1;\r\n      return zoom;\r\n    };\r\n    zoom.y = function(z) {\r\n      if (!arguments.length) return y1;\r\n      y1 = z;\r\n      y0 = z.copy();\r\n      translate = [ 0, 0 ];\r\n      scale = 1;\r\n      return zoom;\r\n    };\r\n    function location(p) {\r\n      return [ (p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale ];\r\n    }\r\n    function point(l) {\r\n      return [ l[0] * scale + translate[0], l[1] * scale + translate[1] ];\r\n    }\r\n    function scaleTo(s) {\r\n      scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\r\n    }\r\n    function translateTo(p, l) {\r\n      l = point(l);\r\n      translate[0] += p[0] - l[0];\r\n      translate[1] += p[1] - l[1];\r\n    }\r\n    function rescale() {\r\n      if (x1) x1.domain(x0.range().map(function(x) {\r\n        return (x - translate[0]) / scale;\r\n      }).map(x0.invert));\r\n      if (y1) y1.domain(y0.range().map(function(y) {\r\n        return (y - translate[1]) / scale;\r\n      }).map(y0.invert));\r\n    }\r\n    function dispatch(event) {\r\n      rescale();\r\n      d3.event.preventDefault();\r\n      event({\r\n        type: \"zoom\",\r\n        scale: scale,\r\n        translate: translate\r\n      });\r\n    }\r\n    function mousedown() {\r\n      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, moved = 0, w = d3.select(d3_window).on(\"mousemove.zoom\", mousemove).on(\"mouseup.zoom\", mouseup), l = location(d3.mouse(target));\r\n      d3_window.focus();\r\n      d3_eventCancel();\r\n      function mousemove() {\r\n        moved = 1;\r\n        translateTo(d3.mouse(target), l);\r\n        dispatch(event_);\r\n      }\r\n      function mouseup() {\r\n        if (moved) d3_eventCancel();\r\n        w.on(\"mousemove.zoom\", null).on(\"mouseup.zoom\", null);\r\n        if (moved && d3.event.target === eventTarget) w.on(\"click.zoom\", click, true);\r\n      }\r\n      function click() {\r\n        d3_eventCancel();\r\n        w.on(\"click.zoom\", null);\r\n      }\r\n    }\r\n    function mousewheel() {\r\n      if (!translate0) translate0 = location(d3.mouse(this));\r\n      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);\r\n      translateTo(d3.mouse(this), translate0);\r\n      dispatch(event.of(this, arguments));\r\n    }\r\n    function mousemove() {\r\n      translate0 = null;\r\n    }\r\n    function dblclick() {\r\n      var p = d3.mouse(this), l = location(p), k = Math.log(scale) / Math.LN2;\r\n      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));\r\n      translateTo(p, l);\r\n      dispatch(event.of(this, arguments));\r\n    }\r\n    function touchstart() {\r\n      var touches = d3.touches(this), now = Date.now();\r\n      scale0 = scale;\r\n      translate0 = {};\r\n      touches.forEach(function(t) {\r\n        translate0[t.identifier] = location(t);\r\n      });\r\n      d3_eventCancel();\r\n      if (touches.length === 1) {\r\n        if (now - touchtime < 500) {\r\n          var p = touches[0], l = location(touches[0]);\r\n          scaleTo(scale * 2);\r\n          translateTo(p, l);\r\n          dispatch(event.of(this, arguments));\r\n        }\r\n        touchtime = now;\r\n      }\r\n    }\r\n    function touchmove() {\r\n      var touches = d3.touches(this), p0 = touches[0], l0 = translate0[p0.identifier];\r\n      if (p1 = touches[1]) {\r\n        var p1, l1 = translate0[p1.identifier];\r\n        p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];\r\n        l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];\r\n        scaleTo(d3.event.scale * scale0);\r\n      }\r\n      translateTo(p0, l0);\r\n      touchtime = null;\r\n      dispatch(event.of(this, arguments));\r\n    }\r\n    return d3.rebind(zoom, event, \"on\");\r\n  };\r\n  var d3_behavior_zoomInfinity = [ 0, Infinity ];\r\n  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = \"onwheel\" in document ? (d3_behavior_zoomDelta = function() {\r\n    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);\r\n  }, \"wheel\") : \"onmousewheel\" in document ? (d3_behavior_zoomDelta = function() {\r\n    return d3.event.wheelDelta;\r\n  }, \"mousewheel\") : (d3_behavior_zoomDelta = function() {\r\n    return -d3.event.detail;\r\n  }, \"MozMousePixelScroll\");\r\n  d3.layout = {};\r\n  d3.layout.bundle = function() {\r\n    return function(links) {\r\n      var paths = [], i = -1, n = links.length;\r\n      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\r\n      return paths;\r\n    };\r\n  };\r\n  function d3_layout_bundlePath(link) {\r\n    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];\r\n    while (start !== lca) {\r\n      start = start.parent;\r\n      points.push(start);\r\n    }\r\n    var k = points.length;\r\n    while (end !== lca) {\r\n      points.splice(k, 0, end);\r\n      end = end.parent;\r\n    }\r\n    return points;\r\n  }\r\n  function d3_layout_bundleAncestors(node) {\r\n    var ancestors = [], parent = node.parent;\r\n    while (parent != null) {\r\n      ancestors.push(node);\r\n      node = parent;\r\n      parent = parent.parent;\r\n    }\r\n    ancestors.push(node);\r\n    return ancestors;\r\n  }\r\n  function d3_layout_bundleLeastCommonAncestor(a, b) {\r\n    if (a === b) return a;\r\n    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;\r\n    while (aNode === bNode) {\r\n      sharedNode = aNode;\r\n      aNode = aNodes.pop();\r\n      bNode = bNodes.pop();\r\n    }\r\n    return sharedNode;\r\n  }\r\n  d3.layout.chord = function() {\r\n    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;\r\n    function relayout() {\r\n      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;\r\n      chords = [];\r\n      groups = [];\r\n      k = 0, i = -1;\r\n      while (++i < n) {\r\n        x = 0, j = -1;\r\n        while (++j < n) {\r\n          x += matrix[i][j];\r\n        }\r\n        groupSums.push(x);\r\n        subgroupIndex.push(d3.range(n));\r\n        k += x;\r\n      }\r\n      if (sortGroups) {\r\n        groupIndex.sort(function(a, b) {\r\n          return sortGroups(groupSums[a], groupSums[b]);\r\n        });\r\n      }\r\n      if (sortSubgroups) {\r\n        subgroupIndex.forEach(function(d, i) {\r\n          d.sort(function(a, b) {\r\n            return sortSubgroups(matrix[i][a], matrix[i][b]);\r\n          });\r\n        });\r\n      }\r\n      k = (2 * π - padding * n) / k;\r\n      x = 0, i = -1;\r\n      while (++i < n) {\r\n        x0 = x, j = -1;\r\n        while (++j < n) {\r\n          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;\r\n          subgroups[di + \"-\" + dj] = {\r\n            index: di,\r\n            subindex: dj,\r\n            startAngle: a0,\r\n            endAngle: a1,\r\n            value: v\r\n          };\r\n        }\r\n        groups[di] = {\r\n          index: di,\r\n          startAngle: x0,\r\n          endAngle: x,\r\n          value: (x - x0) / k\r\n        };\r\n        x += padding;\r\n      }\r\n      i = -1;\r\n      while (++i < n) {\r\n        j = i - 1;\r\n        while (++j < n) {\r\n          var source = subgroups[i + \"-\" + j], target = subgroups[j + \"-\" + i];\r\n          if (source.value || target.value) {\r\n            chords.push(source.value < target.value ? {\r\n              source: target,\r\n              target: source\r\n            } : {\r\n              source: source,\r\n              target: target\r\n            });\r\n          }\r\n        }\r\n      }\r\n      if (sortChords) resort();\r\n    }\r\n    function resort() {\r\n      chords.sort(function(a, b) {\r\n        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\r\n      });\r\n    }\r\n    chord.matrix = function(x) {\r\n      if (!arguments.length) return matrix;\r\n      n = (matrix = x) && matrix.length;\r\n      chords = groups = null;\r\n      return chord;\r\n    };\r\n    chord.padding = function(x) {\r\n      if (!arguments.length) return padding;\r\n      padding = x;\r\n      chords = groups = null;\r\n      return chord;\r\n    };\r\n    chord.sortGroups = function(x) {\r\n      if (!arguments.length) return sortGroups;\r\n      sortGroups = x;\r\n      chords = groups = null;\r\n      return chord;\r\n    };\r\n    chord.sortSubgroups = function(x) {\r\n      if (!arguments.length) return sortSubgroups;\r\n      sortSubgroups = x;\r\n      chords = null;\r\n      return chord;\r\n    };\r\n    chord.sortChords = function(x) {\r\n      if (!arguments.length) return sortChords;\r\n      sortChords = x;\r\n      if (chords) resort();\r\n      return chord;\r\n    };\r\n    chord.chords = function() {\r\n      if (!chords) relayout();\r\n      return chords;\r\n    };\r\n    chord.groups = function() {\r\n      if (!groups) relayout();\r\n      return groups;\r\n    };\r\n    return chord;\r\n  };\r\n  d3.layout.force = function() {\r\n    var force = {}, event = d3.dispatch(\"start\", \"tick\", \"end\"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, gravity = .1, theta = .8, nodes = [], links = [], distances, strengths, charges;\r\n    function repulse(node) {\r\n      return function(quad, x1, _, x2) {\r\n        if (quad.point !== node) {\r\n          var dx = quad.cx - node.x, dy = quad.cy - node.y, dn = 1 / Math.sqrt(dx * dx + dy * dy);\r\n          if ((x2 - x1) * dn < theta) {\r\n            var k = quad.charge * dn * dn;\r\n            node.px -= dx * k;\r\n            node.py -= dy * k;\r\n            return true;\r\n          }\r\n          if (quad.point && isFinite(dn)) {\r\n            var k = quad.pointCharge * dn * dn;\r\n            node.px -= dx * k;\r\n            node.py -= dy * k;\r\n          }\r\n        }\r\n        return !quad.charge;\r\n      };\r\n    }\r\n    force.tick = function() {\r\n      if ((alpha *= .99) < .005) {\r\n        event.end({\r\n          type: \"end\",\r\n          alpha: alpha = 0\r\n        });\r\n        return true;\r\n      }\r\n      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;\r\n      for (i = 0; i < m; ++i) {\r\n        o = links[i];\r\n        s = o.source;\r\n        t = o.target;\r\n        x = t.x - s.x;\r\n        y = t.y - s.y;\r\n        if (l = x * x + y * y) {\r\n          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\r\n          x *= l;\r\n          y *= l;\r\n          t.x -= x * (k = s.weight / (t.weight + s.weight));\r\n          t.y -= y * k;\r\n          s.x += x * (k = 1 - k);\r\n          s.y += y * k;\r\n        }\r\n      }\r\n      if (k = alpha * gravity) {\r\n        x = size[0] / 2;\r\n        y = size[1] / 2;\r\n        i = -1;\r\n        if (k) while (++i < n) {\r\n          o = nodes[i];\r\n          o.x += (x - o.x) * k;\r\n          o.y += (y - o.y) * k;\r\n        }\r\n      }\r\n      if (charge) {\r\n        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\r\n        i = -1;\r\n        while (++i < n) {\r\n          if (!(o = nodes[i]).fixed) {\r\n            q.visit(repulse(o));\r\n          }\r\n        }\r\n      }\r\n      i = -1;\r\n      while (++i < n) {\r\n        o = nodes[i];\r\n        if (o.fixed) {\r\n          o.x = o.px;\r\n          o.y = o.py;\r\n        } else {\r\n          o.x -= (o.px - (o.px = o.x)) * friction;\r\n          o.y -= (o.py - (o.py = o.y)) * friction;\r\n        }\r\n      }\r\n      event.tick({\r\n        type: \"tick\",\r\n        alpha: alpha\r\n      });\r\n    };\r\n    force.nodes = function(x) {\r\n      if (!arguments.length) return nodes;\r\n      nodes = x;\r\n      return force;\r\n    };\r\n    force.links = function(x) {\r\n      if (!arguments.length) return links;\r\n      links = x;\r\n      return force;\r\n    };\r\n    force.size = function(x) {\r\n      if (!arguments.length) return size;\r\n      size = x;\r\n      return force;\r\n    };\r\n    force.linkDistance = function(x) {\r\n      if (!arguments.length) return linkDistance;\r\n      linkDistance = typeof x === \"function\" ? x : +x;\r\n      return force;\r\n    };\r\n    force.distance = force.linkDistance;\r\n    force.linkStrength = function(x) {\r\n      if (!arguments.length) return linkStrength;\r\n      linkStrength = typeof x === \"function\" ? x : +x;\r\n      return force;\r\n    };\r\n    force.friction = function(x) {\r\n      if (!arguments.length) return friction;\r\n      friction = +x;\r\n      return force;\r\n    };\r\n    force.charge = function(x) {\r\n      if (!arguments.length) return charge;\r\n      charge = typeof x === \"function\" ? x : +x;\r\n      return force;\r\n    };\r\n    force.gravity = function(x) {\r\n      if (!arguments.length) return gravity;\r\n      gravity = +x;\r\n      return force;\r\n    };\r\n    force.theta = function(x) {\r\n      if (!arguments.length) return theta;\r\n      theta = +x;\r\n      return force;\r\n    };\r\n    force.alpha = function(x) {\r\n      if (!arguments.length) return alpha;\r\n      x = +x;\r\n      if (alpha) {\r\n        if (x > 0) alpha = x; else alpha = 0;\r\n      } else if (x > 0) {\r\n        event.start({\r\n          type: \"start\",\r\n          alpha: alpha = x\r\n        });\r\n        d3.timer(force.tick);\r\n      }\r\n      return force;\r\n    };\r\n    force.start = function() {\r\n      var i, j, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;\r\n      for (i = 0; i < n; ++i) {\r\n        (o = nodes[i]).index = i;\r\n        o.weight = 0;\r\n      }\r\n      for (i = 0; i < m; ++i) {\r\n        o = links[i];\r\n        if (typeof o.source == \"number\") o.source = nodes[o.source];\r\n        if (typeof o.target == \"number\") o.target = nodes[o.target];\r\n        ++o.source.weight;\r\n        ++o.target.weight;\r\n      }\r\n      for (i = 0; i < n; ++i) {\r\n        o = nodes[i];\r\n        if (isNaN(o.x)) o.x = position(\"x\", w);\r\n        if (isNaN(o.y)) o.y = position(\"y\", h);\r\n        if (isNaN(o.px)) o.px = o.x;\r\n        if (isNaN(o.py)) o.py = o.y;\r\n      }\r\n      distances = [];\r\n      if (typeof linkDistance === \"function\") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;\r\n      strengths = [];\r\n      if (typeof linkStrength === \"function\") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;\r\n      charges = [];\r\n      if (typeof charge === \"function\") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;\r\n      function position(dimension, size) {\r\n        var neighbors = neighbor(i), j = -1, m = neighbors.length, x;\r\n        while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;\r\n        return Math.random() * size;\r\n      }\r\n      function neighbor() {\r\n        if (!neighbors) {\r\n          neighbors = [];\r\n          for (j = 0; j < n; ++j) {\r\n            neighbors[j] = [];\r\n          }\r\n          for (j = 0; j < m; ++j) {\r\n            var o = links[j];\r\n            neighbors[o.source.index].push(o.target);\r\n            neighbors[o.target.index].push(o.source);\r\n          }\r\n        }\r\n        return neighbors[i];\r\n      }\r\n      return force.resume();\r\n    };\r\n    force.resume = function() {\r\n      return force.alpha(.1);\r\n    };\r\n    force.stop = function() {\r\n      return force.alpha(0);\r\n    };\r\n    force.drag = function() {\r\n      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(\"dragstart.force\", d3_layout_forceDragstart).on(\"drag.force\", dragmove).on(\"dragend.force\", d3_layout_forceDragend);\r\n      if (!arguments.length) return drag;\r\n      this.on(\"mouseover.force\", d3_layout_forceMouseover).on(\"mouseout.force\", d3_layout_forceMouseout).call(drag);\r\n    };\r\n    function dragmove(d) {\r\n      d.px = d3.event.x, d.py = d3.event.y;\r\n      force.resume();\r\n    }\r\n    return d3.rebind(force, event, \"on\");\r\n  };\r\n  function d3_layout_forceDragstart(d) {\r\n    d.fixed |= 2;\r\n  }\r\n  function d3_layout_forceDragend(d) {\r\n    d.fixed &= ~6;\r\n  }\r\n  function d3_layout_forceMouseover(d) {\r\n    d.fixed |= 4;\r\n    d.px = d.x, d.py = d.y;\r\n  }\r\n  function d3_layout_forceMouseout(d) {\r\n    d.fixed &= ~4;\r\n  }\r\n  function d3_layout_forceAccumulate(quad, alpha, charges) {\r\n    var cx = 0, cy = 0;\r\n    quad.charge = 0;\r\n    if (!quad.leaf) {\r\n      var nodes = quad.nodes, n = nodes.length, i = -1, c;\r\n      while (++i < n) {\r\n        c = nodes[i];\r\n        if (c == null) continue;\r\n        d3_layout_forceAccumulate(c, alpha, charges);\r\n        quad.charge += c.charge;\r\n        cx += c.charge * c.cx;\r\n        cy += c.charge * c.cy;\r\n      }\r\n    }\r\n    if (quad.point) {\r\n      if (!quad.leaf) {\r\n        quad.point.x += Math.random() - .5;\r\n        quad.point.y += Math.random() - .5;\r\n      }\r\n      var k = alpha * charges[quad.point.index];\r\n      quad.charge += quad.pointCharge = k;\r\n      cx += k * quad.point.x;\r\n      cy += k * quad.point.y;\r\n    }\r\n    quad.cx = cx / quad.charge;\r\n    quad.cy = cy / quad.charge;\r\n  }\r\n  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1;\r\n  d3.layout.partition = function() {\r\n    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];\r\n    function position(node, x, dx, dy) {\r\n      var children = node.children;\r\n      node.x = x;\r\n      node.y = node.depth * dy;\r\n      node.dx = dx;\r\n      node.dy = dy;\r\n      if (children && (n = children.length)) {\r\n        var i = -1, n, c, d;\r\n        dx = node.value ? dx / node.value : 0;\r\n        while (++i < n) {\r\n          position(c = children[i], x, d = c.value * dx, dy);\r\n          x += d;\r\n        }\r\n      }\r\n    }\r\n    function depth(node) {\r\n      var children = node.children, d = 0;\r\n      if (children && (n = children.length)) {\r\n        var i = -1, n;\r\n        while (++i < n) d = Math.max(d, depth(children[i]));\r\n      }\r\n      return 1 + d;\r\n    }\r\n    function partition(d, i) {\r\n      var nodes = hierarchy.call(this, d, i);\r\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\r\n      return nodes;\r\n    }\r\n    partition.size = function(x) {\r\n      if (!arguments.length) return size;\r\n      size = x;\r\n      return partition;\r\n    };\r\n    return d3_layout_hierarchyRebind(partition, hierarchy);\r\n  };\r\n  d3.layout.pie = function() {\r\n    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = 2 * π;\r\n    function pie(data) {\r\n      var values = data.map(function(d, i) {\r\n        return +value.call(pie, d, i);\r\n      });\r\n      var a = +(typeof startAngle === \"function\" ? startAngle.apply(this, arguments) : startAngle);\r\n      var k = ((typeof endAngle === \"function\" ? endAngle.apply(this, arguments) : endAngle) - startAngle) / d3.sum(values);\r\n      var index = d3.range(data.length);\r\n      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {\r\n        return values[j] - values[i];\r\n      } : function(i, j) {\r\n        return sort(data[i], data[j]);\r\n      });\r\n      var arcs = [];\r\n      index.forEach(function(i) {\r\n        var d;\r\n        arcs[i] = {\r\n          data: data[i],\r\n          value: d = values[i],\r\n          startAngle: a,\r\n          endAngle: a += d * k\r\n        };\r\n      });\r\n      return arcs;\r\n    }\r\n    pie.value = function(x) {\r\n      if (!arguments.length) return value;\r\n      value = x;\r\n      return pie;\r\n    };\r\n    pie.sort = function(x) {\r\n      if (!arguments.length) return sort;\r\n      sort = x;\r\n      return pie;\r\n    };\r\n    pie.startAngle = function(x) {\r\n      if (!arguments.length) return startAngle;\r\n      startAngle = x;\r\n      return pie;\r\n    };\r\n    pie.endAngle = function(x) {\r\n      if (!arguments.length) return endAngle;\r\n      endAngle = x;\r\n      return pie;\r\n    };\r\n    return pie;\r\n  };\r\n  var d3_layout_pieSortByValue = {};\r\n  d3.layout.stack = function() {\r\n    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;\r\n    function stack(data, index) {\r\n      var series = data.map(function(d, i) {\r\n        return values.call(stack, d, i);\r\n      });\r\n      var points = series.map(function(d) {\r\n        return d.map(function(v, i) {\r\n          return [ x.call(stack, v, i), y.call(stack, v, i) ];\r\n        });\r\n      });\r\n      var orders = order.call(stack, points, index);\r\n      series = d3.permute(series, orders);\r\n      points = d3.permute(points, orders);\r\n      var offsets = offset.call(stack, points, index);\r\n      var n = series.length, m = series[0].length, i, j, o;\r\n      for (j = 0; j < m; ++j) {\r\n        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\r\n        for (i = 1; i < n; ++i) {\r\n          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\r\n        }\r\n      }\r\n      return data;\r\n    }\r\n    stack.values = function(x) {\r\n      if (!arguments.length) return values;\r\n      values = x;\r\n      return stack;\r\n    };\r\n    stack.order = function(x) {\r\n      if (!arguments.length) return order;\r\n      order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\r\n      return stack;\r\n    };\r\n    stack.offset = function(x) {\r\n      if (!arguments.length) return offset;\r\n      offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\r\n      return stack;\r\n    };\r\n    stack.x = function(z) {\r\n      if (!arguments.length) return x;\r\n      x = z;\r\n      return stack;\r\n    };\r\n    stack.y = function(z) {\r\n      if (!arguments.length) return y;\r\n      y = z;\r\n      return stack;\r\n    };\r\n    stack.out = function(z) {\r\n      if (!arguments.length) return out;\r\n      out = z;\r\n      return stack;\r\n    };\r\n    return stack;\r\n  };\r\n  function d3_layout_stackX(d) {\r\n    return d.x;\r\n  }\r\n  function d3_layout_stackY(d) {\r\n    return d.y;\r\n  }\r\n  function d3_layout_stackOut(d, y0, y) {\r\n    d.y0 = y0;\r\n    d.y = y;\r\n  }\r\n  var d3_layout_stackOrders = d3.map({\r\n    \"inside-out\": function(data) {\r\n      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {\r\n        return max[a] - max[b];\r\n      }), top = 0, bottom = 0, tops = [], bottoms = [];\r\n      for (i = 0; i < n; ++i) {\r\n        j = index[i];\r\n        if (top < bottom) {\r\n          top += sums[j];\r\n          tops.push(j);\r\n        } else {\r\n          bottom += sums[j];\r\n          bottoms.push(j);\r\n        }\r\n      }\r\n      return bottoms.reverse().concat(tops);\r\n    },\r\n    reverse: function(data) {\r\n      return d3.range(data.length).reverse();\r\n    },\r\n    \"default\": d3_layout_stackOrderDefault\r\n  });\r\n  var d3_layout_stackOffsets = d3.map({\r\n    silhouette: function(data) {\r\n      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];\r\n      for (j = 0; j < m; ++j) {\r\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\r\n        if (o > max) max = o;\r\n        sums.push(o);\r\n      }\r\n      for (j = 0; j < m; ++j) {\r\n        y0[j] = (max - sums[j]) / 2;\r\n      }\r\n      return y0;\r\n    },\r\n    wiggle: function(data) {\r\n      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];\r\n      y0[0] = o = o0 = 0;\r\n      for (j = 1; j < m; ++j) {\r\n        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\r\n        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\r\n          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\r\n            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\r\n          }\r\n          s2 += s3 * data[i][j][1];\r\n        }\r\n        y0[j] = o -= s1 ? s2 / s1 * dx : 0;\r\n        if (o < o0) o0 = o;\r\n      }\r\n      for (j = 0; j < m; ++j) y0[j] -= o0;\r\n      return y0;\r\n    },\r\n    expand: function(data) {\r\n      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];\r\n      for (j = 0; j < m; ++j) {\r\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\r\n        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;\r\n      }\r\n      for (j = 0; j < m; ++j) y0[j] = 0;\r\n      return y0;\r\n    },\r\n    zero: d3_layout_stackOffsetZero\r\n  });\r\n  function d3_layout_stackOrderDefault(data) {\r\n    return d3.range(data.length);\r\n  }\r\n  function d3_layout_stackOffsetZero(data) {\r\n    var j = -1, m = data[0].length, y0 = [];\r\n    while (++j < m) y0[j] = 0;\r\n    return y0;\r\n  }\r\n  function d3_layout_stackMaxIndex(array) {\r\n    var i = 1, j = 0, v = array[0][1], k, n = array.length;\r\n    for (;i < n; ++i) {\r\n      if ((k = array[i][1]) > v) {\r\n        j = i;\r\n        v = k;\r\n      }\r\n    }\r\n    return j;\r\n  }\r\n  function d3_layout_stackReduceSum(d) {\r\n    return d.reduce(d3_layout_stackSum, 0);\r\n  }\r\n  function d3_layout_stackSum(p, d) {\r\n    return p + d[1];\r\n  }\r\n  d3.layout.histogram = function() {\r\n    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;\r\n    function histogram(data, i) {\r\n      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;\r\n      while (++i < m) {\r\n        bin = bins[i] = [];\r\n        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\r\n        bin.y = 0;\r\n      }\r\n      if (m > 0) {\r\n        i = -1;\r\n        while (++i < n) {\r\n          x = values[i];\r\n          if (x >= range[0] && x <= range[1]) {\r\n            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\r\n            bin.y += k;\r\n            bin.push(data[i]);\r\n          }\r\n        }\r\n      }\r\n      return bins;\r\n    }\r\n    histogram.value = function(x) {\r\n      if (!arguments.length) return valuer;\r\n      valuer = x;\r\n      return histogram;\r\n    };\r\n    histogram.range = function(x) {\r\n      if (!arguments.length) return ranger;\r\n      ranger = d3_functor(x);\r\n      return histogram;\r\n    };\r\n    histogram.bins = function(x) {\r\n      if (!arguments.length) return binner;\r\n      binner = typeof x === \"number\" ? function(range) {\r\n        return d3_layout_histogramBinFixed(range, x);\r\n      } : d3_functor(x);\r\n      return histogram;\r\n    };\r\n    histogram.frequency = function(x) {\r\n      if (!arguments.length) return frequency;\r\n      frequency = !!x;\r\n      return histogram;\r\n    };\r\n    return histogram;\r\n  };\r\n  function d3_layout_histogramBinSturges(range, values) {\r\n    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\r\n  }\r\n  function d3_layout_histogramBinFixed(range, n) {\r\n    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];\r\n    while (++x <= n) f[x] = m * x + b;\r\n    return f;\r\n  }\r\n  function d3_layout_histogramRange(values) {\r\n    return [ d3.min(values), d3.max(values) ];\r\n  }\r\n  d3.layout.hierarchy = function() {\r\n    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\r\n    function recurse(node, depth, nodes) {\r\n      var childs = children.call(hierarchy, node, depth);\r\n      node.depth = depth;\r\n      nodes.push(node);\r\n      if (childs && (n = childs.length)) {\r\n        var i = -1, n, c = node.children = [], v = 0, j = depth + 1, d;\r\n        while (++i < n) {\r\n          d = recurse(childs[i], j, nodes);\r\n          d.parent = node;\r\n          c.push(d);\r\n          v += d.value;\r\n        }\r\n        if (sort) c.sort(sort);\r\n        if (value) node.value = v;\r\n      } else if (value) {\r\n        node.value = +value.call(hierarchy, node, depth) || 0;\r\n      }\r\n      return node;\r\n    }\r\n    function revalue(node, depth) {\r\n      var children = node.children, v = 0;\r\n      if (children && (n = children.length)) {\r\n        var i = -1, n, j = depth + 1;\r\n        while (++i < n) v += revalue(children[i], j);\r\n      } else if (value) {\r\n        v = +value.call(hierarchy, node, depth) || 0;\r\n      }\r\n      if (value) node.value = v;\r\n      return v;\r\n    }\r\n    function hierarchy(d) {\r\n      var nodes = [];\r\n      recurse(d, 0, nodes);\r\n      return nodes;\r\n    }\r\n    hierarchy.sort = function(x) {\r\n      if (!arguments.length) return sort;\r\n      sort = x;\r\n      return hierarchy;\r\n    };\r\n    hierarchy.children = function(x) {\r\n      if (!arguments.length) return children;\r\n      children = x;\r\n      return hierarchy;\r\n    };\r\n    hierarchy.value = function(x) {\r\n      if (!arguments.length) return value;\r\n      value = x;\r\n      return hierarchy;\r\n    };\r\n    hierarchy.revalue = function(root) {\r\n      revalue(root, 0);\r\n      return root;\r\n    };\r\n    return hierarchy;\r\n  };\r\n  function d3_layout_hierarchyRebind(object, hierarchy) {\r\n    d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\r\n    object.nodes = object;\r\n    object.links = d3_layout_hierarchyLinks;\r\n    return object;\r\n  }\r\n  function d3_layout_hierarchyChildren(d) {\r\n    return d.children;\r\n  }\r\n  function d3_layout_hierarchyValue(d) {\r\n    return d.value;\r\n  }\r\n  function d3_layout_hierarchySort(a, b) {\r\n    return b.value - a.value;\r\n  }\r\n  function d3_layout_hierarchyLinks(nodes) {\r\n    return d3.merge(nodes.map(function(parent) {\r\n      return (parent.children || []).map(function(child) {\r\n        return {\r\n          source: parent,\r\n          target: child\r\n        };\r\n      });\r\n    }));\r\n  }\r\n  d3.layout.pack = function() {\r\n    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ];\r\n    function pack(d, i) {\r\n      var nodes = hierarchy.call(this, d, i), root = nodes[0];\r\n      root.x = 0;\r\n      root.y = 0;\r\n      d3_layout_treeVisitAfter(root, function(d) {\r\n        d.r = Math.sqrt(d.value);\r\n      });\r\n      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);\r\n      var w = size[0], h = size[1], k = Math.max(2 * root.r / w, 2 * root.r / h);\r\n      if (padding > 0) {\r\n        var dr = padding * k / 2;\r\n        d3_layout_treeVisitAfter(root, function(d) {\r\n          d.r += dr;\r\n        });\r\n        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);\r\n        d3_layout_treeVisitAfter(root, function(d) {\r\n          d.r -= dr;\r\n        });\r\n        k = Math.max(2 * root.r / w, 2 * root.r / h);\r\n      }\r\n      d3_layout_packTransform(root, w / 2, h / 2, 1 / k);\r\n      return nodes;\r\n    }\r\n    pack.size = function(x) {\r\n      if (!arguments.length) return size;\r\n      size = x;\r\n      return pack;\r\n    };\r\n    pack.padding = function(_) {\r\n      if (!arguments.length) return padding;\r\n      padding = +_;\r\n      return pack;\r\n    };\r\n    return d3_layout_hierarchyRebind(pack, hierarchy);\r\n  };\r\n  function d3_layout_packSort(a, b) {\r\n    return a.value - b.value;\r\n  }\r\n  function d3_layout_packInsert(a, b) {\r\n    var c = a._pack_next;\r\n    a._pack_next = b;\r\n    b._pack_prev = a;\r\n    b._pack_next = c;\r\n    c._pack_prev = b;\r\n  }\r\n  function d3_layout_packSplice(a, b) {\r\n    a._pack_next = b;\r\n    b._pack_prev = a;\r\n  }\r\n  function d3_layout_packIntersects(a, b) {\r\n    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;\r\n    return dr * dr - dx * dx - dy * dy > .001;\r\n  }\r\n  function d3_layout_packSiblings(node) {\r\n    if (!(nodes = node.children) || !(n = nodes.length)) return;\r\n    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;\r\n    function bound(node) {\r\n      xMin = Math.min(node.x - node.r, xMin);\r\n      xMax = Math.max(node.x + node.r, xMax);\r\n      yMin = Math.min(node.y - node.r, yMin);\r\n      yMax = Math.max(node.y + node.r, yMax);\r\n    }\r\n    nodes.forEach(d3_layout_packLink);\r\n    a = nodes[0];\r\n    a.x = -a.r;\r\n    a.y = 0;\r\n    bound(a);\r\n    if (n > 1) {\r\n      b = nodes[1];\r\n      b.x = b.r;\r\n      b.y = 0;\r\n      bound(b);\r\n      if (n > 2) {\r\n        c = nodes[2];\r\n        d3_layout_packPlace(a, b, c);\r\n        bound(c);\r\n        d3_layout_packInsert(a, c);\r\n        a._pack_prev = c;\r\n        d3_layout_packInsert(c, b);\r\n        b = a._pack_next;\r\n        for (i = 3; i < n; i++) {\r\n          d3_layout_packPlace(a, b, c = nodes[i]);\r\n          var isect = 0, s1 = 1, s2 = 1;\r\n          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\r\n            if (d3_layout_packIntersects(j, c)) {\r\n              isect = 1;\r\n              break;\r\n            }\r\n          }\r\n          if (isect == 1) {\r\n            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\r\n              if (d3_layout_packIntersects(k, c)) {\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          if (isect) {\r\n            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);\r\n            i--;\r\n          } else {\r\n            d3_layout_packInsert(a, c);\r\n            b = c;\r\n            bound(c);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;\r\n    for (i = 0; i < n; i++) {\r\n      c = nodes[i];\r\n      c.x -= cx;\r\n      c.y -= cy;\r\n      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\r\n    }\r\n    node.r = cr;\r\n    nodes.forEach(d3_layout_packUnlink);\r\n  }\r\n  function d3_layout_packLink(node) {\r\n    node._pack_next = node._pack_prev = node;\r\n  }\r\n  function d3_layout_packUnlink(node) {\r\n    delete node._pack_next;\r\n    delete node._pack_prev;\r\n  }\r\n  function d3_layout_packTransform(node, x, y, k) {\r\n    var children = node.children;\r\n    node.x = x += k * node.x;\r\n    node.y = y += k * node.y;\r\n    node.r *= k;\r\n    if (children) {\r\n      var i = -1, n = children.length;\r\n      while (++i < n) d3_layout_packTransform(children[i], x, y, k);\r\n    }\r\n  }\r\n  function d3_layout_packPlace(a, b, c) {\r\n    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;\r\n    if (db && (dx || dy)) {\r\n      var da = b.r + c.r, dc = dx * dx + dy * dy;\r\n      da *= da;\r\n      db *= db;\r\n      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\r\n      c.x = a.x + x * dx + y * dy;\r\n      c.y = a.y + x * dy - y * dx;\r\n    } else {\r\n      c.x = a.x + db;\r\n      c.y = a.y;\r\n    }\r\n  }\r\n  d3.layout.cluster = function() {\r\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];\r\n    function cluster(d, i) {\r\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;\r\n      d3_layout_treeVisitAfter(root, function(node) {\r\n        var children = node.children;\r\n        if (children && children.length) {\r\n          node.x = d3_layout_clusterX(children);\r\n          node.y = d3_layout_clusterY(children);\r\n        } else {\r\n          node.x = previousNode ? x += separation(node, previousNode) : 0;\r\n          node.y = 0;\r\n          previousNode = node;\r\n        }\r\n      });\r\n      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\r\n      d3_layout_treeVisitAfter(root, function(node) {\r\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\r\n        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\r\n      });\r\n      return nodes;\r\n    }\r\n    cluster.separation = function(x) {\r\n      if (!arguments.length) return separation;\r\n      separation = x;\r\n      return cluster;\r\n    };\r\n    cluster.size = function(x) {\r\n      if (!arguments.length) return size;\r\n      size = x;\r\n      return cluster;\r\n    };\r\n    return d3_layout_hierarchyRebind(cluster, hierarchy);\r\n  };\r\n  function d3_layout_clusterY(children) {\r\n    return 1 + d3.max(children, function(child) {\r\n      return child.y;\r\n    });\r\n  }\r\n  function d3_layout_clusterX(children) {\r\n    return children.reduce(function(x, child) {\r\n      return x + child.x;\r\n    }, 0) / children.length;\r\n  }\r\n  function d3_layout_clusterLeft(node) {\r\n    var children = node.children;\r\n    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\r\n  }\r\n  function d3_layout_clusterRight(node) {\r\n    var children = node.children, n;\r\n    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\r\n  }\r\n  d3.layout.tree = function() {\r\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];\r\n    function tree(d, i) {\r\n      var nodes = hierarchy.call(this, d, i), root = nodes[0];\r\n      function firstWalk(node, previousSibling) {\r\n        var children = node.children, layout = node._tree;\r\n        if (children && (n = children.length)) {\r\n          var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;\r\n          while (++i < n) {\r\n            child = children[i];\r\n            firstWalk(child, previousChild);\r\n            ancestor = apportion(child, previousChild, ancestor);\r\n            previousChild = child;\r\n          }\r\n          d3_layout_treeShift(node);\r\n          var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);\r\n          if (previousSibling) {\r\n            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\r\n            layout.mod = layout.prelim - midpoint;\r\n          } else {\r\n            layout.prelim = midpoint;\r\n          }\r\n        } else {\r\n          if (previousSibling) {\r\n            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\r\n          }\r\n        }\r\n      }\r\n      function secondWalk(node, x) {\r\n        node.x = node._tree.prelim + x;\r\n        var children = node.children;\r\n        if (children && (n = children.length)) {\r\n          var i = -1, n;\r\n          x += node._tree.mod;\r\n          while (++i < n) {\r\n            secondWalk(children[i], x);\r\n          }\r\n        }\r\n      }\r\n      function apportion(node, previousSibling, ancestor) {\r\n        if (previousSibling) {\r\n          var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;\r\n          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\r\n            vom = d3_layout_treeLeft(vom);\r\n            vop = d3_layout_treeRight(vop);\r\n            vop._tree.ancestor = node;\r\n            shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);\r\n            if (shift > 0) {\r\n              d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);\r\n              sip += shift;\r\n              sop += shift;\r\n            }\r\n            sim += vim._tree.mod;\r\n            sip += vip._tree.mod;\r\n            som += vom._tree.mod;\r\n            sop += vop._tree.mod;\r\n          }\r\n          if (vim && !d3_layout_treeRight(vop)) {\r\n            vop._tree.thread = vim;\r\n            vop._tree.mod += sim - sop;\r\n          }\r\n          if (vip && !d3_layout_treeLeft(vom)) {\r\n            vom._tree.thread = vip;\r\n            vom._tree.mod += sip - som;\r\n            ancestor = node;\r\n          }\r\n        }\r\n        return ancestor;\r\n      }\r\n      d3_layout_treeVisitAfter(root, function(node, previousSibling) {\r\n        node._tree = {\r\n          ancestor: node,\r\n          prelim: 0,\r\n          mod: 0,\r\n          change: 0,\r\n          shift: 0,\r\n          number: previousSibling ? previousSibling._tree.number + 1 : 0\r\n        };\r\n      });\r\n      firstWalk(root);\r\n      secondWalk(root, -root._tree.prelim);\r\n      var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost), right = d3_layout_treeSearch(root, d3_layout_treeRightmost), deep = d3_layout_treeSearch(root, d3_layout_treeDeepest), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2, y1 = deep.depth || 1;\r\n      d3_layout_treeVisitAfter(root, function(node) {\r\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\r\n        node.y = node.depth / y1 * size[1];\r\n        delete node._tree;\r\n      });\r\n      return nodes;\r\n    }\r\n    tree.separation = function(x) {\r\n      if (!arguments.length) return separation;\r\n      separation = x;\r\n      return tree;\r\n    };\r\n    tree.size = function(x) {\r\n      if (!arguments.length) return size;\r\n      size = x;\r\n      return tree;\r\n    };\r\n    return d3_layout_hierarchyRebind(tree, hierarchy);\r\n  };\r\n  function d3_layout_treeSeparation(a, b) {\r\n    return a.parent == b.parent ? 1 : 2;\r\n  }\r\n  function d3_layout_treeLeft(node) {\r\n    var children = node.children;\r\n    return children && children.length ? children[0] : node._tree.thread;\r\n  }\r\n  function d3_layout_treeRight(node) {\r\n    var children = node.children, n;\r\n    return children && (n = children.length) ? children[n - 1] : node._tree.thread;\r\n  }\r\n  function d3_layout_treeSearch(node, compare) {\r\n    var children = node.children;\r\n    if (children && (n = children.length)) {\r\n      var child, n, i = -1;\r\n      while (++i < n) {\r\n        if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {\r\n          node = child;\r\n        }\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n  function d3_layout_treeRightmost(a, b) {\r\n    return a.x - b.x;\r\n  }\r\n  function d3_layout_treeLeftmost(a, b) {\r\n    return b.x - a.x;\r\n  }\r\n  function d3_layout_treeDeepest(a, b) {\r\n    return a.depth - b.depth;\r\n  }\r\n  function d3_layout_treeVisitAfter(node, callback) {\r\n    function visit(node, previousSibling) {\r\n      var children = node.children;\r\n      if (children && (n = children.length)) {\r\n        var child, previousChild = null, i = -1, n;\r\n        while (++i < n) {\r\n          child = children[i];\r\n          visit(child, previousChild);\r\n          previousChild = child;\r\n        }\r\n      }\r\n      callback(node, previousSibling);\r\n    }\r\n    visit(node, null);\r\n  }\r\n  function d3_layout_treeShift(node) {\r\n    var shift = 0, change = 0, children = node.children, i = children.length, child;\r\n    while (--i >= 0) {\r\n      child = children[i]._tree;\r\n      child.prelim += shift;\r\n      child.mod += shift;\r\n      shift += child.shift + (change += child.change);\r\n    }\r\n  }\r\n  function d3_layout_treeMove(ancestor, node, shift) {\r\n    ancestor = ancestor._tree;\r\n    node = node._tree;\r\n    var change = shift / (node.number - ancestor.number);\r\n    ancestor.change += change;\r\n    node.change -= change;\r\n    node.shift += shift;\r\n    node.prelim += shift;\r\n    node.mod += shift;\r\n  }\r\n  function d3_layout_treeAncestor(vim, node, ancestor) {\r\n    return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;\r\n  }\r\n  d3.layout.treemap = function() {\r\n    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = \"squarify\", ratio = .5 * (1 + Math.sqrt(5));\r\n    function scale(children, k) {\r\n      var i = -1, n = children.length, child, area;\r\n      while (++i < n) {\r\n        area = (child = children[i]).value * (k < 0 ? 0 : k);\r\n        child.area = isNaN(area) || area <= 0 ? 0 : area;\r\n      }\r\n    }\r\n    function squarify(node) {\r\n      var children = node.children;\r\n      if (children && children.length) {\r\n        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === \"slice\" ? rect.dx : mode === \"dice\" ? rect.dy : mode === \"slice-dice\" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;\r\n        scale(remaining, rect.dx * rect.dy / node.value);\r\n        row.area = 0;\r\n        while ((n = remaining.length) > 0) {\r\n          row.push(child = remaining[n - 1]);\r\n          row.area += child.area;\r\n          if (mode !== \"squarify\" || (score = worst(row, u)) <= best) {\r\n            remaining.pop();\r\n            best = score;\r\n          } else {\r\n            row.area -= row.pop().area;\r\n            position(row, u, rect, false);\r\n            u = Math.min(rect.dx, rect.dy);\r\n            row.length = row.area = 0;\r\n            best = Infinity;\r\n          }\r\n        }\r\n        if (row.length) {\r\n          position(row, u, rect, true);\r\n          row.length = row.area = 0;\r\n        }\r\n        children.forEach(squarify);\r\n      }\r\n    }\r\n    function stickify(node) {\r\n      var children = node.children;\r\n      if (children && children.length) {\r\n        var rect = pad(node), remaining = children.slice(), child, row = [];\r\n        scale(remaining, rect.dx * rect.dy / node.value);\r\n        row.area = 0;\r\n        while (child = remaining.pop()) {\r\n          row.push(child);\r\n          row.area += child.area;\r\n          if (child.z != null) {\r\n            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\r\n            row.length = row.area = 0;\r\n          }\r\n        }\r\n        children.forEach(stickify);\r\n      }\r\n    }\r\n    function worst(row, u) {\r\n      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;\r\n      while (++i < n) {\r\n        if (!(r = row[i].area)) continue;\r\n        if (r < rmin) rmin = r;\r\n        if (r > rmax) rmax = r;\r\n      }\r\n      s *= s;\r\n      u *= u;\r\n      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\r\n    }\r\n    function position(row, u, rect, flush) {\r\n      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;\r\n      if (u == rect.dx) {\r\n        if (flush || v > rect.dy) v = rect.dy;\r\n        while (++i < n) {\r\n          o = row[i];\r\n          o.x = x;\r\n          o.y = y;\r\n          o.dy = v;\r\n          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\r\n        }\r\n        o.z = true;\r\n        o.dx += rect.x + rect.dx - x;\r\n        rect.y += v;\r\n        rect.dy -= v;\r\n      } else {\r\n        if (flush || v > rect.dx) v = rect.dx;\r\n        while (++i < n) {\r\n          o = row[i];\r\n          o.x = x;\r\n          o.y = y;\r\n          o.dx = v;\r\n          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\r\n        }\r\n        o.z = false;\r\n        o.dy += rect.y + rect.dy - y;\r\n        rect.x += v;\r\n        rect.dx -= v;\r\n      }\r\n    }\r\n    function treemap(d) {\r\n      var nodes = stickies || hierarchy(d), root = nodes[0];\r\n      root.x = 0;\r\n      root.y = 0;\r\n      root.dx = size[0];\r\n      root.dy = size[1];\r\n      if (stickies) hierarchy.revalue(root);\r\n      scale([ root ], root.dx * root.dy / root.value);\r\n      (stickies ? stickify : squarify)(root);\r\n      if (sticky) stickies = nodes;\r\n      return nodes;\r\n    }\r\n    treemap.size = function(x) {\r\n      if (!arguments.length) return size;\r\n      size = x;\r\n      return treemap;\r\n    };\r\n    treemap.padding = function(x) {\r\n      if (!arguments.length) return padding;\r\n      function padFunction(node) {\r\n        var p = x.call(treemap, node, node.depth);\r\n        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === \"number\" ? [ p, p, p, p ] : p);\r\n      }\r\n      function padConstant(node) {\r\n        return d3_layout_treemapPad(node, x);\r\n      }\r\n      var type;\r\n      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === \"function\" ? padFunction : type === \"number\" ? (x = [ x, x, x, x ], \r\n      padConstant) : padConstant;\r\n      return treemap;\r\n    };\r\n    treemap.round = function(x) {\r\n      if (!arguments.length) return round != Number;\r\n      round = x ? Math.round : Number;\r\n      return treemap;\r\n    };\r\n    treemap.sticky = function(x) {\r\n      if (!arguments.length) return sticky;\r\n      sticky = x;\r\n      stickies = null;\r\n      return treemap;\r\n    };\r\n    treemap.ratio = function(x) {\r\n      if (!arguments.length) return ratio;\r\n      ratio = x;\r\n      return treemap;\r\n    };\r\n    treemap.mode = function(x) {\r\n      if (!arguments.length) return mode;\r\n      mode = x + \"\";\r\n      return treemap;\r\n    };\r\n    return d3_layout_hierarchyRebind(treemap, hierarchy);\r\n  };\r\n  function d3_layout_treemapPadNull(node) {\r\n    return {\r\n      x: node.x,\r\n      y: node.y,\r\n      dx: node.dx,\r\n      dy: node.dy\r\n    };\r\n  }\r\n  function d3_layout_treemapPad(node, padding) {\r\n    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];\r\n    if (dx < 0) {\r\n      x += dx / 2;\r\n      dx = 0;\r\n    }\r\n    if (dy < 0) {\r\n      y += dy / 2;\r\n      dy = 0;\r\n    }\r\n    return {\r\n      x: x,\r\n      y: y,\r\n      dx: dx,\r\n      dy: dy\r\n    };\r\n  }\r\n  function d3_dsv(delimiter, mimeType) {\r\n    var reFormat = new RegExp('[\"' + delimiter + \"\\n]\"), delimiterCode = delimiter.charCodeAt(0);\r\n    function dsv(url, callback) {\r\n      return d3.xhr(url, mimeType, callback).response(response);\r\n    }\r\n    function response(request) {\r\n      return dsv.parse(request.responseText);\r\n    }\r\n    dsv.parse = function(text) {\r\n      var o;\r\n      return dsv.parseRows(text, function(row) {\r\n        if (o) return o(row);\r\n        o = new Function(\"d\", \"return {\" + row.map(function(name, i) {\r\n          return JSON.stringify(name) + \": d[\" + i + \"]\";\r\n        }).join(\",\") + \"}\");\r\n      });\r\n    };\r\n    dsv.parseRows = function(text, f) {\r\n      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;\r\n      function token() {\r\n        if (I >= N) return EOF;\r\n        if (eol) return eol = false, EOL;\r\n        var j = I;\r\n        if (text.charCodeAt(j) === 34) {\r\n          var i = j;\r\n          while (i++ < N) {\r\n            if (text.charCodeAt(i) === 34) {\r\n              if (text.charCodeAt(i + 1) !== 34) break;\r\n              ++i;\r\n            }\r\n          }\r\n          I = i + 2;\r\n          var c = text.charCodeAt(i + 1);\r\n          if (c === 13) {\r\n            eol = true;\r\n            if (text.charCodeAt(i + 2) === 10) ++I;\r\n          } else if (c === 10) {\r\n            eol = true;\r\n          }\r\n          return text.substring(j + 1, i).replace(/\"\"/g, '\"');\r\n        }\r\n        while (I < N) {\r\n          var c = text.charCodeAt(I++), k = 1;\r\n          if (c === 10) eol = true; else if (c === 13) {\r\n            eol = true;\r\n            if (text.charCodeAt(I) === 10) ++I, ++k;\r\n          } else if (c !== delimiterCode) continue;\r\n          return text.substring(j, I - k);\r\n        }\r\n        return text.substring(j);\r\n      }\r\n      while ((t = token()) !== EOF) {\r\n        var a = [];\r\n        while (t !== EOL && t !== EOF) {\r\n          a.push(t);\r\n          t = token();\r\n        }\r\n        if (f && !(a = f(a, n++))) continue;\r\n        rows.push(a);\r\n      }\r\n      return rows;\r\n    };\r\n    dsv.format = function(rows) {\r\n      return rows.map(formatRow).join(\"\\n\");\r\n    };\r\n    function formatRow(row) {\r\n      return row.map(formatValue).join(delimiter);\r\n    }\r\n    function formatValue(text) {\r\n      return reFormat.test(text) ? '\"' + text.replace(/\\\"/g, '\"\"') + '\"' : text;\r\n    }\r\n    return dsv;\r\n  }\r\n  d3.csv = d3_dsv(\",\", \"text/csv\");\r\n  d3.tsv = d3_dsv(\"    \", \"text/tab-separated-values\");\r\n  d3.geo = {};\r\n  d3.geo.stream = function(object, listener) {\r\n    if (d3_geo_streamObjectType.hasOwnProperty(object.type)) {\r\n      d3_geo_streamObjectType[object.type](object, listener);\r\n    } else {\r\n      d3_geo_streamGeometry(object, listener);\r\n    }\r\n  };\r\n  function d3_geo_streamGeometry(geometry, listener) {\r\n    if (d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\r\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\r\n    }\r\n  }\r\n  var d3_geo_streamObjectType = {\r\n    Feature: function(feature, listener) {\r\n      d3_geo_streamGeometry(feature.geometry, listener);\r\n    },\r\n    FeatureCollection: function(object, listener) {\r\n      var features = object.features, i = -1, n = features.length;\r\n      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\r\n    }\r\n  };\r\n  var d3_geo_streamGeometryType = {\r\n    Sphere: function(object, listener) {\r\n      listener.sphere();\r\n    },\r\n    Point: function(object, listener) {\r\n      var coordinate = object.coordinates;\r\n      listener.point(coordinate[0], coordinate[1]);\r\n    },\r\n    MultiPoint: function(object, listener) {\r\n      var coordinates = object.coordinates, i = -1, n = coordinates.length, coordinate;\r\n      while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);\r\n    },\r\n    LineString: function(object, listener) {\r\n      d3_geo_streamLine(object.coordinates, listener, 0);\r\n    },\r\n    MultiLineString: function(object, listener) {\r\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\r\n      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\r\n    },\r\n    Polygon: function(object, listener) {\r\n      d3_geo_streamPolygon(object.coordinates, listener);\r\n    },\r\n    MultiPolygon: function(object, listener) {\r\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\r\n      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\r\n    },\r\n    GeometryCollection: function(object, listener) {\r\n      var geometries = object.geometries, i = -1, n = geometries.length;\r\n      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\r\n    }\r\n  };\r\n  function d3_geo_streamLine(coordinates, listener, closed) {\r\n    var i = -1, n = coordinates.length - closed, coordinate;\r\n    listener.lineStart();\r\n    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);\r\n    listener.lineEnd();\r\n  }\r\n  function d3_geo_streamPolygon(coordinates, listener) {\r\n    var i = -1, n = coordinates.length;\r\n    listener.polygonStart();\r\n    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\r\n    listener.polygonEnd();\r\n  }\r\n  function d3_geo_spherical(cartesian) {\r\n    return [ Math.atan2(cartesian[1], cartesian[0]), Math.asin(Math.max(-1, Math.min(1, cartesian[2]))) ];\r\n  }\r\n  function d3_geo_sphericalEqual(a, b) {\r\n    return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;\r\n  }\r\n  function d3_geo_cartesian(spherical) {\r\n    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);\r\n    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];\r\n  }\r\n  function d3_geo_cartesianDot(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r\n  }\r\n  function d3_geo_cartesianCross(a, b) {\r\n    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\r\n  }\r\n  function d3_geo_cartesianAdd(a, b) {\r\n    a[0] += b[0];\r\n    a[1] += b[1];\r\n    a[2] += b[2];\r\n  }\r\n  function d3_geo_cartesianScale(vector, k) {\r\n    return [ vector[0] * k, vector[1] * k, vector[2] * k ];\r\n  }\r\n  function d3_geo_cartesianNormalize(d) {\r\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\r\n    d[0] /= l;\r\n    d[1] /= l;\r\n    d[2] /= l;\r\n  }\r\n  function d3_geo_resample(project) {\r\n    var δ2 = .5, maxDepth = 16;\r\n    function resample(stream) {\r\n      var λ0, x0, y0, a0, b0, c0;\r\n      var resample = {\r\n        point: point,\r\n        lineStart: lineStart,\r\n        lineEnd: lineEnd,\r\n        polygonStart: function() {\r\n          stream.polygonStart();\r\n          resample.lineStart = polygonLineStart;\r\n        },\r\n        polygonEnd: function() {\r\n          stream.polygonEnd();\r\n          resample.lineStart = lineStart;\r\n        }\r\n      };\r\n      function point(x, y) {\r\n        x = project(x, y);\r\n        stream.point(x[0], x[1]);\r\n      }\r\n      function lineStart() {\r\n        x0 = NaN;\r\n        resample.point = linePoint;\r\n        stream.lineStart();\r\n      }\r\n      function linePoint(λ, φ) {\r\n        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);\r\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\r\n        stream.point(x0, y0);\r\n      }\r\n      function lineEnd() {\r\n        resample.point = point;\r\n        stream.lineEnd();\r\n      }\r\n      function polygonLineStart() {\r\n        var λ00, φ00, x00, y00, a00, b00, c00;\r\n        lineStart();\r\n        resample.point = function(λ, φ) {\r\n          linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\r\n          resample.point = linePoint;\r\n        };\r\n        resample.lineEnd = function() {\r\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);\r\n          resample.lineEnd = lineEnd;\r\n          lineEnd();\r\n        };\r\n      }\r\n      return resample;\r\n    }\r\n    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {\r\n      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\r\n      if (d2 > 4 * δ2 && depth--) {\r\n        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = Math.abs(Math.abs(c) - 1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\r\n        if (dz * dz / d2 > δ2 || Math.abs((dx * dx2 + dy * dy2) / d2 - .5) > .3) {\r\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);\r\n          stream.point(x2, y2);\r\n          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);\r\n        }\r\n      }\r\n    }\r\n    resample.precision = function(_) {\r\n      if (!arguments.length) return Math.sqrt(δ2);\r\n      maxDepth = (δ2 = _ * _) > 0 && 16;\r\n      return resample;\r\n    };\r\n    return resample;\r\n  }\r\n  d3.geo.albersUsa = function() {\r\n    var lower48 = d3.geo.albers();\r\n    var alaska = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 60 ]).parallels([ 55, 65 ]);\r\n    var hawaii = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 20 ]).parallels([ 8, 18 ]);\r\n    var puertoRico = d3.geo.albers().rotate([ 60, 0 ]).center([ 0, 10 ]).parallels([ 8, 18 ]);\r\n    function albersUsa(coordinates) {\r\n      return projection(coordinates)(coordinates);\r\n    }\r\n    function projection(point) {\r\n      var lon = point[0], lat = point[1];\r\n      return lat > 50 ? alaska : lon < -140 ? hawaii : lat < 21 ? puertoRico : lower48;\r\n    }\r\n    albersUsa.scale = function(x) {\r\n      if (!arguments.length) return lower48.scale();\r\n      lower48.scale(x);\r\n      alaska.scale(x * .6);\r\n      hawaii.scale(x);\r\n      puertoRico.scale(x * 1.5);\r\n      return albersUsa.translate(lower48.translate());\r\n    };\r\n    albersUsa.translate = function(x) {\r\n      if (!arguments.length) return lower48.translate();\r\n      var dz = lower48.scale(), dx = x[0], dy = x[1];\r\n      lower48.translate(x);\r\n      alaska.translate([ dx - .4 * dz, dy + .17 * dz ]);\r\n      hawaii.translate([ dx - .19 * dz, dy + .2 * dz ]);\r\n      puertoRico.translate([ dx + .58 * dz, dy + .43 * dz ]);\r\n      return albersUsa;\r\n    };\r\n    return albersUsa.scale(lower48.scale());\r\n  };\r\n  function d3_geo_albers(φ0, φ1) {\r\n    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;\r\n    function albers(λ, φ) {\r\n      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;\r\n      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];\r\n    }\r\n    albers.invert = function(x, y) {\r\n      var ρ0_y = ρ0 - y;\r\n      return [ Math.atan2(x, ρ0_y) / n, Math.asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];\r\n    };\r\n    return albers;\r\n  }\r\n  (d3.geo.albers = function() {\r\n    var φ0 = 29.5 * d3_radians, φ1 = 45.5 * d3_radians, m = d3_geo_projectionMutator(d3_geo_albers), p = m(φ0, φ1);\r\n    p.parallels = function(_) {\r\n      if (!arguments.length) return [ φ0 * d3_degrees, φ1 * d3_degrees ];\r\n      return m(φ0 = _[0] * d3_radians, φ1 = _[1] * d3_radians);\r\n    };\r\n    return p.rotate([ 98, 0 ]).center([ 0, 38 ]).scale(1e3);\r\n  }).raw = d3_geo_albers;\r\n  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {\r\n    return Math.sqrt(2 / (1 + cosλcosφ));\r\n  }, function(ρ) {\r\n    return 2 * Math.asin(ρ / 2);\r\n  });\r\n  (d3.geo.azimuthalEqualArea = function() {\r\n    return d3_geo_projection(d3_geo_azimuthalEqualArea);\r\n  }).raw = d3_geo_azimuthalEqualArea;\r\n  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {\r\n    var c = Math.acos(cosλcosφ);\r\n    return c && c / Math.sin(c);\r\n  }, d3_identity);\r\n  (d3.geo.azimuthalEquidistant = function() {\r\n    return d3_geo_projection(d3_geo_azimuthalEquidistant);\r\n  }).raw = d3_geo_azimuthalEquidistant;\r\n  d3.geo.bounds = d3_geo_bounds(d3_identity);\r\n  function d3_geo_bounds(projectStream) {\r\n    var x0, y0, x1, y1;\r\n    var bound = {\r\n      point: boundPoint,\r\n      lineStart: d3_noop,\r\n      lineEnd: d3_noop,\r\n      polygonStart: function() {\r\n        bound.lineEnd = boundPolygonLineEnd;\r\n      },\r\n      polygonEnd: function() {\r\n        bound.point = boundPoint;\r\n      }\r\n    };\r\n    function boundPoint(x, y) {\r\n      if (x < x0) x0 = x;\r\n      if (x > x1) x1 = x;\r\n      if (y < y0) y0 = y;\r\n      if (y > y1) y1 = y;\r\n    }\r\n    function boundPolygonLineEnd() {\r\n      bound.point = bound.lineEnd = d3_noop;\r\n    }\r\n    return function(feature) {\r\n      y1 = x1 = -(x0 = y0 = Infinity);\r\n      d3.geo.stream(feature, projectStream(bound));\r\n      return [ [ x0, y0 ], [ x1, y1 ] ];\r\n    };\r\n  }\r\n  d3.geo.centroid = function(object) {\r\n    d3_geo_centroidDimension = d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\r\n    d3.geo.stream(object, d3_geo_centroid);\r\n    var m;\r\n    if (d3_geo_centroidW && Math.abs(m = Math.sqrt(d3_geo_centroidX * d3_geo_centroidX + d3_geo_centroidY * d3_geo_centroidY + d3_geo_centroidZ * d3_geo_centroidZ)) > ε) {\r\n      return [ Math.atan2(d3_geo_centroidY, d3_geo_centroidX) * d3_degrees, Math.asin(Math.max(-1, Math.min(1, d3_geo_centroidZ / m))) * d3_degrees ];\r\n    }\r\n  };\r\n  var d3_geo_centroidDimension, d3_geo_centroidW, d3_geo_centroidX, d3_geo_centroidY, d3_geo_centroidZ;\r\n  var d3_geo_centroid = {\r\n    sphere: function() {\r\n      if (d3_geo_centroidDimension < 2) {\r\n        d3_geo_centroidDimension = 2;\r\n        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\r\n      }\r\n    },\r\n    point: d3_geo_centroidPoint,\r\n    lineStart: d3_geo_centroidLineStart,\r\n    lineEnd: d3_geo_centroidLineEnd,\r\n    polygonStart: function() {\r\n      if (d3_geo_centroidDimension < 2) {\r\n        d3_geo_centroidDimension = 2;\r\n        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\r\n      }\r\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\r\n    },\r\n    polygonEnd: function() {\r\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\r\n    }\r\n  };\r\n  function d3_geo_centroidPoint(λ, φ) {\r\n    if (d3_geo_centroidDimension) return;\r\n    ++d3_geo_centroidW;\r\n    λ *= d3_radians;\r\n    var cosφ = Math.cos(φ *= d3_radians);\r\n    d3_geo_centroidX += (cosφ * Math.cos(λ) - d3_geo_centroidX) / d3_geo_centroidW;\r\n    d3_geo_centroidY += (cosφ * Math.sin(λ) - d3_geo_centroidY) / d3_geo_centroidW;\r\n    d3_geo_centroidZ += (Math.sin(φ) - d3_geo_centroidZ) / d3_geo_centroidW;\r\n  }\r\n  function d3_geo_centroidRingStart() {\r\n    var λ00, φ00;\r\n    d3_geo_centroidDimension = 1;\r\n    d3_geo_centroidLineStart();\r\n    d3_geo_centroidDimension = 2;\r\n    var linePoint = d3_geo_centroid.point;\r\n    d3_geo_centroid.point = function(λ, φ) {\r\n      linePoint(λ00 = λ, φ00 = φ);\r\n    };\r\n    d3_geo_centroid.lineEnd = function() {\r\n      d3_geo_centroid.point(λ00, φ00);\r\n      d3_geo_centroidLineEnd();\r\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\r\n    };\r\n  }\r\n  function d3_geo_centroidLineStart() {\r\n    var x0, y0, z0;\r\n    if (d3_geo_centroidDimension > 1) return;\r\n    if (d3_geo_centroidDimension < 1) {\r\n      d3_geo_centroidDimension = 1;\r\n      d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\r\n    }\r\n    d3_geo_centroid.point = function(λ, φ) {\r\n      λ *= d3_radians;\r\n      var cosφ = Math.cos(φ *= d3_radians);\r\n      x0 = cosφ * Math.cos(λ);\r\n      y0 = cosφ * Math.sin(λ);\r\n      z0 = Math.sin(φ);\r\n      d3_geo_centroid.point = nextPoint;\r\n    };\r\n    function nextPoint(λ, φ) {\r\n      λ *= d3_radians;\r\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\r\n      d3_geo_centroidW += w;\r\n      d3_geo_centroidX += w * (x0 + (x0 = x));\r\n      d3_geo_centroidY += w * (y0 + (y0 = y));\r\n      d3_geo_centroidZ += w * (z0 + (z0 = z));\r\n    }\r\n  }\r\n  function d3_geo_centroidLineEnd() {\r\n    d3_geo_centroid.point = d3_geo_centroidPoint;\r\n  }\r\n  d3.geo.circle = function() {\r\n    var origin = [ 0, 0 ], angle, precision = 6, interpolate;\r\n    function circle() {\r\n      var center = typeof origin === \"function\" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];\r\n      interpolate(null, null, 1, {\r\n        point: function(x, y) {\r\n          ring.push(x = rotate(x, y));\r\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\r\n        }\r\n      });\r\n      return {\r\n        type: \"Polygon\",\r\n        coordinates: [ ring ]\r\n      };\r\n    }\r\n    circle.origin = function(x) {\r\n      if (!arguments.length) return origin;\r\n      origin = x;\r\n      return circle;\r\n    };\r\n    circle.angle = function(x) {\r\n      if (!arguments.length) return angle;\r\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\r\n      return circle;\r\n    };\r\n    circle.precision = function(_) {\r\n      if (!arguments.length) return precision;\r\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\r\n      return circle;\r\n    };\r\n    return circle.angle(90);\r\n  };\r\n  function d3_geo_circleInterpolate(radians, precision) {\r\n    var cr = Math.cos(radians), sr = Math.sin(radians);\r\n    return function(from, to, direction, listener) {\r\n      if (from != null) {\r\n        from = d3_geo_circleAngle(cr, from);\r\n        to = d3_geo_circleAngle(cr, to);\r\n        if (direction > 0 ? from < to : from > to) from += direction * 2 * π;\r\n      } else {\r\n        from = radians + direction * 2 * π;\r\n        to = radians;\r\n      }\r\n      var point;\r\n      for (var step = direction * precision, t = from; direction > 0 ? t > to : t < to; t -= step) {\r\n        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);\r\n      }\r\n    };\r\n  }\r\n  function d3_geo_circleAngle(cr, point) {\r\n    var a = d3_geo_cartesian(point);\r\n    a[0] -= cr;\r\n    d3_geo_cartesianNormalize(a);\r\n    var angle = Math.acos(Math.max(-1, Math.min(1, -a[1])));\r\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);\r\n  }\r\n  function d3_geo_clip(pointVisible, clipLine, interpolate) {\r\n    return function(listener) {\r\n      var line = clipLine(listener);\r\n      var clip = {\r\n        point: point,\r\n        lineStart: lineStart,\r\n        lineEnd: lineEnd,\r\n        polygonStart: function() {\r\n          clip.point = pointRing;\r\n          clip.lineStart = ringStart;\r\n          clip.lineEnd = ringEnd;\r\n          invisible = false;\r\n          invisibleArea = visibleArea = 0;\r\n          segments = [];\r\n          listener.polygonStart();\r\n        },\r\n        polygonEnd: function() {\r\n          clip.point = point;\r\n          clip.lineStart = lineStart;\r\n          clip.lineEnd = lineEnd;\r\n          segments = d3.merge(segments);\r\n          if (segments.length) {\r\n            d3_geo_clipPolygon(segments, interpolate, listener);\r\n          } else if (visibleArea < -ε || invisible && invisibleArea < -ε) {\r\n            listener.lineStart();\r\n            interpolate(null, null, 1, listener);\r\n            listener.lineEnd();\r\n          }\r\n          listener.polygonEnd();\r\n          segments = null;\r\n        },\r\n        sphere: function() {\r\n          listener.polygonStart();\r\n          listener.lineStart();\r\n          interpolate(null, null, 1, listener);\r\n          listener.lineEnd();\r\n          listener.polygonEnd();\r\n        }\r\n      };\r\n      function point(λ, φ) {\r\n        if (pointVisible(λ, φ)) listener.point(λ, φ);\r\n      }\r\n      function pointLine(λ, φ) {\r\n        line.point(λ, φ);\r\n      }\r\n      function lineStart() {\r\n        clip.point = pointLine;\r\n        line.lineStart();\r\n      }\r\n      function lineEnd() {\r\n        clip.point = point;\r\n        line.lineEnd();\r\n      }\r\n      var segments, visibleArea, invisibleArea, invisible;\r\n      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), ring;\r\n      function pointRing(λ, φ) {\r\n        ringListener.point(λ, φ);\r\n        ring.push([ λ, φ ]);\r\n      }\r\n      function ringStart() {\r\n        ringListener.lineStart();\r\n        ring = [];\r\n      }\r\n      function ringEnd() {\r\n        pointRing(ring[0][0], ring[0][1]);\r\n        ringListener.lineEnd();\r\n        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;\r\n        if (!n) {\r\n          invisible = true;\r\n          invisibleArea += d3_geo_clipAreaRing(ring, -1);\r\n          ring = null;\r\n          return;\r\n        }\r\n        ring = null;\r\n        if (clean & 1) {\r\n          segment = ringSegments[0];\r\n          visibleArea += d3_geo_clipAreaRing(segment, 1);\r\n          var n = segment.length - 1, i = -1, point;\r\n          listener.lineStart();\r\n          while (++i < n) listener.point((point = segment[i])[0], point[1]);\r\n          listener.lineEnd();\r\n          return;\r\n        }\r\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\r\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\r\n      }\r\n      return clip;\r\n    };\r\n  }\r\n  function d3_geo_clipPolygon(segments, interpolate, listener) {\r\n    var subject = [], clip = [];\r\n    segments.forEach(function(segment) {\r\n      var n = segment.length;\r\n      if (n <= 1) return;\r\n      var p0 = segment[0], p1 = segment[n - 1], a = {\r\n        point: p0,\r\n        points: segment,\r\n        other: null,\r\n        visited: false,\r\n        entry: true,\r\n        subject: true\r\n      }, b = {\r\n        point: p0,\r\n        points: [ p0 ],\r\n        other: a,\r\n        visited: false,\r\n        entry: false,\r\n        subject: false\r\n      };\r\n      a.other = b;\r\n      subject.push(a);\r\n      clip.push(b);\r\n      a = {\r\n        point: p1,\r\n        points: [ p1 ],\r\n        other: null,\r\n        visited: false,\r\n        entry: false,\r\n        subject: true\r\n      };\r\n      b = {\r\n        point: p1,\r\n        points: [ p1 ],\r\n        other: a,\r\n        visited: false,\r\n        entry: true,\r\n        subject: false\r\n      };\r\n      a.other = b;\r\n      subject.push(a);\r\n      clip.push(b);\r\n    });\r\n    clip.sort(d3_geo_clipSort);\r\n    d3_geo_clipLinkCircular(subject);\r\n    d3_geo_clipLinkCircular(clip);\r\n    if (!subject.length) return;\r\n    var start = subject[0], current, points, point;\r\n    while (1) {\r\n      current = start;\r\n      while (current.visited) if ((current = current.next) === start) return;\r\n      points = current.points;\r\n      listener.lineStart();\r\n      do {\r\n        current.visited = current.other.visited = true;\r\n        if (current.entry) {\r\n          if (current.subject) {\r\n            for (var i = 0; i < points.length; i++) listener.point((point = points[i])[0], point[1]);\r\n          } else {\r\n            interpolate(current.point, current.next.point, 1, listener);\r\n          }\r\n          current = current.next;\r\n        } else {\r\n          if (current.subject) {\r\n            points = current.prev.points;\r\n            for (var i = points.length; --i >= 0; ) listener.point((point = points[i])[0], point[1]);\r\n          } else {\r\n            interpolate(current.point, current.prev.point, -1, listener);\r\n          }\r\n          current = current.prev;\r\n        }\r\n        current = current.other;\r\n        points = current.points;\r\n      } while (!current.visited);\r\n      listener.lineEnd();\r\n    }\r\n  }\r\n  function d3_geo_clipLinkCircular(array) {\r\n    if (!(n = array.length)) return;\r\n    var n, i = 0, a = array[0], b;\r\n    while (++i < n) {\r\n      a.next = b = array[i];\r\n      b.prev = a;\r\n      a = b;\r\n    }\r\n    a.next = b = array[0];\r\n    b.prev = a;\r\n  }\r\n  function d3_geo_clipSort(a, b) {\r\n    return ((a = a.point)[0] < 0 ? a[1] - π / 2 - ε : π / 2 - a[1]) - ((b = b.point)[0] < 0 ? b[1] - π / 2 - ε : π / 2 - b[1]);\r\n  }\r\n  function d3_geo_clipSegmentLength1(segment) {\r\n    return segment.length > 1;\r\n  }\r\n  function d3_geo_clipBufferListener() {\r\n    var lines = [], line;\r\n    return {\r\n      lineStart: function() {\r\n        lines.push(line = []);\r\n      },\r\n      point: function(λ, φ) {\r\n        line.push([ λ, φ ]);\r\n      },\r\n      lineEnd: d3_noop,\r\n      buffer: function() {\r\n        var buffer = lines;\r\n        lines = [];\r\n        line = null;\r\n        return buffer;\r\n      }\r\n    };\r\n  }\r\n  function d3_geo_clipAreaRing(ring, invisible) {\r\n    if (!(n = ring.length)) return 0;\r\n    var n, i = 0, area = 0, p = ring[0], λ = p[0], φ = p[1], cosφ = Math.cos(φ), x0 = Math.atan2(invisible * Math.sin(λ) * cosφ, Math.sin(φ)), y0 = 1 - invisible * Math.cos(λ) * cosφ, x1 = x0, x, y;\r\n    while (++i < n) {\r\n      p = ring[i];\r\n      cosφ = Math.cos(φ = p[1]);\r\n      x = Math.atan2(invisible * Math.sin(λ = p[0]) * cosφ, Math.sin(φ));\r\n      y = 1 - invisible * Math.cos(λ) * cosφ;\r\n      if (Math.abs(y0 - 2) < ε && Math.abs(y - 2) < ε) continue;\r\n      if (Math.abs(y) < ε || Math.abs(y0) < ε) {} else if (Math.abs(Math.abs(x - x0) - π) < ε) {\r\n        if (y + y0 > 2) area += 4 * (x - x0);\r\n      } else if (Math.abs(y0 - 2) < ε) area += 4 * (x - x1); else area += ((3 * π + x - x0) % (2 * π) - π) * (y0 + y);\r\n      x1 = x0, x0 = x, y0 = y;\r\n    }\r\n    return area;\r\n  }\r\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate);\r\n  function d3_geo_clipAntimeridianLine(listener) {\r\n    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;\r\n    return {\r\n      lineStart: function() {\r\n        listener.lineStart();\r\n        clean = 1;\r\n      },\r\n      point: function(λ1, φ1) {\r\n        var sλ1 = λ1 > 0 ? π : -π, dλ = Math.abs(λ1 - λ0);\r\n        if (Math.abs(dλ - π) < ε) {\r\n          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? π / 2 : -π / 2);\r\n          listener.point(sλ0, φ0);\r\n          listener.lineEnd();\r\n          listener.lineStart();\r\n          listener.point(sλ1, φ0);\r\n          listener.point(λ1, φ0);\r\n          clean = 0;\r\n        } else if (sλ0 !== sλ1 && dλ >= π) {\r\n          if (Math.abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;\r\n          if (Math.abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;\r\n          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);\r\n          listener.point(sλ0, φ0);\r\n          listener.lineEnd();\r\n          listener.lineStart();\r\n          listener.point(sλ1, φ0);\r\n          clean = 0;\r\n        }\r\n        listener.point(λ0 = λ1, φ0 = φ1);\r\n        sλ0 = sλ1;\r\n      },\r\n      lineEnd: function() {\r\n        listener.lineEnd();\r\n        λ0 = φ0 = NaN;\r\n      },\r\n      clean: function() {\r\n        return 2 - clean;\r\n      }\r\n    };\r\n  }\r\n  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {\r\n    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);\r\n    return Math.abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;\r\n  }\r\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\r\n    var φ;\r\n    if (from == null) {\r\n      φ = direction * π / 2;\r\n      listener.point(-π, φ);\r\n      listener.point(0, φ);\r\n      listener.point(π, φ);\r\n      listener.point(π, 0);\r\n      listener.point(π, -φ);\r\n      listener.point(0, -φ);\r\n      listener.point(-π, -φ);\r\n      listener.point(-π, 0);\r\n      listener.point(-π, φ);\r\n    } else if (Math.abs(from[0] - to[0]) > ε) {\r\n      var s = (from[0] < to[0] ? 1 : -1) * π;\r\n      φ = direction * s / 2;\r\n      listener.point(-s, φ);\r\n      listener.point(0, φ);\r\n      listener.point(s, φ);\r\n    } else {\r\n      listener.point(to[0], to[1]);\r\n    }\r\n  }\r\n  function d3_geo_clipCircle(degrees) {\r\n    var radians = degrees * d3_radians, cr = Math.cos(radians), interpolate = d3_geo_circleInterpolate(radians, 6 * d3_radians);\r\n    return d3_geo_clip(visible, clipLine, interpolate);\r\n    function visible(λ, φ) {\r\n      return Math.cos(λ) * Math.cos(φ) > cr;\r\n    }\r\n    function clipLine(listener) {\r\n      var point0, v0, v00, clean;\r\n      return {\r\n        lineStart: function() {\r\n          v00 = v0 = false;\r\n          clean = 1;\r\n        },\r\n        point: function(λ, φ) {\r\n          var point1 = [ λ, φ ], point2, v = visible(λ, φ);\r\n          if (!point0 && (v00 = v0 = v)) listener.lineStart();\r\n          if (v !== v0) {\r\n            point2 = intersect(point0, point1);\r\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\r\n              point1[0] += ε;\r\n              point1[1] += ε;\r\n              v = visible(point1[0], point1[1]);\r\n            }\r\n          }\r\n          if (v !== v0) {\r\n            clean = 0;\r\n            if (v0 = v) {\r\n              listener.lineStart();\r\n              point2 = intersect(point1, point0);\r\n              listener.point(point2[0], point2[1]);\r\n            } else {\r\n              point2 = intersect(point0, point1);\r\n              listener.point(point2[0], point2[1]);\r\n              listener.lineEnd();\r\n            }\r\n            point0 = point2;\r\n          }\r\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) listener.point(point1[0], point1[1]);\r\n          point0 = point1;\r\n        },\r\n        lineEnd: function() {\r\n          if (v0) listener.lineEnd();\r\n          point0 = null;\r\n        },\r\n        clean: function() {\r\n          return clean | (v00 && v0) << 1;\r\n        }\r\n      };\r\n    }\r\n    function intersect(a, b) {\r\n      var pa = d3_geo_cartesian(a, 0), pb = d3_geo_cartesian(b, 0);\r\n      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\r\n      if (!determinant) return a;\r\n      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);\r\n      d3_geo_cartesianAdd(A, B);\r\n      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t = Math.sqrt(w * w - uu * (d3_geo_cartesianDot(A, A) - 1)), q = d3_geo_cartesianScale(u, (-w - t) / uu);\r\n      d3_geo_cartesianAdd(q, A);\r\n      return d3_geo_spherical(q);\r\n    }\r\n  }\r\n  function d3_geo_compose(a, b) {\r\n    function compose(x, y) {\r\n      return x = a(x, y), b(x[0], x[1]);\r\n    }\r\n    if (a.invert && b.invert) compose.invert = function(x, y) {\r\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\r\n    };\r\n    return compose;\r\n  }\r\n  function d3_geo_equirectangular(λ, φ) {\r\n    return [ λ, φ ];\r\n  }\r\n  (d3.geo.equirectangular = function() {\r\n    return d3_geo_projection(d3_geo_equirectangular).scale(250 / π);\r\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\r\n  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {\r\n    return 1 / cosλcosφ;\r\n  }, Math.atan);\r\n  (d3.geo.gnomonic = function() {\r\n    return d3_geo_projection(d3_geo_gnomonic);\r\n  }).raw = d3_geo_gnomonic;\r\n  d3.geo.graticule = function() {\r\n    var x1, x0, y1, y0, dx = 22.5, dy = dx, x, y, precision = 2.5;\r\n    function graticule() {\r\n      return {\r\n        type: \"MultiLineString\",\r\n        coordinates: lines()\r\n      };\r\n    }\r\n    function lines() {\r\n      return d3.range(Math.ceil(x0 / dx) * dx, x1, dx).map(x).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).map(y));\r\n    }\r\n    graticule.lines = function() {\r\n      return lines().map(function(coordinates) {\r\n        return {\r\n          type: \"LineString\",\r\n          coordinates: coordinates\r\n        };\r\n      });\r\n    };\r\n    graticule.outline = function() {\r\n      return {\r\n        type: \"Polygon\",\r\n        coordinates: [ x(x0).concat(y(y1).slice(1), x(x1).reverse().slice(1), y(y0).reverse().slice(1)) ]\r\n      };\r\n    };\r\n    graticule.extent = function(_) {\r\n      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\r\n      x0 = +_[0][0], x1 = +_[1][0];\r\n      y0 = +_[0][1], y1 = +_[1][1];\r\n      if (x0 > x1) _ = x0, x0 = x1, x1 = _;\r\n      if (y0 > y1) _ = y0, y0 = y1, y1 = _;\r\n      return graticule.precision(precision);\r\n    };\r\n    graticule.step = function(_) {\r\n      if (!arguments.length) return [ dx, dy ];\r\n      dx = +_[0], dy = +_[1];\r\n      return graticule;\r\n    };\r\n    graticule.precision = function(_) {\r\n      if (!arguments.length) return precision;\r\n      precision = +_;\r\n      x = d3_geo_graticuleX(y0, y1, precision);\r\n      y = d3_geo_graticuleY(x0, x1, precision);\r\n      return graticule;\r\n    };\r\n    return graticule.extent([ [ -180 + ε, -90 + ε ], [ 180 - ε, 90 - ε ] ]);\r\n  };\r\n  function d3_geo_graticuleX(y0, y1, dy) {\r\n    var y = d3.range(y0, y1 - ε, dy).concat(y1);\r\n    return function(x) {\r\n      return y.map(function(y) {\r\n        return [ x, y ];\r\n      });\r\n    };\r\n  }\r\n  function d3_geo_graticuleY(x0, x1, dx) {\r\n    var x = d3.range(x0, x1 - ε, dx).concat(x1);\r\n    return function(y) {\r\n      return x.map(function(x) {\r\n        return [ x, y ];\r\n      });\r\n    };\r\n  }\r\n  d3.geo.interpolate = function(source, target) {\r\n    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\r\n  };\r\n  function d3_geo_interpolate(x0, y0, x1, y1) {\r\n    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))), k = 1 / Math.sin(d);\r\n    function interpolate(t) {\r\n      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\r\n      return [ Math.atan2(y, x) / d3_radians, Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_radians ];\r\n    }\r\n    interpolate.distance = d;\r\n    return interpolate;\r\n  }\r\n  d3.geo.greatArc = function() {\r\n    var source = d3_source, source_, target = d3_target, target_, precision = 6 * d3_radians, interpolate;\r\n    function greatArc() {\r\n      var p0 = source_ || source.apply(this, arguments), p1 = target_ || target.apply(this, arguments), i = interpolate || d3.geo.interpolate(p0, p1), t = 0, dt = precision / i.distance, coordinates = [ p0 ];\r\n      while ((t += dt) < 1) coordinates.push(i(t));\r\n      coordinates.push(p1);\r\n      return {\r\n        type: \"LineString\",\r\n        coordinates: coordinates\r\n      };\r\n    }\r\n    greatArc.distance = function() {\r\n      return (interpolate || d3.geo.interpolate(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments))).distance;\r\n    };\r\n    greatArc.source = function(_) {\r\n      if (!arguments.length) return source;\r\n      source = _, source_ = typeof _ === \"function\" ? null : _;\r\n      interpolate = source_ && target_ ? d3.geo.interpolate(source_, target_) : null;\r\n      return greatArc;\r\n    };\r\n    greatArc.target = function(_) {\r\n      if (!arguments.length) return target;\r\n      target = _, target_ = typeof _ === \"function\" ? null : _;\r\n      interpolate = source_ && target_ ? d3.geo.interpolate(source_, target_) : null;\r\n      return greatArc;\r\n    };\r\n    greatArc.precision = function(_) {\r\n      if (!arguments.length) return precision / d3_radians;\r\n      precision = _ * d3_radians;\r\n      return greatArc;\r\n    };\r\n    return greatArc;\r\n  };\r\n  function d3_geo_mercator(λ, φ) {\r\n    return [ λ / (2 * π), Math.max(-.5, Math.min(+.5, Math.log(Math.tan(π / 4 + φ / 2)) / (2 * π))) ];\r\n  }\r\n  d3_geo_mercator.invert = function(x, y) {\r\n    return [ 2 * π * x, 2 * Math.atan(Math.exp(2 * π * y)) - π / 2 ];\r\n  };\r\n  (d3.geo.mercator = function() {\r\n    return d3_geo_projection(d3_geo_mercator).scale(500);\r\n  }).raw = d3_geo_mercator;\r\n  var d3_geo_orthographic = d3_geo_azimuthal(function() {\r\n    return 1;\r\n  }, Math.asin);\r\n  (d3.geo.orthographic = function() {\r\n    return d3_geo_projection(d3_geo_orthographic);\r\n  }).raw = d3_geo_orthographic;\r\n  d3.geo.path = function() {\r\n    var pointRadius = 4.5, projection, context, projectStream, contextStream;\r\n    function path(object) {\r\n      if (object) d3.geo.stream(object, projectStream(contextStream.pointRadius(typeof pointRadius === \"function\" ? +pointRadius.apply(this, arguments) : pointRadius)));\r\n      return contextStream.result();\r\n    }\r\n    path.area = function(object) {\r\n      d3_geo_pathAreaSum = 0;\r\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\r\n      return d3_geo_pathAreaSum;\r\n    };\r\n    path.centroid = function(object) {\r\n      d3_geo_centroidDimension = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\r\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\r\n      return d3_geo_centroidZ ? [ d3_geo_centroidX / d3_geo_centroidZ, d3_geo_centroidY / d3_geo_centroidZ ] : undefined;\r\n    };\r\n    path.bounds = function(object) {\r\n      return d3_geo_bounds(projectStream)(object);\r\n    };\r\n    path.projection = function(_) {\r\n      if (!arguments.length) return projection;\r\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\r\n      return path;\r\n    };\r\n    path.context = function(_) {\r\n      if (!arguments.length) return context;\r\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\r\n      return path;\r\n    };\r\n    path.pointRadius = function(_) {\r\n      if (!arguments.length) return pointRadius;\r\n      pointRadius = typeof _ === \"function\" ? _ : +_;\r\n      return path;\r\n    };\r\n    return path.projection(d3.geo.albersUsa()).context(null);\r\n  };\r\n  function d3_geo_pathCircle(radius) {\r\n    return \"m0,\" + radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + +2 * radius + \"z\";\r\n  }\r\n  function d3_geo_pathProjectStream(project) {\r\n    var resample = d3_geo_resample(function(λ, φ) {\r\n      return project([ λ * d3_degrees, φ * d3_degrees ]);\r\n    });\r\n    return function(stream) {\r\n      stream = resample(stream);\r\n      return {\r\n        point: function(λ, φ) {\r\n          stream.point(λ * d3_radians, φ * d3_radians);\r\n        },\r\n        sphere: function() {\r\n          stream.sphere();\r\n        },\r\n        lineStart: function() {\r\n          stream.lineStart();\r\n        },\r\n        lineEnd: function() {\r\n          stream.lineEnd();\r\n        },\r\n        polygonStart: function() {\r\n          stream.polygonStart();\r\n        },\r\n        polygonEnd: function() {\r\n          stream.polygonEnd();\r\n        }\r\n      };\r\n    };\r\n  }\r\n  function d3_geo_pathBuffer() {\r\n    var pointCircle = d3_geo_pathCircle(4.5), buffer = [];\r\n    var stream = {\r\n      point: point,\r\n      lineStart: function() {\r\n        stream.point = pointLineStart;\r\n      },\r\n      lineEnd: lineEnd,\r\n      polygonStart: function() {\r\n        stream.lineEnd = lineEndPolygon;\r\n      },\r\n      polygonEnd: function() {\r\n        stream.lineEnd = lineEnd;\r\n        stream.point = point;\r\n      },\r\n      pointRadius: function(_) {\r\n        pointCircle = d3_geo_pathCircle(_);\r\n        return stream;\r\n      },\r\n      result: function() {\r\n        if (buffer.length) {\r\n          var result = buffer.join(\"\");\r\n          buffer = [];\r\n          return result;\r\n        }\r\n      }\r\n    };\r\n    function point(x, y) {\r\n      buffer.push(\"M\", x, \",\", y, pointCircle);\r\n    }\r\n    function pointLineStart(x, y) {\r\n      buffer.push(\"M\", x, \",\", y);\r\n      stream.point = pointLine;\r\n    }\r\n    function pointLine(x, y) {\r\n      buffer.push(\"L\", x, \",\", y);\r\n    }\r\n    function lineEnd() {\r\n      stream.point = point;\r\n    }\r\n    function lineEndPolygon() {\r\n      buffer.push(\"Z\");\r\n    }\r\n    return stream;\r\n  }\r\n  function d3_geo_pathContext(context) {\r\n    var pointRadius = 4.5;\r\n    var stream = {\r\n      point: point,\r\n      lineStart: function() {\r\n        stream.point = pointLineStart;\r\n      },\r\n      lineEnd: lineEnd,\r\n      polygonStart: function() {\r\n        stream.lineEnd = lineEndPolygon;\r\n      },\r\n      polygonEnd: function() {\r\n        stream.lineEnd = lineEnd;\r\n        stream.point = point;\r\n      },\r\n      pointRadius: function(_) {\r\n        pointRadius = _;\r\n        return stream;\r\n      },\r\n      result: d3_noop\r\n    };\r\n    function point(x, y) {\r\n      context.moveTo(x, y);\r\n      context.arc(x, y, pointRadius, 0, 2 * π);\r\n    }\r\n    function pointLineStart(x, y) {\r\n      context.moveTo(x, y);\r\n      stream.point = pointLine;\r\n    }\r\n    function pointLine(x, y) {\r\n      context.lineTo(x, y);\r\n    }\r\n    function lineEnd() {\r\n      stream.point = point;\r\n    }\r\n    function lineEndPolygon() {\r\n      context.closePath();\r\n    }\r\n    return stream;\r\n  }\r\n  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {\r\n    point: d3_noop,\r\n    lineStart: d3_noop,\r\n    lineEnd: d3_noop,\r\n    polygonStart: function() {\r\n      d3_geo_pathAreaPolygon = 0;\r\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\r\n    },\r\n    polygonEnd: function() {\r\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\r\n      d3_geo_pathAreaSum += Math.abs(d3_geo_pathAreaPolygon / 2);\r\n    }\r\n  };\r\n  function d3_geo_pathAreaRingStart() {\r\n    var x00, y00, x0, y0;\r\n    d3_geo_pathArea.point = function(x, y) {\r\n      d3_geo_pathArea.point = nextPoint;\r\n      x00 = x0 = x, y00 = y0 = y;\r\n    };\r\n    function nextPoint(x, y) {\r\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\r\n      x0 = x, y0 = y;\r\n    }\r\n    d3_geo_pathArea.lineEnd = function() {\r\n      nextPoint(x00, y00);\r\n    };\r\n  }\r\n  var d3_geo_pathCentroid = {\r\n    point: d3_geo_pathCentroidPoint,\r\n    lineStart: d3_geo_pathCentroidLineStart,\r\n    lineEnd: d3_geo_pathCentroidLineEnd,\r\n    polygonStart: function() {\r\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\r\n    },\r\n    polygonEnd: function() {\r\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\r\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\r\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\r\n    }\r\n  };\r\n  function d3_geo_pathCentroidPoint(x, y) {\r\n    if (d3_geo_centroidDimension) return;\r\n    d3_geo_centroidX += x;\r\n    d3_geo_centroidY += y;\r\n    ++d3_geo_centroidZ;\r\n  }\r\n  function d3_geo_pathCentroidLineStart() {\r\n    var x0, y0;\r\n    if (d3_geo_centroidDimension !== 1) {\r\n      if (d3_geo_centroidDimension < 1) {\r\n        d3_geo_centroidDimension = 1;\r\n        d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\r\n      } else return;\r\n    }\r\n    d3_geo_pathCentroid.point = function(x, y) {\r\n      d3_geo_pathCentroid.point = nextPoint;\r\n      x0 = x, y0 = y;\r\n    };\r\n    function nextPoint(x, y) {\r\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\r\n      d3_geo_centroidX += z * (x0 + x) / 2;\r\n      d3_geo_centroidY += z * (y0 + y) / 2;\r\n      d3_geo_centroidZ += z;\r\n      x0 = x, y0 = y;\r\n    }\r\n  }\r\n  function d3_geo_pathCentroidLineEnd() {\r\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\r\n  }\r\n  function d3_geo_pathCentroidRingStart() {\r\n    var x00, y00, x0, y0;\r\n    if (d3_geo_centroidDimension < 2) {\r\n      d3_geo_centroidDimension = 2;\r\n      d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\r\n    }\r\n    d3_geo_pathCentroid.point = function(x, y) {\r\n      d3_geo_pathCentroid.point = nextPoint;\r\n      x00 = x0 = x, y00 = y0 = y;\r\n    };\r\n    function nextPoint(x, y) {\r\n      var z = y0 * x - x0 * y;\r\n      d3_geo_centroidX += z * (x0 + x);\r\n      d3_geo_centroidY += z * (y0 + y);\r\n      d3_geo_centroidZ += z * 3;\r\n      x0 = x, y0 = y;\r\n    }\r\n    d3_geo_pathCentroid.lineEnd = function() {\r\n      nextPoint(x00, y00);\r\n    };\r\n  }\r\n  d3.geo.area = function(object) {\r\n    d3_geo_areaSum = 0;\r\n    d3.geo.stream(object, d3_geo_area);\r\n    return d3_geo_areaSum;\r\n  };\r\n  var d3_geo_areaSum, d3_geo_areaRingU, d3_geo_areaRingV;\r\n  var d3_geo_area = {\r\n    sphere: function() {\r\n      d3_geo_areaSum += 4 * π;\r\n    },\r\n    point: d3_noop,\r\n    lineStart: d3_noop,\r\n    lineEnd: d3_noop,\r\n    polygonStart: function() {\r\n      d3_geo_areaRingU = 1, d3_geo_areaRingV = 0;\r\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\r\n    },\r\n    polygonEnd: function() {\r\n      var area = 2 * Math.atan2(d3_geo_areaRingV, d3_geo_areaRingU);\r\n      d3_geo_areaSum += area < 0 ? 4 * π + area : area;\r\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\r\n    }\r\n  };\r\n  function d3_geo_areaRingStart() {\r\n    var λ00, φ00, λ0, cosφ0, sinφ0;\r\n    d3_geo_area.point = function(λ, φ) {\r\n      d3_geo_area.point = nextPoint;\r\n      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), \r\n      sinφ0 = Math.sin(φ);\r\n    };\r\n    function nextPoint(λ, φ) {\r\n      λ *= d3_radians;\r\n      φ = φ * d3_radians / 2 + π / 4;\r\n      var dλ = λ - λ0, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u0 = d3_geo_areaRingU, v0 = d3_geo_areaRingV, u = cosφ0 * cosφ + k * Math.cos(dλ), v = k * Math.sin(dλ);\r\n      d3_geo_areaRingU = u0 * u - v0 * v;\r\n      d3_geo_areaRingV = v0 * u + u0 * v;\r\n      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;\r\n    }\r\n    d3_geo_area.lineEnd = function() {\r\n      nextPoint(λ00, φ00);\r\n    };\r\n  }\r\n  d3.geo.projection = d3_geo_projection;\r\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\r\n  function d3_geo_projection(project) {\r\n    return d3_geo_projectionMutator(function() {\r\n      return project;\r\n    })();\r\n  }\r\n  function d3_geo_projectionMutator(projectAt) {\r\n    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {\r\n      x = project(x, y);\r\n      return [ x[0] * k + δx, δy - x[1] * k ];\r\n    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, clip = d3_geo_clipAntimeridian, clipAngle = null;\r\n    function projection(point) {\r\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\r\n      return [ point[0] * k + δx, δy - point[1] * k ];\r\n    }\r\n    function invert(point) {\r\n      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);\r\n      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];\r\n    }\r\n    projection.stream = function(stream) {\r\n      return d3_geo_projectionRadiansRotate(rotate, clip(projectResample(stream)));\r\n    };\r\n    projection.clipAngle = function(_) {\r\n      if (!arguments.length) return clipAngle;\r\n      clip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle(clipAngle = +_);\r\n      return projection;\r\n    };\r\n    projection.scale = function(_) {\r\n      if (!arguments.length) return k;\r\n      k = +_;\r\n      return reset();\r\n    };\r\n    projection.translate = function(_) {\r\n      if (!arguments.length) return [ x, y ];\r\n      x = +_[0];\r\n      y = +_[1];\r\n      return reset();\r\n    };\r\n    projection.center = function(_) {\r\n      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];\r\n      λ = _[0] % 360 * d3_radians;\r\n      φ = _[1] % 360 * d3_radians;\r\n      return reset();\r\n    };\r\n    projection.rotate = function(_) {\r\n      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];\r\n      δλ = _[0] % 360 * d3_radians;\r\n      δφ = _[1] % 360 * d3_radians;\r\n      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;\r\n      return reset();\r\n    };\r\n    d3.rebind(projection, projectResample, \"precision\");\r\n    function reset() {\r\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);\r\n      var center = project(λ, φ);\r\n      δx = x - center[0] * k;\r\n      δy = y + center[1] * k;\r\n      return projection;\r\n    }\r\n    return function() {\r\n      project = projectAt.apply(this, arguments);\r\n      projection.invert = project.invert && invert;\r\n      return reset();\r\n    };\r\n  }\r\n  function d3_geo_projectionRadiansRotate(rotate, stream) {\r\n    return {\r\n      point: function(x, y) {\r\n        y = rotate(x * d3_radians, y * d3_radians), x = y[0];\r\n        stream.point(x > π ? x - 2 * π : x < -π ? x + 2 * π : x, y[1]);\r\n      },\r\n      sphere: function() {\r\n        stream.sphere();\r\n      },\r\n      lineStart: function() {\r\n        stream.lineStart();\r\n      },\r\n      lineEnd: function() {\r\n        stream.lineEnd();\r\n      },\r\n      polygonStart: function() {\r\n        stream.polygonStart();\r\n      },\r\n      polygonEnd: function() {\r\n        stream.polygonEnd();\r\n      }\r\n    };\r\n  }\r\n  function d3_geo_rotation(δλ, δφ, δγ) {\r\n    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_equirectangular;\r\n  }\r\n  function d3_geo_forwardRotationλ(δλ) {\r\n    return function(λ, φ) {\r\n      return λ += δλ, [ λ > π ? λ - 2 * π : λ < -π ? λ + 2 * π : λ, φ ];\r\n    };\r\n  }\r\n  function d3_geo_rotationλ(δλ) {\r\n    var rotation = d3_geo_forwardRotationλ(δλ);\r\n    rotation.invert = d3_geo_forwardRotationλ(-δλ);\r\n    return rotation;\r\n  }\r\n  function d3_geo_rotationφγ(δφ, δγ) {\r\n    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);\r\n    function rotation(λ, φ) {\r\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;\r\n      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδγ + y * sinδγ))) ];\r\n    }\r\n    rotation.invert = function(λ, φ) {\r\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;\r\n      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδφ - x * sinδφ))) ];\r\n    };\r\n    return rotation;\r\n  }\r\n  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {\r\n    return 1 / (1 + cosλcosφ);\r\n  }, function(ρ) {\r\n    return 2 * Math.atan(ρ);\r\n  });\r\n  (d3.geo.stereographic = function() {\r\n    return d3_geo_projection(d3_geo_stereographic);\r\n  }).raw = d3_geo_stereographic;\r\n  function d3_geo_azimuthal(scale, angle) {\r\n    function azimuthal(λ, φ) {\r\n      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);\r\n      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];\r\n    }\r\n    azimuthal.invert = function(x, y) {\r\n      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);\r\n      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];\r\n    };\r\n    return azimuthal;\r\n  }\r\n  d3.geom = {};\r\n  d3.geom.hull = function(vertices) {\r\n    if (vertices.length < 3) return [];\r\n    var len = vertices.length, plen = len - 1, points = [], stack = [], i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;\r\n    for (i = 1; i < len; ++i) {\r\n      if (vertices[i][1] < vertices[h][1]) {\r\n        h = i;\r\n      } else if (vertices[i][1] == vertices[h][1]) {\r\n        h = vertices[i][0] < vertices[h][0] ? i : h;\r\n      }\r\n    }\r\n    for (i = 0; i < len; ++i) {\r\n      if (i === h) continue;\r\n      y1 = vertices[i][1] - vertices[h][1];\r\n      x1 = vertices[i][0] - vertices[h][0];\r\n      points.push({\r\n        angle: Math.atan2(y1, x1),\r\n        index: i\r\n      });\r\n    }\r\n    points.sort(function(a, b) {\r\n      return a.angle - b.angle;\r\n    });\r\n    a = points[0].angle;\r\n    v = points[0].index;\r\n    u = 0;\r\n    for (i = 1; i < plen; ++i) {\r\n      j = points[i].index;\r\n      if (a == points[i].angle) {\r\n        x1 = vertices[v][0] - vertices[h][0];\r\n        y1 = vertices[v][1] - vertices[h][1];\r\n        x2 = vertices[j][0] - vertices[h][0];\r\n        y2 = vertices[j][1] - vertices[h][1];\r\n        if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {\r\n          points[i].index = -1;\r\n        } else {\r\n          points[u].index = -1;\r\n          a = points[i].angle;\r\n          u = i;\r\n          v = j;\r\n        }\r\n      } else {\r\n        a = points[i].angle;\r\n        u = i;\r\n        v = j;\r\n      }\r\n    }\r\n    stack.push(h);\r\n    for (i = 0, j = 0; i < 2; ++j) {\r\n      if (points[j].index !== -1) {\r\n        stack.push(points[j].index);\r\n        i++;\r\n      }\r\n    }\r\n    sp = stack.length;\r\n    for (;j < plen; ++j) {\r\n      if (points[j].index === -1) continue;\r\n      while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {\r\n        --sp;\r\n      }\r\n      stack[sp++] = points[j].index;\r\n    }\r\n    var poly = [];\r\n    for (i = 0; i < sp; ++i) {\r\n      poly.push(vertices[stack[i]]);\r\n    }\r\n    return poly;\r\n  };\r\n  function d3_geom_hullCCW(i1, i2, i3, v) {\r\n    var t, a, b, c, d, e, f;\r\n    t = v[i1];\r\n    a = t[0];\r\n    b = t[1];\r\n    t = v[i2];\r\n    c = t[0];\r\n    d = t[1];\r\n    t = v[i3];\r\n    e = t[0];\r\n    f = t[1];\r\n    return (f - b) * (c - a) - (d - b) * (e - a) > 0;\r\n  }\r\n  d3.geom.polygon = function(coordinates) {\r\n    coordinates.area = function() {\r\n      var i = 0, n = coordinates.length, area = coordinates[n - 1][1] * coordinates[0][0] - coordinates[n - 1][0] * coordinates[0][1];\r\n      while (++i < n) {\r\n        area += coordinates[i - 1][1] * coordinates[i][0] - coordinates[i - 1][0] * coordinates[i][1];\r\n      }\r\n      return area * .5;\r\n    };\r\n    coordinates.centroid = function(k) {\r\n      var i = -1, n = coordinates.length, x = 0, y = 0, a, b = coordinates[n - 1], c;\r\n      if (!arguments.length) k = -1 / (6 * coordinates.area());\r\n      while (++i < n) {\r\n        a = b;\r\n        b = coordinates[i];\r\n        c = a[0] * b[1] - b[0] * a[1];\r\n        x += (a[0] + b[0]) * c;\r\n        y += (a[1] + b[1]) * c;\r\n      }\r\n      return [ x * k, y * k ];\r\n    };\r\n    coordinates.clip = function(subject) {\r\n      var input, i = -1, n = coordinates.length, j, m, a = coordinates[n - 1], b, c, d;\r\n      while (++i < n) {\r\n        input = subject.slice();\r\n        subject.length = 0;\r\n        b = coordinates[i];\r\n        c = input[(m = input.length) - 1];\r\n        j = -1;\r\n        while (++j < m) {\r\n          d = input[j];\r\n          if (d3_geom_polygonInside(d, a, b)) {\r\n            if (!d3_geom_polygonInside(c, a, b)) {\r\n              subject.push(d3_geom_polygonIntersect(c, d, a, b));\r\n            }\r\n            subject.push(d);\r\n          } else if (d3_geom_polygonInside(c, a, b)) {\r\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\r\n          }\r\n          c = d;\r\n        }\r\n        a = b;\r\n      }\r\n      return subject;\r\n    };\r\n    return coordinates;\r\n  };\r\n  function d3_geom_polygonInside(p, a, b) {\r\n    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\r\n  }\r\n  function d3_geom_polygonIntersect(c, d, a, b) {\r\n    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\r\n    return [ x1 + ua * x21, y1 + ua * y21 ];\r\n  }\r\n  d3.geom.voronoi = function(vertices) {\r\n    var polygons = vertices.map(function() {\r\n      return [];\r\n    }), Z = 1e6;\r\n    d3_voronoi_tessellate(vertices, function(e) {\r\n      var s1, s2, x1, x2, y1, y2;\r\n      if (e.a === 1 && e.b >= 0) {\r\n        s1 = e.ep.r;\r\n        s2 = e.ep.l;\r\n      } else {\r\n        s1 = e.ep.l;\r\n        s2 = e.ep.r;\r\n      }\r\n      if (e.a === 1) {\r\n        y1 = s1 ? s1.y : -Z;\r\n        x1 = e.c - e.b * y1;\r\n        y2 = s2 ? s2.y : Z;\r\n        x2 = e.c - e.b * y2;\r\n      } else {\r\n        x1 = s1 ? s1.x : -Z;\r\n        y1 = e.c - e.a * x1;\r\n        x2 = s2 ? s2.x : Z;\r\n        y2 = e.c - e.a * x2;\r\n      }\r\n      var v1 = [ x1, y1 ], v2 = [ x2, y2 ];\r\n      polygons[e.region.l.index].push(v1, v2);\r\n      polygons[e.region.r.index].push(v1, v2);\r\n    });\r\n    polygons = polygons.map(function(polygon, i) {\r\n      var cx = vertices[i][0], cy = vertices[i][1], angle = polygon.map(function(v) {\r\n        return Math.atan2(v[0] - cx, v[1] - cy);\r\n      }), order = d3.range(polygon.length).sort(function(a, b) {\r\n        return angle[a] - angle[b];\r\n      });\r\n      return order.filter(function(d, i) {\r\n        return !i || angle[d] - angle[order[i - 1]] > ε;\r\n      }).map(function(d) {\r\n        return polygon[d];\r\n      });\r\n    });\r\n    polygons.forEach(function(polygon, i) {\r\n      var n = polygon.length;\r\n      if (!n) return polygon.push([ -Z, -Z ], [ -Z, Z ], [ Z, Z ], [ Z, -Z ]);\r\n      if (n > 2) return;\r\n      var p0 = vertices[i], p1 = polygon[0], p2 = polygon[1], x0 = p0[0], y0 = p0[1], x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], dx = Math.abs(x2 - x1), dy = y2 - y1;\r\n      if (Math.abs(dy) < ε) {\r\n        var y = y0 < y1 ? -Z : Z;\r\n        polygon.push([ -Z, y ], [ Z, y ]);\r\n      } else if (dx < ε) {\r\n        var x = x0 < x1 ? -Z : Z;\r\n        polygon.push([ x, -Z ], [ x, Z ]);\r\n      } else {\r\n        var y = (x2 - x1) * (y1 - y0) < (x1 - x0) * (y2 - y1) ? Z : -Z, z = Math.abs(dy) - dx;\r\n        if (Math.abs(z) < ε) {\r\n          polygon.push([ dy < 0 ? y : -y, y ]);\r\n        } else {\r\n          if (z > 0) y *= -1;\r\n          polygon.push([ -Z, y ], [ Z, y ]);\r\n        }\r\n      }\r\n    });\r\n    return polygons;\r\n  };\r\n  var d3_voronoi_opposite = {\r\n    l: \"r\",\r\n    r: \"l\"\r\n  };\r\n  function d3_voronoi_tessellate(vertices, callback) {\r\n    var Sites = {\r\n      list: vertices.map(function(v, i) {\r\n        return {\r\n          index: i,\r\n          x: v[0],\r\n          y: v[1]\r\n        };\r\n      }).sort(function(a, b) {\r\n        return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0;\r\n      }),\r\n      bottomSite: null\r\n    };\r\n    var EdgeList = {\r\n      list: [],\r\n      leftEnd: null,\r\n      rightEnd: null,\r\n      init: function() {\r\n        EdgeList.leftEnd = EdgeList.createHalfEdge(null, \"l\");\r\n        EdgeList.rightEnd = EdgeList.createHalfEdge(null, \"l\");\r\n        EdgeList.leftEnd.r = EdgeList.rightEnd;\r\n        EdgeList.rightEnd.l = EdgeList.leftEnd;\r\n        EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);\r\n      },\r\n      createHalfEdge: function(edge, side) {\r\n        return {\r\n          edge: edge,\r\n          side: side,\r\n          vertex: null,\r\n          l: null,\r\n          r: null\r\n        };\r\n      },\r\n      insert: function(lb, he) {\r\n        he.l = lb;\r\n        he.r = lb.r;\r\n        lb.r.l = he;\r\n        lb.r = he;\r\n      },\r\n      leftBound: function(p) {\r\n        var he = EdgeList.leftEnd;\r\n        do {\r\n          he = he.r;\r\n        } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));\r\n        he = he.l;\r\n        return he;\r\n      },\r\n      del: function(he) {\r\n        he.l.r = he.r;\r\n        he.r.l = he.l;\r\n        he.edge = null;\r\n      },\r\n      right: function(he) {\r\n        return he.r;\r\n      },\r\n      left: function(he) {\r\n        return he.l;\r\n      },\r\n      leftRegion: function(he) {\r\n        return he.edge == null ? Sites.bottomSite : he.edge.region[he.side];\r\n      },\r\n      rightRegion: function(he) {\r\n        return he.edge == null ? Sites.bottomSite : he.edge.region[d3_voronoi_opposite[he.side]];\r\n      }\r\n    };\r\n    var Geom = {\r\n      bisect: function(s1, s2) {\r\n        var newEdge = {\r\n          region: {\r\n            l: s1,\r\n            r: s2\r\n          },\r\n          ep: {\r\n            l: null,\r\n            r: null\r\n          }\r\n        };\r\n        var dx = s2.x - s1.x, dy = s2.y - s1.y, adx = dx > 0 ? dx : -dx, ady = dy > 0 ? dy : -dy;\r\n        newEdge.c = s1.x * dx + s1.y * dy + (dx * dx + dy * dy) * .5;\r\n        if (adx > ady) {\r\n          newEdge.a = 1;\r\n          newEdge.b = dy / dx;\r\n          newEdge.c /= dx;\r\n        } else {\r\n          newEdge.b = 1;\r\n          newEdge.a = dx / dy;\r\n          newEdge.c /= dy;\r\n        }\r\n        return newEdge;\r\n      },\r\n      intersect: function(el1, el2) {\r\n        var e1 = el1.edge, e2 = el2.edge;\r\n        if (!e1 || !e2 || e1.region.r == e2.region.r) {\r\n          return null;\r\n        }\r\n        var d = e1.a * e2.b - e1.b * e2.a;\r\n        if (Math.abs(d) < 1e-10) {\r\n          return null;\r\n        }\r\n        var xint = (e1.c * e2.b - e2.c * e1.b) / d, yint = (e2.c * e1.a - e1.c * e2.a) / d, e1r = e1.region.r, e2r = e2.region.r, el, e;\r\n        if (e1r.y < e2r.y || e1r.y == e2r.y && e1r.x < e2r.x) {\r\n          el = el1;\r\n          e = e1;\r\n        } else {\r\n          el = el2;\r\n          e = e2;\r\n        }\r\n        var rightOfSite = xint >= e.region.r.x;\r\n        if (rightOfSite && el.side === \"l\" || !rightOfSite && el.side === \"r\") {\r\n          return null;\r\n        }\r\n        return {\r\n          x: xint,\r\n          y: yint\r\n        };\r\n      },\r\n      rightOf: function(he, p) {\r\n        var e = he.edge, topsite = e.region.r, rightOfSite = p.x > topsite.x;\r\n        if (rightOfSite && he.side === \"l\") {\r\n          return 1;\r\n        }\r\n        if (!rightOfSite && he.side === \"r\") {\r\n          return 0;\r\n        }\r\n        if (e.a === 1) {\r\n          var dyp = p.y - topsite.y, dxp = p.x - topsite.x, fast = 0, above = 0;\r\n          if (!rightOfSite && e.b < 0 || rightOfSite && e.b >= 0) {\r\n            above = fast = dyp >= e.b * dxp;\r\n          } else {\r\n            above = p.x + p.y * e.b > e.c;\r\n            if (e.b < 0) {\r\n              above = !above;\r\n            }\r\n            if (!above) {\r\n              fast = 1;\r\n            }\r\n          }\r\n          if (!fast) {\r\n            var dxs = topsite.x - e.region.l.x;\r\n            above = e.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b);\r\n            if (e.b < 0) {\r\n              above = !above;\r\n            }\r\n          }\r\n        } else {\r\n          var yl = e.c - e.a * p.x, t1 = p.y - yl, t2 = p.x - topsite.x, t3 = yl - topsite.y;\r\n          above = t1 * t1 > t2 * t2 + t3 * t3;\r\n        }\r\n        return he.side === \"l\" ? above : !above;\r\n      },\r\n      endPoint: function(edge, side, site) {\r\n        edge.ep[side] = site;\r\n        if (!edge.ep[d3_voronoi_opposite[side]]) return;\r\n        callback(edge);\r\n      },\r\n      distance: function(s, t) {\r\n        var dx = s.x - t.x, dy = s.y - t.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n      }\r\n    };\r\n    var EventQueue = {\r\n      list: [],\r\n      insert: function(he, site, offset) {\r\n        he.vertex = site;\r\n        he.ystar = site.y + offset;\r\n        for (var i = 0, list = EventQueue.list, l = list.length; i < l; i++) {\r\n          var next = list[i];\r\n          if (he.ystar > next.ystar || he.ystar == next.ystar && site.x > next.vertex.x) {\r\n            continue;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n        list.splice(i, 0, he);\r\n      },\r\n      del: function(he) {\r\n        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l && ls[i] != he; ++i) {}\r\n        ls.splice(i, 1);\r\n      },\r\n      empty: function() {\r\n        return EventQueue.list.length === 0;\r\n      },\r\n      nextEvent: function(he) {\r\n        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l; ++i) {\r\n          if (ls[i] == he) return ls[i + 1];\r\n        }\r\n        return null;\r\n      },\r\n      min: function() {\r\n        var elem = EventQueue.list[0];\r\n        return {\r\n          x: elem.vertex.x,\r\n          y: elem.ystar\r\n        };\r\n      },\r\n      extractMin: function() {\r\n        return EventQueue.list.shift();\r\n      }\r\n    };\r\n    EdgeList.init();\r\n    Sites.bottomSite = Sites.list.shift();\r\n    var newSite = Sites.list.shift(), newIntStar;\r\n    var lbnd, rbnd, llbnd, rrbnd, bisector;\r\n    var bot, top, temp, p, v;\r\n    var e, pm;\r\n    while (true) {\r\n      if (!EventQueue.empty()) {\r\n        newIntStar = EventQueue.min();\r\n      }\r\n      if (newSite && (EventQueue.empty() || newSite.y < newIntStar.y || newSite.y == newIntStar.y && newSite.x < newIntStar.x)) {\r\n        lbnd = EdgeList.leftBound(newSite);\r\n        rbnd = EdgeList.right(lbnd);\r\n        bot = EdgeList.rightRegion(lbnd);\r\n        e = Geom.bisect(bot, newSite);\r\n        bisector = EdgeList.createHalfEdge(e, \"l\");\r\n        EdgeList.insert(lbnd, bisector);\r\n        p = Geom.intersect(lbnd, bisector);\r\n        if (p) {\r\n          EventQueue.del(lbnd);\r\n          EventQueue.insert(lbnd, p, Geom.distance(p, newSite));\r\n        }\r\n        lbnd = bisector;\r\n        bisector = EdgeList.createHalfEdge(e, \"r\");\r\n        EdgeList.insert(lbnd, bisector);\r\n        p = Geom.intersect(bisector, rbnd);\r\n        if (p) {\r\n          EventQueue.insert(bisector, p, Geom.distance(p, newSite));\r\n        }\r\n        newSite = Sites.list.shift();\r\n      } else if (!EventQueue.empty()) {\r\n        lbnd = EventQueue.extractMin();\r\n        llbnd = EdgeList.left(lbnd);\r\n        rbnd = EdgeList.right(lbnd);\r\n        rrbnd = EdgeList.right(rbnd);\r\n        bot = EdgeList.leftRegion(lbnd);\r\n        top = EdgeList.rightRegion(rbnd);\r\n        v = lbnd.vertex;\r\n        Geom.endPoint(lbnd.edge, lbnd.side, v);\r\n        Geom.endPoint(rbnd.edge, rbnd.side, v);\r\n        EdgeList.del(lbnd);\r\n        EventQueue.del(rbnd);\r\n        EdgeList.del(rbnd);\r\n        pm = \"l\";\r\n        if (bot.y > top.y) {\r\n          temp = bot;\r\n          bot = top;\r\n          top = temp;\r\n          pm = \"r\";\r\n        }\r\n        e = Geom.bisect(bot, top);\r\n        bisector = EdgeList.createHalfEdge(e, pm);\r\n        EdgeList.insert(llbnd, bisector);\r\n        Geom.endPoint(e, d3_voronoi_opposite[pm], v);\r\n        p = Geom.intersect(llbnd, bisector);\r\n        if (p) {\r\n          EventQueue.del(llbnd);\r\n          EventQueue.insert(llbnd, p, Geom.distance(p, bot));\r\n        }\r\n        p = Geom.intersect(bisector, rrbnd);\r\n        if (p) {\r\n          EventQueue.insert(bisector, p, Geom.distance(p, bot));\r\n        }\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    for (lbnd = EdgeList.right(EdgeList.leftEnd); lbnd != EdgeList.rightEnd; lbnd = EdgeList.right(lbnd)) {\r\n      callback(lbnd.edge);\r\n    }\r\n  }\r\n  d3.geom.delaunay = function(vertices) {\r\n    var edges = vertices.map(function() {\r\n      return [];\r\n    }), triangles = [];\r\n    d3_voronoi_tessellate(vertices, function(e) {\r\n      edges[e.region.l.index].push(vertices[e.region.r.index]);\r\n    });\r\n    edges.forEach(function(edge, i) {\r\n      var v = vertices[i], cx = v[0], cy = v[1];\r\n      edge.forEach(function(v) {\r\n        v.angle = Math.atan2(v[0] - cx, v[1] - cy);\r\n      });\r\n      edge.sort(function(a, b) {\r\n        return a.angle - b.angle;\r\n      });\r\n      for (var j = 0, m = edge.length - 1; j < m; j++) {\r\n        triangles.push([ v, edge[j], edge[j + 1] ]);\r\n      }\r\n    });\r\n    return triangles;\r\n  };\r\n  d3.geom.quadtree = function(points, x1, y1, x2, y2) {\r\n    var p, i = -1, n = points.length;\r\n    if (arguments.length < 5) {\r\n      if (arguments.length === 3) {\r\n        y2 = y1;\r\n        x2 = x1;\r\n        y1 = x1 = 0;\r\n      } else {\r\n        x1 = y1 = Infinity;\r\n        x2 = y2 = -Infinity;\r\n        while (++i < n) {\r\n          p = points[i];\r\n          if (p.x < x1) x1 = p.x;\r\n          if (p.y < y1) y1 = p.y;\r\n          if (p.x > x2) x2 = p.x;\r\n          if (p.y > y2) y2 = p.y;\r\n        }\r\n      }\r\n    }\r\n    var dx = x2 - x1, dy = y2 - y1;\r\n    if (dx > dy) y2 = y1 + dx; else x2 = x1 + dy;\r\n    function insert(n, p, x1, y1, x2, y2) {\r\n      if (isNaN(p.x) || isNaN(p.y)) return;\r\n      if (n.leaf) {\r\n        var v = n.point;\r\n        if (v) {\r\n          if (Math.abs(v.x - p.x) + Math.abs(v.y - p.y) < .01) {\r\n            insertChild(n, p, x1, y1, x2, y2);\r\n          } else {\r\n            n.point = null;\r\n            insertChild(n, v, x1, y1, x2, y2);\r\n            insertChild(n, p, x1, y1, x2, y2);\r\n          }\r\n        } else {\r\n          n.point = p;\r\n        }\r\n      } else {\r\n        insertChild(n, p, x1, y1, x2, y2);\r\n      }\r\n    }\r\n    function insertChild(n, p, x1, y1, x2, y2) {\r\n      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = p.x >= sx, bottom = p.y >= sy, i = (bottom << 1) + right;\r\n      n.leaf = false;\r\n      n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\r\n      if (right) x1 = sx; else x2 = sx;\r\n      if (bottom) y1 = sy; else y2 = sy;\r\n      insert(n, p, x1, y1, x2, y2);\r\n    }\r\n    var root = d3_geom_quadtreeNode();\r\n    root.add = function(p) {\r\n      insert(root, p, x1, y1, x2, y2);\r\n    };\r\n    root.visit = function(f) {\r\n      d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);\r\n    };\r\n    points.forEach(root.add);\r\n    return root;\r\n  };\r\n  function d3_geom_quadtreeNode() {\r\n    return {\r\n      leaf: true,\r\n      nodes: [],\r\n      point: null\r\n    };\r\n  }\r\n  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\r\n    if (!f(node, x1, y1, x2, y2)) {\r\n      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;\r\n      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\r\n      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\r\n      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\r\n      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\r\n    }\r\n  }\r\n  d3.time = {};\r\n  var d3_time = Date, d3_time_daySymbols = [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ];\r\n  function d3_time_utc() {\r\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\r\n  }\r\n  d3_time_utc.prototype = {\r\n    getDate: function() {\r\n      return this._.getUTCDate();\r\n    },\r\n    getDay: function() {\r\n      return this._.getUTCDay();\r\n    },\r\n    getFullYear: function() {\r\n      return this._.getUTCFullYear();\r\n    },\r\n    getHours: function() {\r\n      return this._.getUTCHours();\r\n    },\r\n    getMilliseconds: function() {\r\n      return this._.getUTCMilliseconds();\r\n    },\r\n    getMinutes: function() {\r\n      return this._.getUTCMinutes();\r\n    },\r\n    getMonth: function() {\r\n      return this._.getUTCMonth();\r\n    },\r\n    getSeconds: function() {\r\n      return this._.getUTCSeconds();\r\n    },\r\n    getTime: function() {\r\n      return this._.getTime();\r\n    },\r\n    getTimezoneOffset: function() {\r\n      return 0;\r\n    },\r\n    valueOf: function() {\r\n      return this._.valueOf();\r\n    },\r\n    setDate: function() {\r\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\r\n    },\r\n    setDay: function() {\r\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\r\n    },\r\n    setFullYear: function() {\r\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\r\n    },\r\n    setHours: function() {\r\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\r\n    },\r\n    setMilliseconds: function() {\r\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\r\n    },\r\n    setMinutes: function() {\r\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\r\n    },\r\n    setMonth: function() {\r\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\r\n    },\r\n    setSeconds: function() {\r\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\r\n    },\r\n    setTime: function() {\r\n      d3_time_prototype.setTime.apply(this._, arguments);\r\n    }\r\n  };\r\n  var d3_time_prototype = Date.prototype;\r\n  var d3_time_formatDateTime = \"%a %b %e %X %Y\", d3_time_formatDate = \"%m/%d/%Y\", d3_time_formatTime = \"%H:%M:%S\";\r\n  var d3_time_days = [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ], d3_time_dayAbbreviations = [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ], d3_time_months = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ], d3_time_monthAbbreviations = [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ];\r\n  d3.time.format = function(template) {\r\n    var n = template.length;\r\n    function format(date) {\r\n      var string = [], i = -1, j = 0, c, p, f;\r\n      while (++i < n) {\r\n        if (template.charCodeAt(i) === 37) {\r\n          string.push(template.substring(j, i));\r\n          if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\r\n          if (f = d3_time_formats[c]) c = f(date, p == null ? c === \"e\" ? \" \" : \"0\" : p);\r\n          string.push(c);\r\n          j = i + 1;\r\n        }\r\n      }\r\n      string.push(template.substring(j, i));\r\n      return string.join(\"\");\r\n    }\r\n    format.parse = function(string) {\r\n      var d = {\r\n        y: 1900,\r\n        m: 0,\r\n        d: 1,\r\n        H: 0,\r\n        M: 0,\r\n        S: 0,\r\n        L: 0\r\n      }, i = d3_time_parse(d, template, string, 0);\r\n      if (i != string.length) return null;\r\n      if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\r\n      var date = new d3_time();\r\n      date.setFullYear(d.y, d.m, d.d);\r\n      date.setHours(d.H, d.M, d.S, d.L);\r\n      return date;\r\n    };\r\n    format.toString = function() {\r\n      return template;\r\n    };\r\n    return format;\r\n  };\r\n  function d3_time_parse(date, template, string, j) {\r\n    var c, p, i = 0, n = template.length, m = string.length;\r\n    while (i < n) {\r\n      if (j >= m) return -1;\r\n      c = template.charCodeAt(i++);\r\n      if (c === 37) {\r\n        p = d3_time_parsers[template.charAt(i++)];\r\n        if (!p || (j = p(date, string, j)) < 0) return -1;\r\n      } else if (c != string.charCodeAt(j++)) {\r\n        return -1;\r\n      }\r\n    }\r\n    return j;\r\n  }\r\n  function d3_time_formatRe(names) {\r\n    return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\r\n  }\r\n  function d3_time_formatLookup(names) {\r\n    var map = new d3_Map(), i = -1, n = names.length;\r\n    while (++i < n) map.set(names[i].toLowerCase(), i);\r\n    return map;\r\n  }\r\n  function d3_time_formatPad(value, fill, width) {\r\n    value += \"\";\r\n    var length = value.length;\r\n    return length < width ? new Array(width - length + 1).join(fill) + value : value;\r\n  }\r\n  var d3_time_dayRe = d3_time_formatRe(d3_time_days), d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations), d3_time_monthRe = d3_time_formatRe(d3_time_months), d3_time_monthLookup = d3_time_formatLookup(d3_time_months), d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations), d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations);\r\n  var d3_time_formatPads = {\r\n    \"-\": \"\",\r\n    _: \" \",\r\n    \"0\": \"0\"\r\n  };\r\n  var d3_time_formats = {\r\n    a: function(d) {\r\n      return d3_time_dayAbbreviations[d.getDay()];\r\n    },\r\n    A: function(d) {\r\n      return d3_time_days[d.getDay()];\r\n    },\r\n    b: function(d) {\r\n      return d3_time_monthAbbreviations[d.getMonth()];\r\n    },\r\n    B: function(d) {\r\n      return d3_time_months[d.getMonth()];\r\n    },\r\n    c: d3.time.format(d3_time_formatDateTime),\r\n    d: function(d, p) {\r\n      return d3_time_formatPad(d.getDate(), p, 2);\r\n    },\r\n    e: function(d, p) {\r\n      return d3_time_formatPad(d.getDate(), p, 2);\r\n    },\r\n    H: function(d, p) {\r\n      return d3_time_formatPad(d.getHours(), p, 2);\r\n    },\r\n    I: function(d, p) {\r\n      return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\r\n    },\r\n    j: function(d, p) {\r\n      return d3_time_formatPad(1 + d3.time.dayOfYear(d), p, 3);\r\n    },\r\n    L: function(d, p) {\r\n      return d3_time_formatPad(d.getMilliseconds(), p, 3);\r\n    },\r\n    m: function(d, p) {\r\n      return d3_time_formatPad(d.getMonth() + 1, p, 2);\r\n    },\r\n    M: function(d, p) {\r\n      return d3_time_formatPad(d.getMinutes(), p, 2);\r\n    },\r\n    p: function(d) {\r\n      return d.getHours() >= 12 ? \"PM\" : \"AM\";\r\n    },\r\n    S: function(d, p) {\r\n      return d3_time_formatPad(d.getSeconds(), p, 2);\r\n    },\r\n    U: function(d, p) {\r\n      return d3_time_formatPad(d3.time.sundayOfYear(d), p, 2);\r\n    },\r\n    w: function(d) {\r\n      return d.getDay();\r\n    },\r\n    W: function(d, p) {\r\n      return d3_time_formatPad(d3.time.mondayOfYear(d), p, 2);\r\n    },\r\n    x: d3.time.format(d3_time_formatDate),\r\n    X: d3.time.format(d3_time_formatTime),\r\n    y: function(d, p) {\r\n      return d3_time_formatPad(d.getFullYear() % 100, p, 2);\r\n    },\r\n    Y: function(d, p) {\r\n      return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\r\n    },\r\n    Z: d3_time_zone,\r\n    \"%\": function() {\r\n      return \"%\";\r\n    }\r\n  };\r\n  var d3_time_parsers = {\r\n    a: d3_time_parseWeekdayAbbrev,\r\n    A: d3_time_parseWeekday,\r\n    b: d3_time_parseMonthAbbrev,\r\n    B: d3_time_parseMonth,\r\n    c: d3_time_parseLocaleFull,\r\n    d: d3_time_parseDay,\r\n    e: d3_time_parseDay,\r\n    H: d3_time_parseHour24,\r\n    I: d3_time_parseHour24,\r\n    L: d3_time_parseMilliseconds,\r\n    m: d3_time_parseMonthNumber,\r\n    M: d3_time_parseMinutes,\r\n    p: d3_time_parseAmPm,\r\n    S: d3_time_parseSeconds,\r\n    x: d3_time_parseLocaleDate,\r\n    X: d3_time_parseLocaleTime,\r\n    y: d3_time_parseYear,\r\n    Y: d3_time_parseFullYear\r\n  };\r\n  function d3_time_parseWeekdayAbbrev(date, string, i) {\r\n    d3_time_dayAbbrevRe.lastIndex = 0;\r\n    var n = d3_time_dayAbbrevRe.exec(string.substring(i));\r\n    return n ? i += n[0].length : -1;\r\n  }\r\n  function d3_time_parseWeekday(date, string, i) {\r\n    d3_time_dayRe.lastIndex = 0;\r\n    var n = d3_time_dayRe.exec(string.substring(i));\r\n    return n ? i += n[0].length : -1;\r\n  }\r\n  function d3_time_parseMonthAbbrev(date, string, i) {\r\n    d3_time_monthAbbrevRe.lastIndex = 0;\r\n    var n = d3_time_monthAbbrevRe.exec(string.substring(i));\r\n    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;\r\n  }\r\n  function d3_time_parseMonth(date, string, i) {\r\n    d3_time_monthRe.lastIndex = 0;\r\n    var n = d3_time_monthRe.exec(string.substring(i));\r\n    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;\r\n  }\r\n  function d3_time_parseLocaleFull(date, string, i) {\r\n    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\r\n  }\r\n  function d3_time_parseLocaleDate(date, string, i) {\r\n    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\r\n  }\r\n  function d3_time_parseLocaleTime(date, string, i) {\r\n    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\r\n  }\r\n  function d3_time_parseFullYear(date, string, i) {\r\n    d3_time_numberRe.lastIndex = 0;\r\n    var n = d3_time_numberRe.exec(string.substring(i, i + 4));\r\n    return n ? (date.y = +n[0], i += n[0].length) : -1;\r\n  }\r\n  function d3_time_parseYear(date, string, i) {\r\n    d3_time_numberRe.lastIndex = 0;\r\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\r\n    return n ? (date.y = d3_time_expandYear(+n[0]), i += n[0].length) : -1;\r\n  }\r\n  function d3_time_expandYear(d) {\r\n    return d + (d > 68 ? 1900 : 2e3);\r\n  }\r\n  function d3_time_parseMonthNumber(date, string, i) {\r\n    d3_time_numberRe.lastIndex = 0;\r\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\r\n    return n ? (date.m = n[0] - 1, i += n[0].length) : -1;\r\n  }\r\n  function d3_time_parseDay(date, string, i) {\r\n    d3_time_numberRe.lastIndex = 0;\r\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\r\n    return n ? (date.d = +n[0], i += n[0].length) : -1;\r\n  }\r\n  function d3_time_parseHour24(date, string, i) {\r\n    d3_time_numberRe.lastIndex = 0;\r\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\r\n    return n ? (date.H = +n[0], i += n[0].length) : -1;\r\n  }\r\n  function d3_time_parseMinutes(date, string, i) {\r\n    d3_time_numberRe.lastIndex = 0;\r\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\r\n    return n ? (date.M = +n[0], i += n[0].length) : -1;\r\n  }\r\n  function d3_time_parseSeconds(date, string, i) {\r\n    d3_time_numberRe.lastIndex = 0;\r\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\r\n    return n ? (date.S = +n[0], i += n[0].length) : -1;\r\n  }\r\n  function d3_time_parseMilliseconds(date, string, i) {\r\n    d3_time_numberRe.lastIndex = 0;\r\n    var n = d3_time_numberRe.exec(string.substring(i, i + 3));\r\n    return n ? (date.L = +n[0], i += n[0].length) : -1;\r\n  }\r\n  var d3_time_numberRe = /^\\s*\\d+/;\r\n  function d3_time_parseAmPm(date, string, i) {\r\n    var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());\r\n    return n == null ? -1 : (date.p = n, i);\r\n  }\r\n  var d3_time_amPmLookup = d3.map({\r\n    am: 0,\r\n    pm: 1\r\n  });\r\n  function d3_time_zone(d) {\r\n    var z = d.getTimezoneOffset(), zs = z > 0 ? \"-\" : \"+\", zh = ~~(Math.abs(z) / 60), zm = Math.abs(z) % 60;\r\n    return zs + d3_time_formatPad(zh, \"0\", 2) + d3_time_formatPad(zm, \"0\", 2);\r\n  }\r\n  d3.time.format.utc = function(template) {\r\n    var local = d3.time.format(template);\r\n    function format(date) {\r\n      try {\r\n        d3_time = d3_time_utc;\r\n        var utc = new d3_time();\r\n        utc._ = date;\r\n        return local(utc);\r\n      } finally {\r\n        d3_time = Date;\r\n      }\r\n    }\r\n    format.parse = function(string) {\r\n      try {\r\n        d3_time = d3_time_utc;\r\n        var date = local.parse(string);\r\n        return date && date._;\r\n      } finally {\r\n        d3_time = Date;\r\n      }\r\n    };\r\n    format.toString = local.toString;\r\n    return format;\r\n  };\r\n  var d3_time_formatIso = d3.time.format.utc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\r\n  d3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;\r\n  function d3_time_formatIsoNative(date) {\r\n    return date.toISOString();\r\n  }\r\n  d3_time_formatIsoNative.parse = function(string) {\r\n    var date = new Date(string);\r\n    return isNaN(date) ? null : date;\r\n  };\r\n  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\r\n  function d3_time_interval(local, step, number) {\r\n    function round(date) {\r\n      var d0 = local(date), d1 = offset(d0, 1);\r\n      return date - d0 < d1 - date ? d0 : d1;\r\n    }\r\n    function ceil(date) {\r\n      step(date = local(new d3_time(date - 1)), 1);\r\n      return date;\r\n    }\r\n    function offset(date, k) {\r\n      step(date = new d3_time(+date), k);\r\n      return date;\r\n    }\r\n    function range(t0, t1, dt) {\r\n      var time = ceil(t0), times = [];\r\n      if (dt > 1) {\r\n        while (time < t1) {\r\n          if (!(number(time) % dt)) times.push(new Date(+time));\r\n          step(time, 1);\r\n        }\r\n      } else {\r\n        while (time < t1) times.push(new Date(+time)), step(time, 1);\r\n      }\r\n      return times;\r\n    }\r\n    function range_utc(t0, t1, dt) {\r\n      try {\r\n        d3_time = d3_time_utc;\r\n        var utc = new d3_time_utc();\r\n        utc._ = t0;\r\n        return range(utc, t1, dt);\r\n      } finally {\r\n        d3_time = Date;\r\n      }\r\n    }\r\n    local.floor = local;\r\n    local.round = round;\r\n    local.ceil = ceil;\r\n    local.offset = offset;\r\n    local.range = range;\r\n    var utc = local.utc = d3_time_interval_utc(local);\r\n    utc.floor = utc;\r\n    utc.round = d3_time_interval_utc(round);\r\n    utc.ceil = d3_time_interval_utc(ceil);\r\n    utc.offset = d3_time_interval_utc(offset);\r\n    utc.range = range_utc;\r\n    return local;\r\n  }\r\n  function d3_time_interval_utc(method) {\r\n    return function(date, k) {\r\n      try {\r\n        d3_time = d3_time_utc;\r\n        var utc = new d3_time_utc();\r\n        utc._ = date;\r\n        return method(utc, k)._;\r\n      } finally {\r\n        d3_time = Date;\r\n      }\r\n    };\r\n  }\r\n  d3.time.second = d3_time_interval(function(date) {\r\n    return new d3_time(Math.floor(date / 1e3) * 1e3);\r\n  }, function(date, offset) {\r\n    date.setTime(date.getTime() + Math.floor(offset) * 1e3);\r\n  }, function(date) {\r\n    return date.getSeconds();\r\n  });\r\n  d3.time.seconds = d3.time.second.range;\r\n  d3.time.seconds.utc = d3.time.second.utc.range;\r\n  d3.time.minute = d3_time_interval(function(date) {\r\n    return new d3_time(Math.floor(date / 6e4) * 6e4);\r\n  }, function(date, offset) {\r\n    date.setTime(date.getTime() + Math.floor(offset) * 6e4);\r\n  }, function(date) {\r\n    return date.getMinutes();\r\n  });\r\n  d3.time.minutes = d3.time.minute.range;\r\n  d3.time.minutes.utc = d3.time.minute.utc.range;\r\n  d3.time.hour = d3_time_interval(function(date) {\r\n    var timezone = date.getTimezoneOffset() / 60;\r\n    return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\r\n  }, function(date, offset) {\r\n    date.setTime(date.getTime() + Math.floor(offset) * 36e5);\r\n  }, function(date) {\r\n    return date.getHours();\r\n  });\r\n  d3.time.hours = d3.time.hour.range;\r\n  d3.time.hours.utc = d3.time.hour.utc.range;\r\n  d3.time.day = d3_time_interval(function(date) {\r\n    var day = new d3_time(1970, 0);\r\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\r\n    return day;\r\n  }, function(date, offset) {\r\n    date.setDate(date.getDate() + offset);\r\n  }, function(date) {\r\n    return date.getDate() - 1;\r\n  });\r\n  d3.time.days = d3.time.day.range;\r\n  d3.time.days.utc = d3.time.day.utc.range;\r\n  d3.time.dayOfYear = function(date) {\r\n    var year = d3.time.year(date);\r\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\r\n  };\r\n  d3_time_daySymbols.forEach(function(day, i) {\r\n    day = day.toLowerCase();\r\n    i = 7 - i;\r\n    var interval = d3.time[day] = d3_time_interval(function(date) {\r\n      (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\r\n      return date;\r\n    }, function(date, offset) {\r\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\r\n    }, function(date) {\r\n      var day = d3.time.year(date).getDay();\r\n      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\r\n    });\r\n    d3.time[day + \"s\"] = interval.range;\r\n    d3.time[day + \"s\"].utc = interval.utc.range;\r\n    d3.time[day + \"OfYear\"] = function(date) {\r\n      var day = d3.time.year(date).getDay();\r\n      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);\r\n    };\r\n  });\r\n  d3.time.week = d3.time.sunday;\r\n  d3.time.weeks = d3.time.sunday.range;\r\n  d3.time.weeks.utc = d3.time.sunday.utc.range;\r\n  d3.time.weekOfYear = d3.time.sundayOfYear;\r\n  d3.time.month = d3_time_interval(function(date) {\r\n    date = d3.time.day(date);\r\n    date.setDate(1);\r\n    return date;\r\n  }, function(date, offset) {\r\n    date.setMonth(date.getMonth() + offset);\r\n  }, function(date) {\r\n    return date.getMonth();\r\n  });\r\n  d3.time.months = d3.time.month.range;\r\n  d3.time.months.utc = d3.time.month.utc.range;\r\n  d3.time.year = d3_time_interval(function(date) {\r\n    date = d3.time.day(date);\r\n    date.setMonth(0, 1);\r\n    return date;\r\n  }, function(date, offset) {\r\n    date.setFullYear(date.getFullYear() + offset);\r\n  }, function(date) {\r\n    return date.getFullYear();\r\n  });\r\n  d3.time.years = d3.time.year.range;\r\n  d3.time.years.utc = d3.time.year.utc.range;\r\n  function d3_time_scale(linear, methods, format) {\r\n    function scale(x) {\r\n      return linear(x);\r\n    }\r\n    scale.invert = function(x) {\r\n      return d3_time_scaleDate(linear.invert(x));\r\n    };\r\n    scale.domain = function(x) {\r\n      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\r\n      linear.domain(x);\r\n      return scale;\r\n    };\r\n    scale.nice = function(m) {\r\n      return scale.domain(d3_scale_nice(scale.domain(), function() {\r\n        return m;\r\n      }));\r\n    };\r\n    scale.ticks = function(m, k) {\r\n      var extent = d3_time_scaleExtent(scale.domain());\r\n      if (typeof m !== \"function\") {\r\n        var span = extent[1] - extent[0], target = span / m, i = d3.bisect(d3_time_scaleSteps, target);\r\n        if (i == d3_time_scaleSteps.length) return methods.year(extent, m);\r\n        if (!i) return linear.ticks(m).map(d3_time_scaleDate);\r\n        if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;\r\n        m = methods[i];\r\n        k = m[1];\r\n        m = m[0].range;\r\n      }\r\n      return m(extent[0], new Date(+extent[1] + 1), k);\r\n    };\r\n    scale.tickFormat = function() {\r\n      return format;\r\n    };\r\n    scale.copy = function() {\r\n      return d3_time_scale(linear.copy(), methods, format);\r\n    };\r\n    return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\r\n  }\r\n  function d3_time_scaleExtent(domain) {\r\n    var start = domain[0], stop = domain[domain.length - 1];\r\n    return start < stop ? [ start, stop ] : [ stop, start ];\r\n  }\r\n  function d3_time_scaleDate(t) {\r\n    return new Date(t);\r\n  }\r\n  function d3_time_scaleFormat(formats) {\r\n    return function(date) {\r\n      var i = formats.length - 1, f = formats[i];\r\n      while (!f[1](date)) f = formats[--i];\r\n      return f[0](date);\r\n    };\r\n  }\r\n  function d3_time_scaleSetYear(y) {\r\n    var d = new Date(y, 0, 1);\r\n    d.setFullYear(y);\r\n    return d;\r\n  }\r\n  function d3_time_scaleGetYear(d) {\r\n    var y = d.getFullYear(), d0 = d3_time_scaleSetYear(y), d1 = d3_time_scaleSetYear(y + 1);\r\n    return y + (d - d0) / (d1 - d0);\r\n  }\r\n  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];\r\n  var d3_time_scaleLocalMethods = [ [ d3.time.second, 1 ], [ d3.time.second, 5 ], [ d3.time.second, 15 ], [ d3.time.second, 30 ], [ d3.time.minute, 1 ], [ d3.time.minute, 5 ], [ d3.time.minute, 15 ], [ d3.time.minute, 30 ], [ d3.time.hour, 1 ], [ d3.time.hour, 3 ], [ d3.time.hour, 6 ], [ d3.time.hour, 12 ], [ d3.time.day, 1 ], [ d3.time.day, 2 ], [ d3.time.week, 1 ], [ d3.time.month, 1 ], [ d3.time.month, 3 ], [ d3.time.year, 1 ] ];\r\n  var d3_time_scaleLocalFormats = [ [ d3.time.format(\"%Y\"), d3_true ], [ d3.time.format(\"%B\"), function(d) {\r\n    return d.getMonth();\r\n  } ], [ d3.time.format(\"%b %d\"), function(d) {\r\n    return d.getDate() != 1;\r\n  } ], [ d3.time.format(\"%a %d\"), function(d) {\r\n    return d.getDay() && d.getDate() != 1;\r\n  } ], [ d3.time.format(\"%I %p\"), function(d) {\r\n    return d.getHours();\r\n  } ], [ d3.time.format(\"%I:%M\"), function(d) {\r\n    return d.getMinutes();\r\n  } ], [ d3.time.format(\":%S\"), function(d) {\r\n    return d.getSeconds();\r\n  } ], [ d3.time.format(\".%L\"), function(d) {\r\n    return d.getMilliseconds();\r\n  } ] ];\r\n  var d3_time_scaleLinear = d3.scale.linear(), d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);\r\n  d3_time_scaleLocalMethods.year = function(extent, m) {\r\n    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);\r\n  };\r\n  d3.time.scale = function() {\r\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\r\n  };\r\n  var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {\r\n    return [ m[0].utc, m[1] ];\r\n  });\r\n  var d3_time_scaleUTCFormats = [ [ d3.time.format.utc(\"%Y\"), d3_true ], [ d3.time.format.utc(\"%B\"), function(d) {\r\n    return d.getUTCMonth();\r\n  } ], [ d3.time.format.utc(\"%b %d\"), function(d) {\r\n    return d.getUTCDate() != 1;\r\n  } ], [ d3.time.format.utc(\"%a %d\"), function(d) {\r\n    return d.getUTCDay() && d.getUTCDate() != 1;\r\n  } ], [ d3.time.format.utc(\"%I %p\"), function(d) {\r\n    return d.getUTCHours();\r\n  } ], [ d3.time.format.utc(\"%I:%M\"), function(d) {\r\n    return d.getUTCMinutes();\r\n  } ], [ d3.time.format.utc(\":%S\"), function(d) {\r\n    return d.getUTCSeconds();\r\n  } ], [ d3.time.format.utc(\".%L\"), function(d) {\r\n    return d.getUTCMilliseconds();\r\n  } ] ];\r\n  var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);\r\n  function d3_time_scaleUTCSetYear(y) {\r\n    var d = new Date(Date.UTC(y, 0, 1));\r\n    d.setUTCFullYear(y);\r\n    return d;\r\n  }\r\n  function d3_time_scaleUTCGetYear(d) {\r\n    var y = d.getUTCFullYear(), d0 = d3_time_scaleUTCSetYear(y), d1 = d3_time_scaleUTCSetYear(y + 1);\r\n    return y + (d - d0) / (d1 - d0);\r\n  }\r\n  d3_time_scaleUTCMethods.year = function(extent, m) {\r\n    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);\r\n  };\r\n  d3.time.scale.utc = function() {\r\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);\r\n  };\r\n  return d3;\r\n}();"]],"start1":0,"start2":0,"length1":0,"length2":275123}]],"length":275123,"saved":false}
