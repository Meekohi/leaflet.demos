{"ts":1360341394594,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1360341396617,"patch":[[{"diffs":[[1,"// BEGIN Math.uuid.js\n\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n(function() {\n  // Private array of chars to use\n  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\n  Math.uuid = function (len, radix) {\n    var chars = CHARS, uuid = [];\n    radix = radix || chars.length;\n\n    if (len) {\n      // Compact form\n      for (var i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];\n    } else {\n      // rfc4122, version 4 form\n      var r;\n\n      // rfc4122 requires these characters\n      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n      uuid[14] = '4';\n\n      // Fill in random data.  At i==19 set the high bits of clock sequence as\n      // per rfc4122, sec. 4.1.5\n      for (var i = 0; i < 36; i++) {\n        if (!uuid[i]) {\n          r = 0 | Math.random()*16;\n          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n        }\n      }\n    }\n\n    return uuid.join('');\n  };\n\n  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance\n  // by minimizing calls to random()\n  Math.uuidFast = function() {\n    var chars = CHARS, uuid = new Array(36), rnd=0, r;\n    for (var i = 0; i < 36; i++) {\n      if (i==8 || i==13 ||  i==18 || i==23) {\n        uuid[i] = '-';\n      } else if (i==14) {\n        uuid[i] = '4';\n      } else {\n        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\n        r = rnd & 0xf;\n        rnd = rnd >> 4;\n        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n      }\n    }\n    return uuid.join('');\n  };\n\n  // A more compact, but less performant, RFC4122v4 solution:\n  Math.uuidCompact = function() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n    }).toUpperCase();\n  };\n})();\n\n// END Math.uuid.js\n\n/**\n*\n*  MD5 (Message-Digest Algorithm)\n*\n*  For original source see http://www.webtoolkit.info/\n*  Download: 15.02.2009 from http://www.webtoolkit.info/javascript-md5.html\n*\n*  Licensed under CC-BY 2.0 License\n*  (http://creativecommons.org/licenses/by/2.0/uk/)\n*\n**/\n\nvar Crypto = {};\n(function() {\n  Crypto.MD5 = function(string) {\n\n    function RotateLeft(lValue, iShiftBits) {\n      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n    }\n\n    function AddUnsigned(lX,lY) {\n      var lX4,lY4,lX8,lY8,lResult;\n      lX8 = (lX & 0x80000000);\n      lY8 = (lY & 0x80000000);\n      lX4 = (lX & 0x40000000);\n      lY4 = (lY & 0x40000000);\n      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n      if (lX4 & lY4) {\n        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n      }\n      if (lX4 | lY4) {\n        if (lResult & 0x40000000) {\n          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n        } else {\n          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n        }\n      } else {\n        return (lResult ^ lX8 ^ lY8);\n      }\n    }\n\n    function F(x,y,z) { return (x & y) | ((~x) & z); }\n    function G(x,y,z) { return (x & z) | (y & (~z)); }\n    function H(x,y,z) { return (x ^ y ^ z); }\n    function I(x,y,z) { return (y ^ (x | (~z))); }\n\n    function FF(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function GG(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function HH(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function II(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    };\n\n    function ConvertToWordArray(string) {\n      var lWordCount;\n      var lMessageLength = string.length;\n      var lNumberOfWords_temp1=lMessageLength + 8;\n      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n      var lWordArray=Array(lNumberOfWords-1);\n      var lBytePosition = 0;\n      var lByteCount = 0;\n      while ( lByteCount < lMessageLength ) {\n        lWordCount = (lByteCount-(lByteCount % 4))/4;\n        lBytePosition = (lByteCount % 4)*8;\n        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n        lByteCount++;\n      }\n      lWordCount = (lByteCount-(lByteCount % 4))/4;\n      lBytePosition = (lByteCount % 4)*8;\n      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n      return lWordArray;\n    };\n\n    function WordToHex(lValue) {\n      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n      for (lCount = 0;lCount<=3;lCount++) {\n        lByte = (lValue>>>(lCount*8)) & 255;\n        WordToHexValue_temp = \"0\" + lByte.toString(16);\n        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n      }\n      return WordToHexValue;\n    };\n\n    //**    function Utf8Encode(string) removed. Aready defined in pidcrypt_utils.js\n\n    var x=Array();\n    var k,AA,BB,CC,DD,a,b,c,d;\n    var S11=7, S12=12, S13=17, S14=22;\n    var S21=5, S22=9 , S23=14, S24=20;\n    var S31=4, S32=11, S33=16, S34=23;\n    var S41=6, S42=10, S43=15, S44=21;\n\n    //    string = Utf8Encode(string); #function call removed\n\n    x = ConvertToWordArray(string);\n\n    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n\n    for (k=0;k<x.length;k+=16) {\n      AA=a; BB=b; CC=c; DD=d;\n      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\n      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\n      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\n      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n      a=AddUnsigned(a,AA);\n      b=AddUnsigned(b,BB);\n      c=AddUnsigned(c,CC);\n      d=AddUnsigned(d,DD);\n    }\n    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n    return temp.toLowerCase();\n  }\n})();\n\n// END Crypto.md5.js\n\n//----------------------------------------------------------------------\n//\n// ECMAScript 5 Polyfills\n//  from www.calocomrmen./polyfill/\n//\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\n// ES5 15.2 Object Objects\n//----------------------------------------------------------------------\n\n\n\n// ES 15.2.3.6 Object.defineProperty ( O, P, Attributes )\n// Partial support for most common case - getters, setters, and values\n(function() {\n  if (!Object.defineProperty ||\n      !(function () { try { Object.defineProperty({}, 'x', {}); return true; } catch (e) { return false; } } ())) {\n    var orig = Object.defineProperty;\n    Object.defineProperty = function (o, prop, desc) {\n      \"use strict\";\n\n      // In IE8 try built-in implementation for defining properties on DOM prototypes.\n      if (orig) { try { return orig(o, prop, desc); } catch (e) {} }\n\n      if (o !== Object(o)) { throw new TypeError(\"Object.defineProperty called on non-object\"); }\n      if (Object.prototype.__defineGetter__ && ('get' in desc)) {\n        Object.prototype.__defineGetter__.call(o, prop, desc.get);\n      }\n      if (Object.prototype.__defineSetter__ && ('set' in desc)) {\n        Object.prototype.__defineSetter__.call(o, prop, desc.set);\n      }\n      if ('value' in desc) {\n        o[prop] = desc.value;\n      }\n      return o;\n    };\n  }\n}());\n\n\n\n// ES5 15.2.3.14 Object.keys ( O )\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\nif (!Object.keys) {\n  Object.keys = function (o) {\n    if (o !== Object(o)) { throw new TypeError('Object.keys called on non-object'); }\n    var ret = [], p;\n    for (p in o) {\n      if (Object.prototype.hasOwnProperty.call(o, p)) {\n        ret.push(p);\n      }\n    }\n    return ret;\n  };\n}\n\n//----------------------------------------------------------------------\n// ES5 15.4 Array Objects\n//----------------------------------------------------------------------\n\n\n\n// ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function (fun /*, thisp */) {\n    \"use strict\";\n\n    if (this === void 0 || this === null) { throw new TypeError(); }\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (typeof fun !== \"function\") { throw new TypeError(); }\n\n    var thisp = arguments[1], i;\n    for (i = 0; i < len; i++) {\n      if (i in t) {\n        fun.call(thisp, t[i], i, t);\n      }\n    }\n  };\n}\n\n\n// ES5 15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] )\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map\nif (!Array.prototype.map) {\n  Array.prototype.map = function (fun /*, thisp */) {\n    \"use strict\";\n\n    if (this === void 0 || this === null) { throw new TypeError(); }\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (typeof fun !== \"function\") { throw new TypeError(); }\n\n    var res = []; res.length = len;\n    var thisp = arguments[1], i;\n    for (i = 0; i < len; i++) {\n      if (i in t) {\n        res[i] = fun.call(thisp, t[i], i, t);\n      }\n    }\n\n    return res;\n  };\n}\n\n\n\"use strict\";\n\nvar Pouch = function Pouch(name, opts, callback) {\n\n  if (!(this instanceof Pouch)) {\n    return new Pouch(name, opts, callback);\n  }\n\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\n    callback = opts;\n    opts = {};\n  }\n  \n  if (typeof name === 'object') {\n    opts = name;\n    name = undefined;\n  }\n\n  var backend = Pouch.parseAdapter(opts.name || name);\n  opts.name = opts.name || backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  if (!Pouch.adapters[opts.adapter]) {\n    throw 'Adapter is missing';\n  }\n\n  if (!Pouch.adapters[opts.adapter].valid()) {\n    throw 'Invalid Adapter';\n  }\n\n  var adapter = Pouch.adapters[opts.adapter](opts, function(err, db) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }\n    for (var plugin in Pouch.plugins) {\n      // In future these will likely need to be async to allow the plugin\n      // to initialise\n      var pluginObj = Pouch.plugins[plugin](db);\n      for (var api in pluginObj) {\n        // We let things like the http adapter use its own implementation\n        // as it shares a lot of code\n        if (!(api in db)) {\n          db[api] = pluginObj[api];\n        }\n      }\n    }\n    callback(null, db);\n  });\n  for (var j in adapter) {\n    this[j] = adapter[j];\n  }\n};\n\nPouch.DEBUG = false;\n\nPouch.adapters = {};\nPouch.plugins = {};\n\nPouch.parseAdapter = function(name) {\n\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\n    var adapter = match[1];\n    if (!Pouch.adapters[adapter].valid()) {\n      throw 'Invalid adapter';\n    }\n    return {name: name, adapter: match[1]};\n  }\n\n  var rank = {'idb': 1, 'leveldb': 2, 'websql': 3, 'http': 4, 'https': 4};\n  var rankedAdapter = Object.keys(Pouch.adapters).sort(function(a, b) {\n    return rank[a] - rank[b];\n  })[0];\n\n  return {\n    name: name,\n    adapter: rankedAdapter\n  };\n\n  throw 'No Valid Adapter.';\n};\n\n\nPouch.destroy = function(name, callback) {\n  for (var plugin in Pouch.plugins) {\n    Pouch.plugins[plugin]._delete(name);\n  }\n  var opts = Pouch.parseAdapter(name);\n  Pouch.adapters[opts.adapter].destroy(opts.name, callback);\n};\n\nPouch.adapter = function (id, obj) {\n  if (obj.valid()) {\n    Pouch.adapters[id] = obj;\n  }\n};\n\nPouch.plugin = function(id, obj) {\n  Pouch.plugins[id] = obj;\n};\n\n// Enumerate errors, add the status code so we can reflect the HTTP api\n// in future\nPouch.Errors = {\n  MISSING_BULK_DOCS: {\n    status: 400,\n    error: 'bad_request',\n    reason: \"Missing JSON list of 'docs'\"\n  },\n  MISSING_DOC: {\n    status: 404,\n    error: 'not_found',\n    reason: 'missing'\n  },\n  REV_CONFLICT: {\n    status: 409,\n    error: 'conflict',\n    reason: 'Document update conflict'\n  },\n  INVALID_ID: {\n    status: 400,\n    error: 'invalid_id',\n    reason: '_id field must contain a string'\n  },\n  MISSING_ID: {\n    status: 412,\n    error: 'missing_id',\n    reason: '_id is required for puts'\n  },\n  RESERVED_ID: {\n    status: 400,\n    error: 'bad_request',\n    reason: 'Only reserved document ids may start with underscore.'\n  },\n  NOT_OPEN: {\n    status: 412,\n    error: 'precondition_failed',\n    reason: 'Database not open so cannot close'\n  },\n  UNKNOWN_ERROR: {\n    status: 500,\n    error: 'unknown_error',\n    reason: 'Database encountered an unknown error'\n  },\n  INVALID_REQUEST: {\n    status: 400,\n    error: 'invalid_request',\n    reason: 'Request was invalid'\n  }\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  global.Pouch = Pouch;\n  Pouch.merge = require('./pouch.merge.js').merge;\n  Pouch.collate = require('./pouch.collate.js').collate;\n  Pouch.replicate = require('./pouch.replicate.js').replicate;\n  Pouch.utils = require('./pouch.utils.js');\n  module.exports = Pouch;\n\n  // load adapters known to work under node\n  var adapters = ['leveldb', 'http'];\n  adapters.map(function(adapter) {\n    var adapter_path = './adapters/pouch.'+adapter+'.js';\n    require(adapter_path);\n  });\n  require('./plugins/pouchdb.mapreduce.js');\n} else {\n  this.Pouch = Pouch;\n}\n\n(function() {\n  // a few hacks to get things in the right place for node.js\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Pouch;\n  }\n\n  Pouch.collate = function(a, b) {\n    var ai = collationIndex(a);\n    var bi = collationIndex(b);\n    if ((ai - bi) !== 0) {\n      return ai - bi;\n    }\n    if (a === null) {\n      return 0;\n    }\n    if (typeof a === 'number') {\n      return a - b;\n    }\n    if (typeof a === 'boolean') {\n      return a < b ? -1 : 1;\n    }\n    if (typeof a === 'string') {\n      return stringCollate(a, b);\n    }\n    if (Array.isArray(a)) {\n      return arrayCollate(a, b)\n    }\n    if (typeof a === 'object') {\n      return objectCollate(a, b);\n    }\n  }\n\n  var stringCollate = function(a, b) {\n    // See: https://github.com/daleharvey/pouchdb/issues/40\n    // This is incompatible with the CouchDB implementation, but its the\n    // best we can do for now\n    return (a === b) ? 0 : ((a > b) ? 1 : -1);\n  }\n\n  var objectCollate = function(a, b) {\n    var ak = Object.keys(a), bk = Object.keys(b);\n    var len = Math.min(ak.length, bk.length);\n    for (var i = 0; i < len; i++) {\n      // First sort the keys\n      var sort = Pouch.collate(ak[i], bk[i]);\n      if (sort !== 0) {\n        return sort;\n      }\n      // if the keys are equal sort the values\n      sort = Pouch.collate(a[ak[i]], b[bk[i]]);\n      if (sort !== 0) {\n        return sort;\n      }\n\n    }\n    return (ak.length === bk.length) ? 0 :\n      (ak.length > bk.length) ? 1 : -1;\n  }\n\n  var arrayCollate = function(a, b) {\n    var len = Math.min(a.length, b.length);\n    for (var i = 0; i < len; i++) {\n      var sort = Pouch.collate(a[i], b[i]);\n      if (sort !== 0) {\n        return sort;\n      }\n    }\n    return (a.length === b.length) ? 0 :\n      (a.length > b.length) ? 1 : -1;\n  }\n\n  // The collation is defined by erlangs ordered terms\n  // the atoms null, true, false come first, then numbers, strings,\n  // arrays, then objects\n  var collationIndex = function(x) {\n    var id = ['boolean', 'number', 'string', 'object'];\n    if (id.indexOf(typeof x) !== -1) {\n      if (x === null) {\n        return 1;\n      }\n      return id.indexOf(typeof x) + 2;\n    }\n    if (Array.isArray(x)) {\n      return 4.5;\n    }\n  }\n\n}).call(this);\n\n(function() {\n  // a few hacks to get things in the right place for node.js\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Pouch;\n    var utils = require('./pouch.utils.js');\n    for (var k in utils) {\n      global[k] = utils[k];\n    }\n  }\n\n  // for a better overview of what this is doing, read:\n  // https://github.com/apache/couchdb/blob/master/src/couchdb/couch_key_tree.erl\n  //\n  // But for a quick intro, CouchDB uses a revision tree to store a documents\n  // history, A -> B -> C, when a document has conflicts, that is a branch in the\n  // tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n  //\n  // KeyTree = [Path ... ]\n  // Path = {pos: position_from_root, ids: Tree}\n  // Tree = [Key, Tree]\n\n  // Turn a path as a flat array into a tree with a single branch\n  function pathToTree(path) {\n    var root = [path.shift(), []];\n    var leaf = root;\n    while (path.length) {\n      nleaf = [path.shift(), []];\n      leaf[1].push(nleaf);\n      leaf = nleaf;\n    }\n    return root;\n  }\n\n  // To ensure we dont grow the revision tree infinitely, we stem old revisions\n  function stem(tree, depth) {\n    // First we break out the tree into a complete list of root to leaf paths,\n    // we cut off the start of the path and generate a new set of flat trees\n    var stemmedPaths = rootToLeaf(tree).map(function(path) {\n      var stemmed = path.ids.slice(-depth);\n      return {\n        pos: path.pos + (path.ids.length - stemmed.length),\n        ids: pathToTree(stemmed)\n      };\n    });\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    return stemmedPaths.reduce(function(prev, current, i, arr) {\n      return doMerge(prev, current, true).tree;\n    }, [stemmedPaths.shift()]);\n  }\n\n  // Merge two trees together\n  // The roots of tree1 and tree2 must be the same revision\n\n  function mergeTree(in_tree1, in_tree2) {\n    var queue = [{tree1: in_tree1, tree2: in_tree2}];\n    var conflicts = false;\n    while (queue.length > 0) {\n      var item = queue.pop();\n      var tree1 = item.tree1;\n      var tree2 = item.tree2;\n\n      for (var i = 0; i < tree2[1].length; i++) {\n        if (!tree1[1][0]) {\n          conflicts = 'new_leaf';\n          tree1[1][0] = tree2[1][i];\n          continue;\n        }\n\n        var merged = false;\n        for (var j = 0; j < tree1[1].length; j++) {\n          if (tree1[1][j][0] == tree2[1][i][0]) {\n            queue.push({tree1: tree1[1][j], tree2: tree2[1][i]});\n            merged = true;\n          }\n        }\n        if (!merged) {\n          conflicts = 'new_branch';\n          tree1[1].push(tree2[1][i]);\n          tree1[1].sort();\n        }\n      }\n    }\n    return {conflicts: conflicts, tree: in_tree1};\n  }\n\n  function doMerge(tree, path, dontExpand) {\n    var restree = [];\n    var conflicts = false;\n    var merged = false;\n    var res, branch;\n\n    if (!tree.length) {\n      return {tree: [path], conflicts: 'new_leaf'};\n    }\n\n    tree.forEach(function(branch) {\n      if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n        // Paths start at the same position and have the same root, so they need\n        // merged\n        res = mergeTree(branch.ids, path.ids);\n        restree.push({pos: branch.pos, ids: res.tree});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      } else if (dontExpand !== true) {\n        // The paths start at a different position, take the earliest path and\n        // traverse up until it as at the same point from root as the path we want to\n        // merge.  If the keys match we return the longer path with the other merged\n        // After stemming we dont want to expand the trees\n\n        var t1 = branch.pos < path.pos ? branch : path;\n        var t2 = branch.pos < path.pos ? path : branch;\n        var diff = t2.pos - t1.pos;\n\n        var candidateParents = [];\n\n        var trees = [];\n        trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n        while (trees.length > 0) {\n          var item = trees.pop();\n          if (item.diff == 0) {\n            if (item.ids[0] == t2.ids[0]) {\n              candidateParents.push(item);\n            }\n            continue;\n          }\n          if (!item.ids) continue;\n          item.ids[1].forEach(function(el, idx) {\n            trees.push({ids: el, diff: item.diff-1, parent: item.ids, parentIdx: idx});\n          });\n        }\n\n        var el = candidateParents[0];\n\n        if (!el) {\n          restree.push(branch);\n        } else {\n          res = mergeTree(el.ids, t2.ids);\n          el.parent[1][el.parentIdx] = res.tree;\n          restree.push({pos: t1.pos, ids: t1.ids});\n          conflicts = conflicts || res.conflicts;\n          merged = true;\n        }\n      } else {\n        restree.push(branch);\n      }\n    });\n\n    // We didnt find\n    if (!merged) {\n      restree.push(path);\n    }\n\n    restree.sort(function(a, b) {\n      return a.pos - b.pos;\n    });\n\n    return {\n      tree: restree,\n      conflicts: conflicts || 'internal_node'\n    };\n  }\n\n  Pouch.merge = function(tree, path, depth) {\n    // Ugh, nicer way to not modify arguments in place?\n    tree = extend(true, [], tree);\n    path = extend(true, {}, path);\n    var newTree = doMerge(tree, path);\n    return {\n      tree: stem(newTree.tree, depth),\n      conflicts: newTree.conflicts\n    };\n  };\n\n}).call(this);\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Pouch;\n}\n\n(function() {\n\n  function replicate(src, target, opts, callback, replicateRet) {\n\n    fetchCheckpoint(src, target, opts, function(checkpoint) {\n      var results = [];\n      var completed = false;\n      var pending = 0;\n      var last_seq = checkpoint;\n      var continuous = opts.continuous || false;\n      var result = {\n        ok: true,\n        start_time: new Date(),\n        docs_read: 0,\n        docs_written: 0\n      };\n\n      function isCompleted() {\n        if (completed && pending === 0) {\n          result.end_time = new Date();\n          writeCheckpoint(src, target, opts, last_seq, function() {\n            call(callback, null, result);\n          });\n        }\n      }\n\n      if (replicateRet.cancelled) {\n        return;\n      }\n\n      var repOpts = {\n        continuous: continuous,\n        since: checkpoint,\n        style: 'all_docs',\n        onChange: function(change) {\n          last_seq = change.seq;\n          results.push(change);\n          result.docs_read++;\n          pending++;\n          var diff = {};\n          diff[change.id] = change.changes.map(function(x) { return x.rev; });\n          target.revsDiff(diff, function(err, diffs) {\n            if (err) {\n              if (continuous)\n                replicateRet.cancel();\n              call(callback, err, null);\n              return;\n            }\n            if (Object.keys(diffs).length === 0) {\n              pending--;\n              isCompleted();\n              return;\n            }\n            for (var id in diffs) {\n              diffs[id].missing.map(function(rev) {\n                src.get(id, {revs: true, rev: rev, attachments: true}, function(err, doc) {\n                  target.bulkDocs({docs: [doc]}, {new_edits: false}, function() {\n                    if (opts.onChange) {\n                      opts.onChange.apply(this, [result]);\n                    }\n                    result.docs_written++;\n                    pending--;\n                    isCompleted();\n                  });\n                });\n              });\n            }\n          });\n        },\n        complete: function(err, res) {\n          completed = true;\n          isCompleted();\n        }\n      };\n\n      if (opts.filter) {\n        repOpts.filter = opts.filter;\n      }\n\n      if (opts.query_params) {\n        repOpts.query_params = opts.query_params;\n      }\n\n      var changes = src.changes(repOpts);\n      if (opts.continuous) {\n        replicateRet.cancel = changes.cancel;\n      }\n    });\n  }\n\n  function toPouch(db, callback) {\n    if (typeof db === 'string') {\n      return new Pouch(db, callback);\n    }\n    callback(null, db);\n  }\n\n  Pouch.replicate = function(src, target, opts, callback) {\n    // TODO: This needs some cleaning up, from the replicate call I want\n    // to return a promise in which I can cancel continuous replications\n    // this will just proxy requests to cancel the changes feed but only\n    // after we start actually running the changes feed\n    if (opts instanceof Function) {\n      callback = opts;\n      opts = {}\n    }\n    if (opts === undefined) {\n      opts = {};\n    }\n\n    var ret = function() {\n      this.cancelled = false;\n      this.cancel = function() {\n        this.cancelled = true;\n      }\n    }\n    var replicateRet = new ret();\n    toPouch(src, function(err, src) {\n      if (err) {\n        return call(callback, err);\n      }\n      toPouch(target, function(err, target) {\n        if (err) {\n          return call(callback, err);\n        }\n        replicate(src, target, opts, callback, replicateRet);\n      });\n    });\n    return replicateRet;\n  };\n\n}).call(this);\n\n// Pretty dumb name for a function, just wraps callback calls so we dont\n// to if (callback) callback() everywhere\nvar call = function(fun) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  if (typeof fun === typeof Function) {\n    fun.apply(this, args);\n  }\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nvar yankError = function(callback) {\n  return function(err, results) {\n    if (err || results[0].error) {\n      call(callback, err || results[0]);\n    } else {\n      call(callback, null, results[0]);\n    }\n  };\n};\n\nvar isAttachmentId = function(id) {\n  return (/\\//.test(id)\n      && !/^_local/.test(id)\n      && !/^_design/.test(id));\n}\n\n// Parse document ids: docid[/attachid]\n//   - /attachid is optional, and can have slashes in it too\n//   - int ids and strings beginning with _design or _local are not split\n// returns an object: { docId: docid, attachmentId: attachid }\nvar parseDocId = function(id) {\n  var ids = (typeof id === 'string') && !(/^_(design|local)\\//.test(id))\n    ? id.split('/')\n    : [id]\n  return {\n    docId: ids[0],\n    attachmentId: ids.splice(1).join('/').replace(/^\\/+/, '')\n  }\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to metadata.rev\nvar isDeleted = function(metadata, rev) {\n  if (!metadata || !metadata.deletions) return false;\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  if (rev.indexOf('-') >= 0) {\n    rev = rev.split('-')[1];\n  }\n\n  return metadata.deletions[rev] === true;\n}\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or '_local'\n//   - any other string value is a valid id\nvar isValidId = function(id) {\n  if (/^_/.test(id)) {\n    return /^_(design|local)/.test(id);\n  }\n  return true;\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nvar parseDoc = function(doc, newEdits) {\n  var error = null;\n\n  // check for an attachment id and add attachments as needed\n  if (doc._id) {\n    var id = parseDocId(doc._id);\n    if (id.attachmentId !== '') {\n      var attachment = btoa(JSON.stringify(doc));\n      doc = {\n        _id: id.docId,\n      }\n      if (!doc._attachments) {\n        doc._attachments = {};\n      }\n      doc._attachments[id.attachmentId] = {\n        content_type: 'application/json',\n        data: attachment\n      }\n    }\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = Math.uuid();\n    }\n    var newRevId = Math.uuid(32, 16).toLowerCase();\n    var nRevNum;\n    if (doc._rev) {\n      var revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\n      if (!revInfo) {\n        throw \"invalid value for property '_rev'\";\n      }\n      doc._rev_tree = [{\n        pos: parseInt(revInfo[1], 10),\n        ids: [revInfo[2], [[newRevId, []]]]\n      }];\n      nRevNum = parseInt(revInfo[1], 10) + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = [{\n        pos: doc._revisions.start - doc._revisions.ids.length + 1,\n        ids: doc._revisions.ids.reduce(function(acc, x) {\n          if (acc === null) {\n            return [x, []];\n          } else {\n            return [x, [acc]];\n          }\n        }, null)\n      }];\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      var revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\n      nRevNum = parseInt(revInfo[1], 10);\n      newRevId = revInfo[2];\n      doc._rev_tree = [{\n        pos: parseInt(revInfo[1], 10),\n        ids: [revInfo[2], []]\n      }];\n    }\n  }\n\n  if (typeof doc._id !== 'string') {\n    error = Pouch.Errors.INVALID_ID;\n  }\n  else if (!isValidId(doc._id)) {\n    error = Pouch.Errors.RESERVED_ID;\n  }\n\n  doc._id = decodeURIComponent(doc._id);\n  doc._rev = [nRevNum, newRevId].join('-');\n\n  if (error) {\n    return error;\n  }\n\n  return Object.keys(doc).reduce(function(acc, key) {\n    if (/^_/.test(key) && key !== '_attachments') {\n      acc.metadata[key.slice(1)] = doc[key];\n    } else {\n      acc.data[key] = doc[key];\n    }\n    return acc;\n  }, {metadata : {}, data : {}});\n};\n\nvar compareRevs = function(a, b) {\n  // Sort by id\n  if (a.id !== b.id) {\n    return (a.id < b.id ? -1 : 1);\n  }\n  // Then by deleted\n  if (a.deleted ^ b.deleted) {\n    return (a.deleted ? -1 : 1);\n  }\n  // Then by rev id\n  if (a.rev_tree[0].pos === b.rev_tree[0].pos) {\n    return (a.rev_tree[0].ids < b.rev_tree[0].ids ? -1 : 1);\n  }\n  // Then by depth of edits\n  return (a.rev_tree[0].start < b.rev_tree[0].start ? -1 : 1);\n};\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// Callback has signature function(isLeaf, pos, id, [context])\n// The return value from the callback will be passed as context to all children of that node\nvar traverseRevTree = function(revs, callback) {\n  var toVisit = [];\n\n  revs.forEach(function(tree) {\n    toVisit.push({pos: tree.pos, ids: tree.ids});\n  });\n\n  while (toVisit.length > 0) {\n    var node = toVisit.pop(),\n        pos = node.pos,\n        tree = node.ids;\n    var newCtx = callback(tree[1].length == 0, pos, tree[0], node.ctx);\n    tree[1].forEach(function(branch) {\n      toVisit.push({pos: pos+1, ids: branch, ctx: newCtx});\n    });\n  }\n}\n\nvar collectRevs = function(path) {\n  var revs = [];\n\n  traverseRevTree([path], function(isLeaf, pos, id) {\n    revs.push({rev: pos + \"-\" + id, status: 'available'});\n  });\n\n  return revs;\n}\n\nvar collectLeaves = function(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function(isLeaf, pos, id) {\n    if (isLeaf) leaves.unshift({rev: pos + \"-\" + id, pos: pos});\n  });\n  leaves.sort(function(a, b) {\n    return b.pos-a.pos;\n  });\n  leaves.map(function(leaf) { delete leaf.pos });\n  return leaves;\n}\n\nvar collectConflicts = function(revs) {\n  var leaves = collectLeaves(revs);\n  // First is current rev\n  leaves.shift();\n  return leaves.map(function(x) { return x.rev; });\n}\n\nvar fetchCheckpoint = function(src, target, opts, callback) {\n  var filter_func = '';\n  if(typeof opts.filter != \"undefined\"){\n    filter_func = opts.filter.toString();\n  }\n\n  var id = Crypto.MD5(src.id() + target.id() + filter_func);\n  src.get('_local/' + id, function(err, doc) {\n    if (err && err.status === 404) {\n      callback(0);\n    } else {\n      callback(doc.last_seq);\n    }\n  });\n};\n\nvar writeCheckpoint = function(src, target, opts, checkpoint, callback) {\n  var filter_func = '';\n  if(typeof opts.filter != \"undefined\"){\n    filter_func = opts.filter.toString();\n  }\n  \n  var check = {\n    _id: '_local/' + Crypto.MD5(src.id() + target.id() + filter_func),\n    last_seq: checkpoint\n  };\n  src.get(check._id, function(err, doc) {\n    if (doc && doc._rev) {\n      check._rev = doc._rev;\n    }\n    src.put(check, function(err, doc) {\n      callback();\n    });\n  });\n};\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nvar winningRev = function(metadata) {\n  var deletions = metadata.deletions || {};\n  var leafs = [];\n\n  traverseRevTree(metadata.rev_tree, function(isLeaf, pos, id) {\n    if (isLeaf) leafs.push({pos: pos, id: id});\n  })\n\n  leafs.forEach(function(leaf) {\n    leaf.deleted = leaf.id in deletions;\n  });\n\n  leafs.sort(function(a, b) {\n    if (a.deleted !== b.deleted) {\n      return a.deleted > b.deleted ? 1 : -1;\n    }\n    if (a.pos !== b.pos) {\n      return b.pos - a.pos;\n    }\n    return a.id < b.id ? 1 : -1;\n  });\n  return leafs[0].pos + '-' + leafs[0].id;\n}\n\nvar rootToLeaf = function(tree) {\n  var paths = [];\n  \n  traverseRevTree(tree, function(isLeaf, pos, id, history) {\n    history = history ? history.slice(0) : [];\n    history.push(id);\n    if (isLeaf) {\n      var rootPos = pos + 1 - history.length;\n      paths.unshift({pos: rootPos, ids: history});\n    }\n    return history;\n  });\n\n  return paths;\n}\n\nvar arrayFirst = function(arr, callback) {\n  for (var i = 0; i < arr.length; i++) {\n    if (callback(arr[i], i) === true) {\n      return arr[i];\n    }\n  }\n  return false;\n};\n\nvar filterChange = function(opts) {\n  return function(change) {\n    if (opts.filter && !opts.filter.call(this, change.doc)) {\n      return;\n    }\n    if (!opts.include_docs) {\n      delete change.doc;\n    }\n    call(opts.onChange, change);\n  }\n};\n\n\nvar ajax = function ajax(options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    timeout: 10000\n  };\n  options = extend(true, defaultOptions, options);\n  if (options.auth) {\n      var token = btoa(options.auth.username + ':' + options.auth.password);\n      options.headers.Authorization = 'Basic ' + token;\n  }\n  var onSuccess = function(obj, resp, cb){\n    if (!options.json && typeof obj !== 'string') {\n          obj = JSON.stringify(obj);\n    } else if (options.json && typeof obj === 'string') {\n          obj = JSON.parse(obj);\n    }\n    call(cb, null, obj, resp);\n  };\n  var onError = function(err, cb){\n    var errParsed;\n    var errObj = err.responseText ? {status: err.status} : err; //this seems too clever\n         try{\n          errParsed = JSON.parse(err.responseText); //would prefer not to have a try/catch clause\n          errObj = extend(true, {}, errObj, errParsed);\n         } catch(e){}\n         call(cb, errObj);\n  };\n  if (window.XMLHttpRequest) {\n    var timer,timedout  = false;\n    var xhr = new XMLHttpRequest();\n    xhr.open(options.method, options.url);\n    if (options.json) {\n      options.headers.Accept = 'application/json';\n      options.headers['Content-Type'] = 'application/json';\n      if (options.body && typeof options.body !== \"string\") {\n        options.body = JSON.stringify(options.body);\n      }\n    }\n    for (var key in options.headers){\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n    if (!(\"body\" in options)) {\n      options.body = null;\n    }\n    \n    var abortReq = function() {\n        timedout=true;\n        xhr.abort();\n        call(onError, xhr, callback);\n      }\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState !== 4 || timedout) return;\n      clearTimeout(timer);\n      if (xhr.status >= 200 && xhr.status < 300){\n        call(onSuccess, xhr.responseText, xhr, callback);\n      } else {\n         call(onError, xhr, callback);\n      }\n    };\n    if (options.timeout > 0) {\n      timer = setTimeout(abortReq, options.timeout);\n    }\n    xhr.send(options.body);\n    return {abort:abortReq};\n  } else {\n    return request(options, function(err, response, body) {\n      if (err) {\n        err.status = response ? response.statusCode : 400;\n        return call(onError, err, callback);\n      }\n\n      var content_type = response.headers['content-type']\n        , data = (body || '');\n\n      // CouchDB doesn't always return the right content-type for JSON data, so\n      // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n      if (options.json && (/json/.test(content_type)\n          || (/^[\\s]*{/.test(data) && /}[\\s]*$/.test(data)))) {\n        data = JSON.parse(data);\n      }\n\n      if (data.error) {\n        data.status = response.statusCode;\n        call(onError, data, callback);\n      }\n      else {\n        call(onSuccess, data, response, callback);\n      }\n    });\n  }\n};\n\n// Extends method\n// (taken from http://code.jquery.com/jquery-1.9.0.js)\n// Populate the class2type map\nvar class2type = {};\n\nvar types = [\"Boolean\", \"Number\", \"String\", \"Function\", \"Array\", \"Date\", \"RegExp\", \"Object\", \"Error\"];\nfor (var i = 0; i < types.length; i++) {\n  var typename = types[i];\n  class2type[ \"[object \" + typename + \"]\" ] = typename.toLowerCase();\n}\n\nvar core_toString = class2type.toString;\nvar core_hasOwn = class2type.hasOwnProperty;\n\nvar type = function(obj) {\n  if (obj === null) {\n    return String( obj );\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[core_toString.call(obj)] || \"object\" :\n    typeof obj;\n};\n\nvar isPlainObject = function( obj ) {\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if ( !obj || type(obj) !== \"object\" || obj.nodeType || isWindow( obj ) ) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if ( obj.constructor &&\n      !core_hasOwn.call(obj, \"constructor\") &&\n      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n\n  var key;\n  for ( key in obj ) {}\n\n  return key === undefined || core_hasOwn.call( obj, key );\n};\n\nvar isFunction = function(obj) {\n  return type(obj) === \"function\";\n};\n\nvar isWindow = function(obj) {\n  return obj != null && obj == obj.window;\n};\n\nvar isArray = Array.isArray || function(obj) {\n  return type(obj) === \"array\";\n};\n\nvar extend = function() {\n  var options, name, src, copy, copyIsArray, clone,\n    target = arguments[0] || {},\n    i = 1,\n    length = arguments.length,\n    deep = false;\n\n  // Handle a deep copy situation\n  if ( typeof target === \"boolean\" ) {\n    deep = target;\n    target = arguments[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if ( typeof target !== \"object\" && !isFunction(target) ) {\n    target = {};\n  }\n\n  // extend jQuery itself if only one argument is passed\n  if ( length === i ) {\n    target = this;\n    --i;\n  }\n\n  for ( ; i < length; i++ ) {\n    // Only deal with non-null/undefined values\n    if ((options = arguments[ i ]) != null) {\n      // Extend the base object\n      for ( name in options ) {\n        src = target[ name ];\n        copy = options[ name ];\n\n        // Prevent never-ending loop\n        if ( target === copy ) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        if ( deep && copy && ( isPlainObject(copy) || (copyIsArray = isArray(copy)) ) ) {\n          if ( copyIsArray ) {\n            copyIsArray = false;\n            clone = src && isArray(src) ? src : [];\n\n          } else {\n            clone = src && isPlainObject(src) ? src : {};\n          }\n\n          // Never move original objects, clone them\n          target[ name ] = extend( deep, clone, copy );\n\n        // Don't bring in undefined values\n        } else if ( copy !== undefined ) {\n          target[ name ] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n};\n\n// Basic wrapper for localStorage\nvar win = this;\nvar localJSON = (function(){\n  if (!win.localStorage) {\n    return false;\n  }\n  return {\n    set: function(prop, val) {\n      localStorage.setItem(prop, JSON.stringify(val));\n    },\n    get: function(prop, def) {\n      try {\n        if (localStorage.getItem(prop) === null) {\n          return def;\n        }\n        return JSON.parse((localStorage.getItem(prop) || 'false'));\n      } catch(err) {\n        return def;\n      }\n    },\n    remove: function(prop) {\n      localStorage.removeItem(prop);\n    }\n  };\n})();\n\n// btoa and atob don't exist in node. see https://developer.mozilla.org/en-US/docs/DOM/window.btoa\nif (typeof btoa === 'undefined') {\n  btoa = function(str) {\n    return new Buffer(unescape(encodeURIComponent(str)), 'binary').toString('base64');\n  }\n}\nif (typeof atob === 'undefined') {\n  atob = function(str) {\n    return decodeURIComponent(escape(new Buffer(str, 'base64').toString('binary')));\n  }\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  // use node.js's crypto library instead of the Crypto object created by deps/uuid.js\n  var crypto = require('crypto');\n  var Crypto = {\n    MD5: function(str) {\n      return crypto.createHash('md5').update(str).digest('hex');\n    }\n  }\n  request = require('request');\n  _ = require('underscore');\n  $ = _;\n\n  module.exports = {\n    Crypto: Crypto,\n    call: call,\n    yankError: yankError,\n    isAttachmentId: isAttachmentId,\n    parseDocId: parseDocId,\n    parseDoc: parseDoc,\n    isDeleted: isDeleted,\n    compareRevs: compareRevs,\n    collectRevs: collectRevs,\n    collectLeaves: collectLeaves,\n    collectConflicts: collectConflicts,\n    fetchCheckpoint: fetchCheckpoint,\n    writeCheckpoint: writeCheckpoint,\n    winningRev: winningRev,\n    rootToLeaf: rootToLeaf,\n    arrayFirst: arrayFirst,\n    filterChange: filterChange,\n    ajax: ajax,\n    atob: atob,\n    btoa: btoa,\n    extend: extend\n  }\n}\n\n\"use strict\";\n\nvar HTTP_TIMEOUT = 10000;\n\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nfunction parseUri (str) {\n  var o = parseUri.options;\n  var m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) uri[o.key[i]] = m[i] || \"\";\n\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) uri[o.q.name][$1] = $2;\n  });\n\n  return uri;\n}\n\nparseUri.options = {\n  strictMode: false,\n  key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\n        \"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\n  q:   {\n    name:   \"queryKey\",\n    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n  },\n  parser: {\n    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n    loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name) {\n  // If the given name contains \"http:\"\n  if (/http(s?):/.test(name)) {\n    // Prase the URI into all its little bits\n    var uri = parseUri(name);\n\n    // Store the fact that it is a remote URI\n    uri.remote = true;\n\n    // Store the user and password as a separate auth object\n    if (uri.user || uri.password) {\n      uri.auth = {username: uri.user, password: uri.password};\n    }\n\n    // Split the path part of the URI into parts using '/' as the delimiter\n    // after removing any leading '/' and any trailing '/'\n    var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n    // Store the first part as the database name and remove it from the parts\n    // array\n    uri.db = parts.pop();\n\n    // Restore the path by joining all the remaining parts (all the parts\n    // except for the database name) with '/'s\n    uri.path = parts.join('/');\n\n    return uri;\n  }\n\n  // If the given name does not contain 'http:' then return a very basic object\n  // with no host, the current path, the given name as the database name and no\n  // username/password\n  return {host: '', path: '/', db: name, auth: false};\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  // If the host is remote\n  if (opts.remote) {\n    // If the host already has a path, then we need to have a path delimiter\n    // Otherwise, the path delimiter is the empty string\n    var pathDel = !opts.path ? '' : '/';\n\n    // Return the URL made up of all the host's information and the given path\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' +\n      opts.path + pathDel + opts.db + '/' + path;\n  }\n\n  // If the host is not remote, then return the URL made up of just the\n  // database name and the given path\n  return '/' + opts.db + '/' + path;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  if (opts.remote) {\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' + path;\n  }\n  return '/' + path;\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nvar HttpPouch = function(opts, callback) {\n\n  // Parse the URI given by opts.name into an easy-to-use object\n  var host = getHost(opts.name);\n  if (opts.auth) host.auth = opts.auth;\n\n  // Generate the database URL based on the host\n  var db_url = genDBUrl(host, '');\n\n  // The functions that will be publically available for HttpPouch\n  var api = {};\n\n  var uuids = {\n    list: [],\n    get: function(opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {count: 10};\n      }\n      var cb = function(err, body) {\n        if (err || !('uuids' in body)) {\n          call(callback, err || Pouch.Errors.UNKNOWN_ERROR);\n        } else {\n          uuids.list = uuids.list.concat(body.uuids);\n          call(callback, null, \"OK\");\n        }\n      };\n      var params = '?count=' + opts.count;\n      ajax({\n        auth: host.auth,\n        method: 'GET',\n        url: genUrl(host, '_uuids') + params\n      }, cb);\n    }\n  };\n\n  // Create a new CouchDB database based on the given opts\n  var createDB = function(){\n    ajax({auth: host.auth, method: 'PUT', url: db_url}, function(err, ret) {\n      // If we get an \"Unauthorized\" error\n      if (err && err.status === 401) {\n        // Test if the database already exists\n        ajax({auth: host.auth, method: 'HEAD', url: db_url}, function (err, ret) {\n          // If there is still an error\n          if (err) {\n            // Give the error to the callback to deal with\n            call(callback, err);\n          } else {\n            // Continue as if there had been no errors\n            call(callback, null, api);\n          }\n        });\n        // If there were no errros or if the only error is \"Precondition Failed\"\n        // (note: \"Precondition Failed\" occurs when we try to create a database\n        // that already exists)\n      } else if (!err || err.status === 412) {\n        // Continue as if there had been no errors\n        call(callback, null, api);\n      } else {\n        call(callback, Pouch.Errors.UNKNOWN_ERROR);\n      }\n    });\n  };\n  ajax({auth: host.auth, method: 'GET', url: db_url}, function(err, ret) {\n    //check if the db exists\n    if (err) {\n      if (err.status === 404) {\n        //if it doesn't, create it\n        createDB();\n      } else {\n        call(callback, err);\n      }\n    } else {\n      //go do stuff with the db\n      call(callback, null, api);\n      }\n  });\n\n  api.type = function() {\n    return 'http';\n  };\n\n  // The HttpPouch's ID is its URL\n  api.id = function() {\n    return genDBUrl(host, '');\n  };\n\n  api.request = function(options, callback) {\n    options.auth = host.auth;\n    options.url = genDBUrl(host, options.url);\n    ajax(options, callback);\n  };\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = function(callback) {\n    ajax({\n      auth: host.auth,\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, callback)\n  }\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api.info = function(callback) {\n    ajax({\n      auth: host.auth,\n      method:'GET',\n      url: genDBUrl(host, ''),\n    }, callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = function(id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n\n    // If it exists, add the opts.revs value to the list of parameters.\n    // If revs=true then the resulting JSON will include a field\n    // _revisions containing an array of the revision IDs.\n    if (opts.revs) {\n      params.push('revs=true');\n    }\n\n    // If it exists, add the opts.revs_info value to the list of parameters.\n    // If revs_info=true then the resulting JSON will include the field\n    // _revs_info containing an array of objects in which each object\n    // representing an available revision.\n    if (opts.revs_info) {\n      params.push('revs_info=true');\n    }\n\n    // If it exists, add the opts.attachments value to the list of parameters.\n    // If attachments=true the resulting JSON will include the base64-encoded\n    // contents in the \"data\" property of each attachment.\n    if (opts.attachments) {\n      params.push('attachments=true');\n    }\n\n    // If it exists, add the opts.rev value to the list of parameters.\n    // If rev is given a revision number then get the specified revision.\n    if (opts.rev) {\n      params.push('rev=' + opts.rev);\n    }\n\n    // If it exists, add the opts.conflicts value to the list of parameters.\n    // If conflicts=true then the resulting JSON will include the field\n    // _conflicts containing all the conflicting revisions.\n    if (opts.conflicts) {\n      params.push('conflicts=' + opts.conflicts);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // Set the options for the ajax call\n    var options = {\n      auth: host.auth,\n      method: 'GET',\n      url: genDBUrl(host, id + params)\n    };\n\n    // If the given id contains at least one '/' and the part before the '/'\n    // is NOT \"_design\" and is NOT \"_local\"\n    // OR\n    // If the given id contains at least two '/' and the part before the first\n    // '/' is \"_design\".\n    // TODO This second condition seems strange since if parts[0] === '_design'\n    // then we already know that parts[0] !== '_local'.\n    var parts = id.split('/');\n    if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||\n        (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {\n      // Nothing is expected back from the server\n      options.json = false;\n    }\n\n    // Get the document\n    ajax(options, function(err, doc, xhr) {\n      // If the document does not exist, send an error to the callback\n      if (err) {\n        return call(callback, Pouch.Errors.MISSING_DOC);\n      }\n\n      // Send the document to the callback\n      call(callback, null, doc, xhr);\n    });\n  };\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = function(doc, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Delete the document\n    ajax({\n      auth: host.auth,\n      method:'DELETE',\n      url: genDBUrl(host, doc._id) + '?rev=' + doc._rev\n    }, callback);\n  };\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\n    ajax({\n      auth: host.auth,\n      method: 'DELETE',\n      url: genDBUrl(host, id) + '?rev=' + rev,\n    }, callback);\n  };\n\n  // Add the attachment given by doc and the content type given by type\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = function(id, rev, doc, type, callback) {\n    // Add the attachment\n    ajax({\n      auth: host.auth,\n      method:'PUT',\n      url: genDBUrl(host, id) + '?rev=' + rev,\n      headers: {'Content-Type': type},\n      body: doc\n    }, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This fails if the doc has no _id field.\n  api.put = function(doc, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (!doc || !('_id' in doc)) {\n      return call(callback, Pouch.Errors.MISSING_ID);\n    }\n\n    // List of parameter to add to the PUT request\n    var params = [];\n\n    // If it exists, add the opts.new_edits value to the list of parameters.\n    // If new_edits = false then the database will NOT assign this document a\n    // new revision number\n    if (opts && typeof opts.new_edits !== 'undefined') {\n      params.push('new_edits=' + opts.new_edits);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // Add the document\n    ajax({\n      auth: host.auth,\n      method: 'PUT',\n      url: genDBUrl(host, doc._id) + params,\n      body: doc\n    }, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This does not assume that doc is a new document (i.e. does not\n  // have a _id or a _rev field.\n  api.post = function(doc, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (! (\"_id\" in doc)) {\n      if (uuids.list.length > 0) {\n        doc._id = uuids.list.pop();\n        api.put(doc, opts, callback);\n      }else {\n        uuids.get(function(err, resp) {\n          if (err) {\n            return call(callback, Pouch.Errors.UNKNOWN_ERROR);\n          }\n          doc._id = uuids.list.pop();\n          api.put(doc, opts, callback);\n        });\n      }\n    } else {\n      api.put(doc, opts, callback);\n    }\n  };\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api.bulkDocs = function(req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!opts) {\n      opts = {}\n    }\n\n    // If opts.new_edits exists add it to the document data to be\n    // send to the database.\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    if (typeof opts.new_edits !== 'undefined') {\n      req.new_edits = opts.new_edits;\n    }\n\n    // Update/create the documents\n    ajax({\n      auth: host.auth,\n      method:'POST',\n      url: genDBUrl(host, '_bulk_docs'),\n      body: req\n    }, callback);\n  };\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = function(opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n\n    // TODO I don't see conflicts as a valid parameter for a\n    // _all_docs request (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)\n    if (opts.conflicts) {\n      params.push('conflicts=true');\n    }\n\n    // If opts.include_docs exists, add the include_docs value to the\n    // list of parameters.\n    // If include_docs=true then include the associated document with each\n    // result.\n    if (opts.include_docs) {\n      params.push('include_docs=true');\n    }\n\n    // If opts.startkey exists, add the startkey value to the list of\n    // parameters.\n    // If startkey is given then the returned list of documents will\n    // start with the document whose id is startkey.\n    if (opts.startkey) {\n      params.push('startkey=' +\n                  encodeURIComponent(JSON.stringify(opts.startkey)));\n    }\n\n    // If opts.endkey exists, add the endkey value to the list of parameters.\n    // If endkey is given then the returned list of docuemnts will\n    // end with the document whose id is endkey.\n    if (opts.endkey) {\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\n    }\n\n    // If opts.keys exists, add the keys value to the list of parameters.\n    if (opts.keys) {\n      params.push('keys=' + encodeURIComponent(JSON.stringify(opts.keys)));\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // Get the document listing\n    ajax({\n      auth: host.auth,\n      method:'GET',\n      url: genDBUrl(host, '_all_docs' + params)\n    }, callback);\n  };\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api.changes = function(opts) {\n\n    if (Pouch.DEBUG)\n      console.log(db_url + ': Start Changes Feed: continuous=' + opts.continuous);\n\n    // Query string of all the parameters to add to the GET request\n    var params = [],\n        paramsStr;\n\n    if (opts.style) {\n      params.push('style='+opts.style);\n    }\n\n    // If opts.include_docs exists, opts.filter exists, and opts.filter is a\n    // function, add the include_docs value to the query string.\n    // If include_docs=true then include the associated document with each\n    // result.\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.push('include_docs=true');\n    }\n\n    // If opts.continuous exists, add the feed value to the query string.\n    // If feed=longpoll then it waits for either a timeout or a change to\n    // occur before returning.\n    if (opts.continuous) {\n      params.push('feed=longpoll');\n    }\n\n    // If opts.conflicts exists, add the conflicts value to the query string.\n    // TODO I can't find documentation of what conflicts=true does. See\n    // http://wiki.apache.org/couchdb/HTTP_database_API#Changes\n    if (opts.conflicts) {\n      params.push('conflicts=true');\n    }\n\n    // If opts.descending exists, add the descending value to the query string.\n    // if descending=true then the change results are returned in\n    // descending order (most recent change first).\n    if (opts.descending) {\n      params.push('descending=true');\n    }\n\n    // If opts.filter exists and is a string then add the filter value\n    // to the query string.\n    // If filter is given a string containing the name of a filter in\n    // the design, then only documents passing through the filter will\n    // be returned.\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.push('filter=' + opts.filter);\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params.push(param_name+'='+opts.query_params[param_name]);\n        }\n      }\n    }\n\n    paramsStr = '?';\n\n    if (params.length > 0) {\n      paramsStr += params.join('&');\n    }\n\n    var xhr;\n    var last_seq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function(since, callback) {\n      // Set the options for the ajax call\n      var xhrOpts = {\n        auth: host.auth, method:'GET',\n        url: genDBUrl(host, '_changes' + paramsStr + '&since=' + since),\n        timeout: null          // _changes can take a long time to generate, especially when filtered\n      };\n      last_seq = since;\n\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      xhr = ajax(xhrOpts, callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var fetchTimeout = 10;\n    var fetchRetryCount = 0;\n    var fetched = function(err, res) {\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        // For each change\n        res.results.forEach(function(c) {\n          var hasFilter = opts.filter && typeof opts.filter === 'function';\n          if (opts.aborted || hasFilter && !opts.filter.apply(this, [c.doc])) {\n            return;\n          }\n\n          // Process the change\n          call(opts.onChange, c);\n        });\n      }\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        last_seq = res.last_seq;\n      }\n\n      if (opts.continuous) {\n        // Increase retry delay exponentially as long as errors persist\n        if (err) fetchRetryCount += 1;\n        else fetchRetryCount = 0;\n        var timeoutMultiplier = 1 << fetchRetryCount;       // i.e. Math.pow(2, fetchRetryCount)\n        \n        var retryWait = fetchTimeout * timeoutMultiplier;\n        var maximumWait = opts.maximumWait || 30000;\n        if (retryWait > maximumWait) {\n          call(opts.complete, err || Pouch.Errors.UNKNOWN_ERROR, null);\n        }\n        \n        // Queue a call to fetch again with the newest sequence number\n        setTimeout(function () {\n          fetch(last_seq, fetched);\n        }, retryWait);\n      } else {\n        // We're done, call the callback\n        call(opts.complete, null, res);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function() {\n        if (Pouch.DEBUG)\n          console.log(db_url + ': Cancel Changes Feed');\n        opts.aborted = true;\n        xhr.abort();\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = function(req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax({\n      auth: host.auth,\n      method:'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, function(err, res) {\n      call(callback, null, res);\n    });\n  };\n\n  api.replicate = {};\n\n  // Replicate from the database given by url to this HttpPouch\n  api.replicate.from = function(url, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(url, api, opts, callback);\n  };\n\n  // Replicate to the database given by dbName from this HttpPouch\n  api.replicate.to = function(dbName, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(api, dbName, opts, callback);\n  };\n\n  api.close = function(callback) {\n    call(callback, null);\n  };\n\n  return api;\n};\n\n// Delete the HttpPouch specified by the given name.\nHttpPouch.destroy = function(name, callback) {\n  var host = getHost(name);\n  ajax({auth: host.auth, method: 'DELETE', url: genDBUrl(host, '')}, callback);\n};\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function() {\n  return true;\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  // running in node\n  var pouchdir = '../';\n  this.Pouch = require(pouchdir + 'pouch.js')\n  this.ajax = Pouch.utils.ajax;\n}\n\n// Set HttpPouch to be the adapter used with the http scheme.\nPouch.adapter('http', HttpPouch);\nPouch.adapter('https', HttpPouch);\n\n// While most of the IDB behaviors match between implementations a\n// lot of the names still differ. This section tries to normalize the\n// different objects & methods.\nwindow.indexedDB = window.indexedDB ||\n  window.mozIndexedDB ||\n  window.webkitIndexedDB;\n\n// still needed for R/W transactions in Android Chrome. follow MDN example:\n// https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#transaction\n// note though that Chrome Canary fails on undefined READ_WRITE constants\n// on the native IDBTransaction object\nwindow.IDBTransaction = (window.IDBTransaction && window.IDBTransaction.READ_WRITE)\n  ? window.IDBTransaction\n  : (window.webkitIDBTransaction && window.webkitIDBTransaction.READ_WRITE)\n    ? window.webkitIDBTransaction\n    : { READ_WRITE: 'readwrite' };\n\nwindow.IDBKeyRange = window.IDBKeyRange ||\n  window.webkitIDBKeyRange;\n\nwindow.storageInfo = window.storageInfo ||\n  window.webkitStorageInfo;\n\nwindow.requestFileSystem = window.requestFileSystem ||\n    window.webkitRequestFileSystem;\n\nvar idbError = function(callback) {\n  return function(event) {\n    call(callback, {\n      status: 500,\n      error: event.type,\n      reason: event.target\n    });\n  };\n};\n\nvar IdbPouch = function(opts, callback) {\n\n  // IndexedDB requires a versioned database structure, this is going to make\n  // it hard to dynamically create object stores if we needed to for things\n  // like views\n  var POUCH_VERSION = 1;\n\n  // The object stores created for each database\n  // DOC_STORE stores the document meta data, its revision history and state\n  var DOC_STORE = 'document-store';\n  // BY_SEQ_STORE stores a particular version of a document, keyed by its\n  // sequence id\n  var BY_SEQ_STORE = 'by-sequence';\n  // Where we store attachments\n  var ATTACH_STORE = 'attach-store';\n  // Where we store meta data\n  var META_STORE = 'meta-store';\n\n\n  var name = opts.name;\n  var req = indexedDB.open(name, POUCH_VERSION);\n  var meta = {\n    id: 'meta-store',\n    updateSeq: 0,\n  };\n\n  var instanceId = null;\n\n  // var storeAttachmentsInIDB = !(window.storageInfo && window.requestFileSystem);\n  // We cant store attachments on the filesystem due to a limitation in the\n  // indexeddb api, it will close a transaction when we yield to the event loop\n  var storeAttachmentsInIDB = true;\n\n  var api = {};\n  var idb = null;\n\n  if (Pouch.DEBUG)\n    console.log(name + ': Open Database');\n\n  // TODO: before we release, make sure we write upgrade needed\n  // in a way that supports a future upgrade path\n  req.onupgradeneeded = function(e) {\n    var db = e.target.result;\n    db.createObjectStore(DOC_STORE, {keyPath : 'id'})\n      .createIndex('seq', 'seq', {unique: true});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement : true})\n      .createIndex('_rev', '_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n  };\n\n  req.onsuccess = function(e) {\n\n    idb = e.target.result;\n\n    var txn = idb.transaction([META_STORE], IDBTransaction.READ_WRITE);\n\n    idb.onversionchange = function() {\n      idb.close();\n    };\n\n    // polyfill the new onupgradeneeded api for chrome. can get rid of when\n    // saucelabs moves to chrome 23\n    if (idb.setVersion && Number(idb.version) !== POUCH_VERSION) {\n      var versionReq = idb.setVersion(POUCH_VERSION);\n      versionReq.onsuccess = function(evt) {\n        function setVersionComplete() {\n          req.onsuccess(e);\n        }\n        evt.target.result.oncomplete = setVersionComplete;\n        req.onupgradeneeded(e);\n      };\n      return;\n    }\n\n    var req = txn.objectStore(META_STORE).get('meta-store');\n\n    req.onsuccess = function(e) {\n      var reqDBId,\n          result;\n\n      if (e.target.result) {\n        meta = e.target.result;\n      }\n\n      if (name + '_id' in meta) {\n        instanceId = meta[name + '_id'];\n      } else {\n        instanceId = Math.uuid();\n\n        meta[name + '_id'] = instanceId;\n        reqDBId = txn.objectStore(META_STORE).put(meta);\n      }\n      call(callback, null, api);\n    }\n  };\n\n  req.onerror = idbError(callback);\n\n  api.type = function() {\n    return 'idb';\n  };\n\n  // Each database needs a unique id so that we can store the sequence\n  // checkpoint without having other databases confuse itself.\n  api.id = function idb_id() {\n    return instanceId;\n  };\n\n  api.bulkDocs = function idb_bulkDocs(req, opts, callback) {\n\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!opts) {\n      opts = {};\n    }\n\n    if (!req.docs) {\n      return call(callback, Pouch.Errors.MISSING_BULK_DOCS);\n    }\n\n    var newEdits = 'new_edits' in opts ? opts.new_edits : true;\n    var userDocs = extend(true, [], req.docs);\n\n    // Parse the docs, give them a sequence number for the result\n    var docInfos = userDocs.map(function(doc, i) {\n      var newDoc = parseDoc(doc, newEdits);\n      newDoc._bulk_seq = i;\n      if (doc._deleted) {\n        if (!newDoc.metadata.deletions) {\n          newDoc.metadata.deletions = {};\n        }\n        newDoc.metadata.deletions[doc._rev.split('-')[1]] = true;\n      }\n      return newDoc;\n    });\n\n    var results = [];\n    var docs = [];\n\n    // Group multiple edits to the same document\n    docInfos.forEach(function(docInfo) {\n      if (docInfo.error) {\n        return results.push(docInfo);\n      }\n      if (!docs.length || docInfo.metadata.id !== docs[0].metadata.id) {\n        return docs.unshift(docInfo);\n      }\n      // We mark subsequent bulk docs with a duplicate id as conflicts\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n    });\n\n    function processDocs() {\n      if (!docs.length) {\n        return;\n      }\n      var currentDoc = docs.shift();\n      var req = txn.objectStore(DOC_STORE).get(currentDoc.metadata.id);\n      req.onsuccess = function process_docRead(event) {\n        var oldDoc = event.target.result;\n        if (!oldDoc) {\n          insertDoc(currentDoc);\n        } else {\n          updateDoc(oldDoc, currentDoc);\n        }\n      };\n    }\n\n    function complete(event) {\n      var aresults = [];\n      results.sort(sortByBulkSeq);\n      results.forEach(function(result) {\n        delete result._bulk_seq;\n        if (result.error) {\n          aresults.push(result);\n          return;\n        }\n        var metadata = result.metadata;\n        var rev = winningRev(metadata);\n\n        aresults.push({\n          ok: true,\n          id: metadata.id,\n          rev: rev\n        });\n\n        if (/_local/.test(metadata.id)) {\n          return;\n        }\n\n        var change = {\n          id: metadata.id,\n          seq: metadata.seq,\n          changes: collectLeaves(metadata.rev_tree),\n          doc: result.data\n        };\n        change.doc._rev = rev;\n\n        IdbPouch.Changes.emitChange(name, change);\n      });\n      call(callback, null, aresults);\n    }\n\n    function writeDoc(docInfo, callback) {\n      var err = null;\n      var recv = 0;\n\n      docInfo.data._id = docInfo.metadata.id;\n      docInfo.data._rev = docInfo.metadata.rev;\n\n      meta.updateSeq++;\n      var req = txn.objectStore(META_STORE).put(meta);\n\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\n        docInfo.data._deleted = true;\n      }\n\n      var attachments = docInfo.data._attachments ?\n        Object.keys(docInfo.data._attachments) : [];\n\n      for (var key in docInfo.data._attachments) {\n        if (!docInfo.data._attachments[key].stub) {\n          var data = docInfo.data._attachments[key].data;\n          var digest = 'md5-' + Crypto.MD5(data);\n          delete docInfo.data._attachments[key].data;\n          docInfo.data._attachments[key].digest = digest;\n          saveAttachment(docInfo, digest, data, function(err) {\n            recv++;\n            collectResults(err);\n          });\n        } else {\n          recv++;\n          collectResults();\n        }\n      }\n\n      if (!attachments.length) {\n        finish();\n      }\n\n      function collectResults(attachmentErr) {\n        if (!err) {\n          if (attachmentErr) {\n            err = attachmentErr;\n            call(callback, err);\n          } else if (recv == attachments.length) {\n            finish();\n          }\n        }\n      }\n\n      function finish() {\n        var dataReq = txn.objectStore(BY_SEQ_STORE).put(docInfo.data);\n        dataReq.onsuccess = function(e) {\n          if (Pouch.DEBUG)\n            console.log(name + ': Wrote Document ', docInfo.metadata.id);\n          docInfo.metadata.seq = e.target.result;\n          // Current _rev is calculated from _rev_tree on read\n          delete docInfo.metadata.rev;\n          var metaDataReq = txn.objectStore(DOC_STORE).put(docInfo.metadata);\n          metaDataReq.onsuccess = function() {\n            results.push(docInfo);\n            call(callback);\n          };\n        };\n      }\n    }\n\n    function updateDoc(oldDoc, docInfo) {\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\n\n      var inConflict = (isDeleted(oldDoc) && isDeleted(docInfo.metadata)) ||\n        (!isDeleted(oldDoc) && newEdits && merged.conflicts !== 'new_leaf');\n\n      if (inConflict) {\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n        return processDocs();\n      }\n\n      docInfo.metadata.rev_tree = merged.tree;\n      writeDoc(docInfo, processDocs);\n    }\n\n    function insertDoc(docInfo) {\n      // Cant insert new deleted documents\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\n        results.push(Pouch.Errors.MISSING_DOC);\n        return processDocs();\n      }\n      writeDoc(docInfo, processDocs);\n    }\n\n    // Insert sequence number into the error so we can sort later\n    function makeErr(err, seq) {\n      err._bulk_seq = seq;\n      return err;\n    }\n\n    function saveAttachment(docInfo, digest, data, callback) {\n      if (storeAttachmentsInIDB) {\n        var objectStore = txn.objectStore(ATTACH_STORE);\n        var getReq = objectStore.get(digest).onsuccess = function(e) {\n          var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\n          var newAtt = {digest: digest, body: data};\n\n          if (e.target.result) {\n            if (e.target.result.refs) {\n              // only update references if this attachment already has them\n              // since we cannot migrate old style attachments here without\n              // doing a full db scan for references\n              newAtt.refs = e.target.result.refs;\n              newAtt.refs[ref] = true;\n            }\n          } else {\n            newAtt.refs = {};\n            newAtt.refs[ref] = true;\n          }\n\n          var putReq = objectStore.put(newAtt).onsuccess = function(e) {\n            call(callback);\n          };\n          putReq.onerror = putReq.ontimeout = idbError(callback);\n        };\n        getReq.onerror = getReq.ontimeout = idbError(callback);\n      } else {\n        // right now fire and forget, needs cleaned\n        writeAttachmentToFile(digest,data);\n        call(callback);\n      }\n    }\n\n    var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, META_STORE], IDBTransaction.READ_WRITE);\n    txn.onerror = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n\n    processDocs();\n\n  };\n\n  function sortByBulkSeq(a, b) {\n    return a._bulk_seq - b._bulk_seq;\n  }\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api.get = function idb_get(id, opts, callback) {\n\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    id = parseDocId(id);\n    if (id.attachmentId !== '') {\n      return api.getAttachment(id, {decode: true}, callback);\n    }\n\n    var result;\n    var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n    txn.oncomplete = function() {\n      if ('error' in result) {\n        call(callback, result);\n      } else {\n        call(callback, null, result);\n      }\n    };\n\n    txn.objectStore(DOC_STORE).get(id.docId).onsuccess = function(e) {\n      var metadata = e.target.result;\n      if (!e.target.result || (isDeleted(metadata, opts.rev) && !opts.rev)) {\n        result = Pouch.Errors.MISSING_DOC;\n        return;\n      }\n\n      var rev = winningRev(metadata);\n      var key = opts.rev ? opts.rev : rev;\n      var index = txn.objectStore(BY_SEQ_STORE).index('_rev');\n\n      index.get(key).onsuccess = function(e) {\n        var doc = e.target.result;\n        if (opts.revs) {\n          var path = arrayFirst(rootToLeaf(metadata.rev_tree), function(arr) {\n            return arr.ids.indexOf(doc._rev.split('-')[1]) !== -1;\n          });\n          path.ids.reverse();\n          doc._revisions = {\n            start: (path.pos + path.ids.length) - 1,\n            ids: path.ids\n          };\n        }\n        if (opts.revs_info) {\n          doc._revs_info = metadata.rev_tree.reduce(function(prev, current) {\n            return prev.concat(collectRevs(current));\n          }, []);\n        }\n        if (opts.conflicts) {\n          var conflicts = collectConflicts(metadata.rev_tree);\n          if (conflicts.length) {\n            doc._conflicts = conflicts;\n          }\n        }\n\n        if (opts.attachments && doc._attachments) {\n          var attachments = Object.keys(doc._attachments);\n          var recv = 0;\n\n          attachments.forEach(function(key) {\n            api.getAttachment(doc._id + '/' + key, {txn: txn}, function(err, data) {\n              doc._attachments[key].data = data;\n\n              if (++recv === attachments.length) {\n                result = doc;\n              }\n            });\n          });\n        } else {\n          if (doc._attachments){\n            for (var key in doc._attachments) {\n              doc._attachments[key].stub = true;\n            }\n          }\n          result = doc;\n        }\n      };\n    };\n  };\n\n  api.getAttachment = function(id, opts, callback) {\n    if (opts instanceof Function) {\n      callback = opts;\n      opts = {};\n    }\n    if (typeof id === 'string') {\n      id = parseDocId(id);\n    }\n\n    var result;\n    var txn;\n\n    // This can be called while we are in a current transaction, pass the context\n    // along and dont wait for the transaction to complete here.\n    if ('txn' in opts) {\n      txn = opts.txn;\n    } else {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      txn.oncomplete = function() { call(callback, null, result); }\n    }\n\n    txn.objectStore(DOC_STORE).get(id.docId).onsuccess = function(e) {\n      var metadata = e.target.result;\n      var bySeq = txn.objectStore(BY_SEQ_STORE);\n      bySeq.get(metadata.seq).onsuccess = function(e) {\n        var attachment = e.target.result._attachments[id.attachmentId];\n        var digest = attachment.digest;\n        var type = attachment.content_type\n\n        function postProcessDoc(data) {\n          if (opts.decode) {\n            data = atob(data);\n          }\n          return data;\n        }\n\n        if (storeAttachmentsInIDB) {\n          txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function(e) {\n            var data = e.target.result.body;\n            result = postProcessDoc(data);\n            if ('txn' in opts) {\n              call(callback, null, result);\n            }\n          }\n        } else {\n          // This will be buggy, it will cause the transaction to be closed\n          // as we will be returning to the event loop waiting on the file to\n          // read, switch back to idb asap\n          readAttachmentFromFile(digest, function(data) {\n            result = postProcessDoc(data);\n            if ('txn' in opts) {\n              call(callback, null, result);\n            }\n          });\n        }\n      };\n    }\n    return;\n  }\n\n  api.put = function(doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (!doc || !('_id' in doc)) {\n      return call(callback, Pouch.Errors.MISSING_ID);\n    }\n    return api.bulkDocs({docs: [doc]}, opts, yankError(callback));\n  }\n\n  api.post = function idb_put(doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return api.bulkDocs({docs: [doc]}, opts, yankError(callback));\n  };\n\n  api.putAttachment = function idb_putAttachment(id, rev, doc, type, callback) {\n    id = parseDocId(id);\n    api.get(id.docId, {attachments: true}, function(err, obj) {\n      obj._attachments || (obj._attachments = {});\n      obj._attachments[id.attachmentId] = {\n        content_type: type,\n        data: btoa(doc)\n      }\n      api.put(obj, callback);\n    });\n  };\n\n  api.remove = function idb_remove(doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts.was_delete = true;\n    var newDoc = extend(true, {}, doc);\n    newDoc._deleted = true;\n    return api.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n  };\n\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\n    id = parseDocId(id);\n    api.get(id.docId, function(err, obj) {\n      if (err) {\n        call(callback, err);\n        return;\n      }\n\n      if (obj._rev != rev) {\n        call(callback, Pouch.Errors.REV_CONFLICT);\n        return;\n      }\n\n      obj._attachments || (obj._attachments = {});\n      delete obj._attachments[id.attachmentId];\n      api.put(obj, callback);\n    });\n  };\n\n  api.allDocs = function idb_allDocs(opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    var keyRange = start && end ? IDBKeyRange.bound(start, end, false, false)\n      : start ? IDBKeyRange.lowerBound(start, true)\n      : end ? IDBKeyRange.upperBound(end) : null;\n\n    var result;\n    var transaction = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');\n    transaction.oncomplete = function() { callback(null, result); };\n\n    var oStore = transaction.objectStore(DOC_STORE);\n    var oCursor = descending ? oStore.openCursor(keyRange, descending)\n      : oStore.openCursor(keyRange);\n    var results = [];\n    oCursor.onsuccess = function(e) {\n      if (!e.target.result) {\n        result = {\n          total_rows: results.length,\n          rows: results\n        };\n        return;\n      }\n      var cursor = e.target.result;\n      function allDocsInner(metadata, data) {\n        if (/_local/.test(metadata.id)) {\n          return cursor['continue']();\n        }\n        if (!isDeleted(metadata)) {\n          var doc = {\n            id: metadata.id,\n            key: metadata.id,\n            value: {\n              rev: winningRev(metadata)\n            }\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev(metadata);\n            if (opts.conflicts) {\n              doc.doc._conflicts = collectConflicts(metadata.rev_tree);\n            }\n          }\n          results.push(doc);\n        }\n        cursor['continue']();\n      }\n\n      if (!opts.include_docs) {\n        allDocsInner(cursor.value);\n      } else {\n        var index = transaction.objectStore(BY_SEQ_STORE);\n        index.get(cursor.value.seq).onsuccess = function(event) {\n          allDocsInner(cursor.value, event.target.result);\n        };\n      }\n    }\n  };\n\n  // Looping through all the documents in the database is a terrible idea\n  // easiest to implement though, should probably keep a counter\n  api.info = function idb_info(callback) {\n    var count = 0;\n    var result;\n    var txn = idb.transaction([DOC_STORE], 'readonly');\n\n    txn.oncomplete = function() {\n      callback(null, result);\n    };\n\n    txn.objectStore(DOC_STORE).openCursor().onsuccess = function(e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          result = {\n            db_name: name,\n            doc_count: count,\n            update_seq: meta.updateSeq\n          };\n          return;\n        }\n        if (cursor.value.deleted !== true) {\n          count++;\n        }\n        cursor['continue']();\n      };\n  };\n\n  api.revsDiff = function idb_revsDiff(req, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ids = Object.keys(req);\n    var count = 0;\n    var missing = {};\n\n    function readDoc(err, doc, id) {\n      req[id].map(function(revId) {\n        var matches = function(x) { return x.rev !== revId; };\n        if (!doc || doc._revs_info.every(matches)) {\n          if (!missing[id]) {\n            missing[id] = {missing: []};\n          }\n          missing[id].missing.push(revId);\n        }\n      });\n\n      if (++count === ids.length) {\n        return call(callback, null, missing);\n      }\n    }\n\n    ids.map(function(id) {\n      api.get(id, {revs_info: true}, function(err, doc) {\n        readDoc(err, doc, id);\n      });\n    });\n  };\n\n  api.changes = function idb_changes(opts) {\n\n    if (!opts.seq) {\n      opts.seq = 0;\n    }\n    if (opts.since) {\n      opts.seq = opts.since;\n    }\n\n    if (Pouch.DEBUG)\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    var results = [], resultIndices = {}, dedupResults = [];\n    var id = name + ':' + Math.uuid();\n    var txn;\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      var filterName = opts.filter.split('/');\n      api.get('_design/' + filterName[0], function(err, ddoc) {\n        var filter = eval('(function() { return ' +\n                          ddoc.filters[filterName[1]] + ' })()');\n        opts.filter = filter;\n        fetchChanges();\n      });\n    } else {\n      fetchChanges();\n    }\n\n    function fetchChanges() {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE]);\n      txn.oncomplete = onTxnComplete;\n      var req = descending\n        ? txn.objectStore(BY_SEQ_STORE)\n          .openCursor(IDBKeyRange.lowerBound(opts.seq, true), descending)\n        : txn.objectStore(BY_SEQ_STORE)\n          .openCursor(IDBKeyRange.lowerBound(opts.seq, true));\n      req.onsuccess = onsuccess;\n      req.onerror = onerror;\n    }\n\n    function onsuccess(event) {\n      if (!event.target.result) {\n        if (opts.continuous && !opts.cancelled) {\n          IdbPouch.Changes.addListener(name, id, opts);\n        }\n\n        // Filter out null results casued by deduping\n        for (var i = 0, l = results.length; i < l; i++ ) {\n          var result = results[i];\n          if (result) dedupResults.push(result);\n        }\n        return false;\n      }\n\n      var cursor = event.target.result;\n\n      // Try to pre-emptively dedup to save us a bunch of idb calls\n      var changeId = cursor.value._id, changeIdIndex = resultIndices[changeId];\n      if (changeIdIndex !== undefined) {\n        results[changeIdIndex].seq = cursor.key; // update so it has the later sequence number\n        results.push(results[changeIdIndex]);\n        results[changeIdIndex] = null;\n        resultIndices[changeId] = results.length - 1;\n        return cursor['continue']();\n      }\n\n      var index = txn.objectStore(DOC_STORE);\n      index.get(cursor.value._id).onsuccess = function(event) {\n        var metadata = event.target.result;\n        if (/_local/.test(metadata.id)) {\n          return cursor['continue']();\n        }\n\n        var mainRev = winningRev(metadata);\n        var index = txn.objectStore(BY_SEQ_STORE).index('_rev');\n        index.get(mainRev).onsuccess = function(docevent) {\n          var doc = docevent.target.result;\n          var changeList = [{rev: mainRev}]\n          if (opts.style === 'all_docs') {\n          //  console.log('all docs', changeList, collectLeaves(metadata.rev_tree));\n            changeList = collectLeaves(metadata.rev_tree);\n          }\n          var change = {\n            id: metadata.id,\n            seq: cursor.key,\n            changes: changeList,\n            doc: doc,\n          };\n          if (isDeleted(metadata, mainRev)) {\n            change.deleted = true;\n          }\n          if (opts.conflicts) {\n            change.doc._conflicts = collectConflicts(metadata.rev_tree);\n          }\n\n          // Dedupe the changes feed\n          var changeId = change.id, changeIdIndex = resultIndices[changeId];\n          if (changeIdIndex !== undefined) {\n            results[changeIdIndex] = null;\n          }\n          results.push(change);\n          resultIndices[changeId] = results.length - 1;\n          cursor['continue']();\n        }\n      };\n    };\n\n    function onTxnComplete() {\n      dedupResults.map(function(c) {\n        if (opts.filter && !opts.filter.apply(this, [c.doc])) {\n          return;\n        }\n        if (!opts.include_docs) {\n          delete c.doc;\n        }\n        call(opts.onChange, c);\n      });\n      if (!opts.continuous || (opts.continuous && !opts.cancelled)) {\n        call(opts.complete, null, {results: dedupResults});\n      }\n    };\n\n    function onerror(error) {\n      if (opts.continuous && !opts.cancelled) {\n        IdbPouch.Changes.addListener(name, id, opts);\n      }\n      else {\n        call(opts.complete);\n      }\n    };\n\n    if (opts.continuous) {\n      return {\n        cancel: function() {\n          if (Pouch.DEBUG)\n            console.log(name + ': Cancel Changes Feed');\n          opts.cancelled = true;\n          IdbPouch.Changes.removeListener(name, id);\n        }\n      }\n    }\n  };\n\n  api.replicate = {};\n\n  api.replicate.from = function idb_replicate_from(url, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(url, api, opts, callback);\n  };\n\n  api.replicate.to = function idb_replicate_to(dbName, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(api, dbName, opts, callback);\n  };\n\n  // Functions for reading and writing an attachment in the html5 file system\n  // instead of idb\n  function toArray(list) {\n    return Array.prototype.slice.call(list || [], 0);\n  }\n  function fileErrorHandler(e) {\n    console.error('File system error',e);\n  }\n\n  //Delete attachments that are no longer referenced by any existing documents\n  function deleteOrphanedFiles(currentQuota){\n    api.allDocs({include_docs:true},function(err, response) {\n      window.requestFileSystem(window.PERSISTENT, currentQuota, function(fs){\n      var dirReader = fs.root.createReader();\n      var entries = [];\n      var docRows = response.rows;\n\n      // Call the reader.readEntries() until no more results are returned.\n      var readEntries = function() {\n        dirReader.readEntries (function(results) {\n          if (!results.length) {\n            for (var i in entries){\n              var entryIsReferenced = false;\n              for (var k in docRows){\n                if (docRows[k].doc){\n                  var aDoc = docRows[k].doc;\n                  if (aDoc._attachments) {\n                    for (var j in aDoc._attachments) {\n                      if (aDoc._attachments[j].digest==entries[i].name) {\n                        entryIsReferenced = true;\n                      }\n                    };\n                  }\n                  if (entryIsReferenced) break;\n                }\n              };\n              if (!entryIsReferenced){\n                entries[i].remove(function() {\n                  if (Pouch.DEBUG)\n                    console.log(\"Removed orphaned attachment: \"+entries[i].name);\n                }, fileErrorHandler);\n              }\n            };\n          } else {\n            entries = entries.concat(toArray(results));\n            readEntries();\n          }\n        }, fileErrorHandler);\n      };\n\n      readEntries(); // Start reading dirs.\n\n      }, fileErrorHandler);\n    });\n  }\n\n  function writeAttachmentToFile(digest, data, type){\n    //Check the current file quota and increase it if necessary\n    window.storageInfo.queryUsageAndQuota(window.PERSISTENT, function(currentUsage, currentQuota) {\n      var newQuota = currentQuota;\n      if (currentQuota == 0){\n        newQuota = 1000*1024*1024; //start with 1GB\n      }else if ((currentUsage/currentQuota) > 0.8){\n        deleteOrphanedFiles(currentQuota); //delete old attachments when we hit 80% usage\n      }else if ((currentUsage/currentQuota) > 0.9){\n        newQuota=2*currentQuota; //double the quota when we hit 90% usage\n      }\n\n      if (Pouch.DEBUG)\n        console.log(\"Current file quota: \"+currentQuota+\", current usage:\"+currentUsage+\", new quota will be: \"+newQuota);\n\n      //Ask for file quota. This does nothing if the proper quota size has already been granted.\n      window.storageInfo.requestQuota(window.PERSISTENT, newQuota, function(grantedBytes) {\n        window.storageInfo.queryUsageAndQuota(window.PERSISTENT, function(currentUsage, currentQuota) {\n          window.requestFileSystem(window.PERSISTENT, currentQuota, function(fs){\n            fs.root.getFile(digest, {create: true}, function(fileEntry) {\n              fileEntry.createWriter(function(fileWriter) {\n                fileWriter.onwriteend = function(e) {\n                  if (Pouch.DEBUG)\n                    console.log('Wrote attachment');\n                };\n                fileWriter.onerror = function(e) {\n                  console.error('File write failed: ' + e.toString());\n                };\n                var blob = new Blob([data], {type: type});\n                fileWriter.write(blob);\n              }, fileErrorHandler);\n            }, fileErrorHandler);\n          }, fileErrorHandler);\n        }, fileErrorHandler);\n      }, fileErrorHandler);\n    },fileErrorHandler);\n  }\n\n  function readAttachmentFromFile(digest, callback){\n    window.storageInfo.queryUsageAndQuota(window.PERSISTENT, function(currentUsage, currentQuota) {\n      window.requestFileSystem(window.PERSISTENT, currentQuota, function(fs){\n        fs.root.getFile(digest, {}, function(fileEntry) {\n          fileEntry.file(function(file) {\n            var reader = new FileReader();\n            reader.onloadend = function(e) {\n              data = this.result;\n              if (Pouch.DEBUG)\n                console.log(\"Read attachment\");\n              callback(data);\n            };\n            reader.readAsBinaryString(file);\n          }, fileErrorHandler);\n        }, fileErrorHandler);\n      }, fileErrorHandler);\n    }, fileErrorHandler);\n  }\n\n  api.close = function(callback) {\n    if (idb === null) {\n      return call(callback, Pouch.Errors.NOT_OPEN);\n    }\n\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    call(callback, null);\n  };\n\n  return api;\n};\n\nIdbPouch.valid = function idb_valid() {\n  if (!document.location.host) {\n    console.error('indexedDB cannot be used in pages served from the filesystem');\n  }\n  return !!window.indexedDB && !!document.location.host;\n};\n\nIdbPouch.destroy = function idb_destroy(name, callback) {\n  if (Pouch.DEBUG)\n    console.log(name + ': Delete Database');\n  IdbPouch.Changes.clearListeners(name);\n  var req = indexedDB.deleteDatabase(name);\n\n  req.onsuccess = function() {\n    call(callback, null);\n  };\n\n  req.onerror = idbError(callback);\n};\n\nIdbPouch.Changes = (function() {\n\n  var api = {};\n  var listeners = {};\n\n  api.addListener = function(db, id, opts) {\n    if (!listeners[db]) {\n      listeners[db] = {};\n    }\n    listeners[db][id] = opts;\n  }\n\n  api.removeListener = function(db, id) {\n    delete listeners[db][id];\n  }\n\n  api.clearListeners = function(db) {\n    delete listeners[db];\n  }\n\n  api.emitChange = function(db, change) {\n    if (!listeners[db]) {\n      return;\n    }\n    for (var i in listeners[db]) {\n      var opts = listeners[db][i];\n      if (opts.filter && !opts.filter.apply(this, [change.doc])) {\n        return;\n      }\n      if (!opts.include_docs) {\n        delete change.doc;\n      }\n      opts.onChange.apply(opts.onChange, [change]);\n    }\n  }\n\n  return api;\n})();\n\nPouch.adapter('idb', IdbPouch);\n\n\"use strict\";\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar POUCH_VERSION = 1;\nvar POUCH_SIZE = 5 * 1024 * 1024;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE = quote('attach-store');\nvar META_STORE = quote('metadata-store');\n\nvar unknownError = function(callback) {\n  return function(event) {\n    call(callback, {\n      status: 500,\n      error: event.type,\n      reason: event.target\n    });\n  };\n};\n\nvar webSqlPouch = function(opts, callback) {\n\n  var api = {};\n  var update_seq = 0;\n  var name = opts.name;\n\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\n  if (!db) {\n    return call(callback, Pouch.Errors.UNKNOWN_ERROR);\n  }\n\n  function dbCreated() {\n    callback(null, api);\n  }\n\n  db.transaction(function (tx) {\n    var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE +\n      ' (update_seq)';\n    var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE +\n      ' (digest, json)';\n    var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE +\n      ' (id unique, seq, json, winningseq)';\n    var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE +\n      ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, rev UNIQUE, json)';\n\n    tx.executeSql(attach);\n    tx.executeSql(doc);\n    tx.executeSql(seq);\n    tx.executeSql(meta);\n\n    var sql = 'SELECT update_seq FROM ' + META_STORE;\n    tx.executeSql(sql, [], function(tx, result) {\n      if (!result.rows.length) {\n        var initSeq = 'INSERT INTO ' + META_STORE + ' (update_seq) VALUES (?)';\n        tx.executeSql(initSeq, [0]);\n        return;\n      }\n      update_seq = result.rows.item(0).update_seq;\n    });\n  }, unknownError(callback), dbCreated);\n\n  api.type = function() {\n    return 'websql';\n  };\n\n  api.id = function() {\n    var id = localJSON.get(name + '_id', null);\n    if (id === null) {\n      id = Math.uuid();\n      localJSON.set(name + '_id', id);\n    }\n    return id;\n  };\n\n  api.info = function(callback) {\n    db.transaction(function(tx) {\n      var sql = 'SELECT COUNT(id) AS count FROM ' + DOC_STORE;\n      tx.executeSql(sql, [], function(tx, result) {\n        callback(null, {\n          db_name: name,\n          doc_count: result.rows.item(0).count,\n          update_seq: update_seq\n        });\n      });\n    });\n  };\n\n  api.bulkDocs = function idb_bulkDocs(req, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!opts) {\n      opts = {};\n    }\n\n    if (!req.docs) {\n      return call(callback, Pouch.Errors.MISSING_BULK_DOCS);\n    }\n\n    var newEdits = 'new_edits' in opts ? opts.new_edits : true;\n    var userDocs = extend(true, [], req.docs);\n\n    // Parse the docs, give them a sequence number for the result\n    var docInfos = userDocs.map(function(doc, i) {\n      var newDoc = parseDoc(doc, newEdits);\n      newDoc._bulk_seq = i;\n      if (doc._deleted) {\n        if (!newDoc.metadata.deletions) {\n          newDoc.metadata.deletions = {};\n        }\n        newDoc.metadata.deletions[doc._rev.split('-')[1]] = true;\n      }\n      return newDoc;\n    });\n\n    var tx;\n    var results = [];\n    var docs = [];\n    var fetchedDocs = {};\n\n    // Group multiple edits to the same document\n    docInfos.forEach(function(docInfo) {\n      if (docInfo.error) {\n        return results.push(docInfo);\n      }\n      if (!docs.length || docInfo.metadata.id !== docs[0].metadata.id) {\n        return docs.unshift(docInfo);\n      }\n      // We mark subsequent bulk docs with a duplicate id as conflicts\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n    });\n\n    function sortByBulkSeq(a, b) {\n      return a._bulk_seq - b._bulk_seq;\n    }\n\n    function complete(event) {\n      var aresults = [];\n      results.sort(sortByBulkSeq);\n      results.forEach(function(result) {\n        delete result._bulk_seq;\n        if (result.error) {\n          aresults.push(result);\n          return;\n        }\n        var metadata = result.metadata;\n        var rev = winningRev(metadata);\n\n        aresults.push({\n          ok: true,\n          id: metadata.id,\n          rev: rev\n        });\n\n        if (/_local/.test(metadata.id)) {\n          return;\n        }\n\n        var change = {\n          id: metadata.id,\n          seq: metadata.seq,\n          changes: collectLeaves(metadata.rev_tree),\n          doc: result.data\n        };\n        change.doc._rev = rev;\n        update_seq++;\n        var sql = 'UPDATE ' + META_STORE + ' SET update_seq=?';\n        tx.executeSql(sql, [update_seq], function() {\n          webSqlPouch.Changes.emitChange(name, change);\n        });\n      });\n      call(callback, null, aresults);\n    }\n\n    function writeDoc(docInfo, callback, isUpdate) {\n      var err = null;\n      var recv = 0;\n\n      docInfo.data._id = docInfo.metadata.id;\n      docInfo.data._rev = docInfo.metadata.rev;\n\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\n        docInfo.data._deleted = true;\n      }\n\n      var attachments = docInfo.data._attachments ?\n        Object.keys(docInfo.data._attachments) : [];\n\n      for (var key in docInfo.data._attachments) {\n        if (!docInfo.data._attachments[key].stub) {\n          var data = docInfo.data._attachments[key].data;\n          var digest = 'md5-' + Crypto.MD5(data);\n          delete docInfo.data._attachments[key].data;\n          docInfo.data._attachments[key].digest = digest;\n          saveAttachment(docInfo, digest, data, function(err) {\n            recv++;\n            collectResults(err);\n          });\n        } else {\n          recv++;\n          collectResults();\n        }\n      }\n\n      if (!attachments.length) {\n        finish();\n      }\n\n      function collectResults(attachmentErr) {\n        if (!err) {\n          if (attachmentErr) {\n            err = attachmentErr;\n            call(callback, err);\n          } else if (recv == attachments.length) {\n            finish();\n          }\n        }\n      }\n\n      function dataWritten(tx, result) {\n        var seq = docInfo.metadata.seq = result.insertId;\n        delete docInfo.metadata.rev;\n\n        var mainRev = winningRev(docInfo.metadata);\n\n        var sql = isUpdate ?\n          'UPDATE ' + DOC_STORE + ' SET seq=?, json=?, winningseq=(SELECT seq FROM ' + BY_SEQ_STORE + ' WHERE rev=?) WHERE id=?' :\n          'INSERT INTO ' + DOC_STORE + ' (id, seq, winningseq, json) VALUES (?, ?, ?, ?);';\n        var params = isUpdate ?\n          [seq, JSON.stringify(docInfo.metadata), mainRev, docInfo.metadata.id] :\n          [docInfo.metadata.id, seq, seq, JSON.stringify(docInfo.metadata)];\n        tx.executeSql(sql, params, function(tx, result) {\n          results.push(docInfo);\n          call(callback, null);\n        });\n      }\n\n      function finish() {\n        var data = docInfo.data;\n        var sql = 'INSERT INTO ' + BY_SEQ_STORE + ' (rev, json) VALUES (?, ?);';\n        tx.executeSql(sql, [data._rev, JSON.stringify(data)], dataWritten);\n      }\n    }\n\n    function updateDoc(oldDoc, docInfo) {\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\n      var inConflict = (isDeleted(oldDoc) && isDeleted(docInfo.metadata)) ||\n        (!isDeleted(oldDoc) && newEdits && merged.conflicts !== 'new_leaf');\n\n      if (inConflict) {\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\n        return processDocs();\n      }\n\n      docInfo.metadata.rev_tree = merged.tree;\n      writeDoc(docInfo, processDocs, true);\n    }\n\n    function insertDoc(docInfo) {\n      // Cant insert new deleted documents\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\n        results.push(Pouch.Errors.MISSING_DOC);\n        return processDocs();\n      }\n      writeDoc(docInfo, processDocs, false);\n    }\n\n    function processDocs() {\n      if (!docs.length) {\n        return complete();\n      }\n      var currentDoc = docs.shift();\n      var id = currentDoc.metadata.id;\n      if (id in fetchedDocs) {\n        updateDoc(fetchedDocs[id], currentDoc);\n      } else {\n        insertDoc(currentDoc);\n      }\n    }\n\n    // Insert sequence number into the error so we can sort later\n    function makeErr(err, seq) {\n      err._bulk_seq = seq;\n      return err;\n    }\n\n    function saveAttachment(docInfo, digest, data, callback) {\n      var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\n      var newAtt = {digest: digest, body: data};\n      var sql = 'SELECT * FROM ' + ATTACH_STORE + ' WHERE digest=?';\n      tx.executeSql(sql, [digest], function(tx, result) {\n        if (!result.rows.length) {\n          newAtt.refs = {};\n          newAtt.refs[ref] = true;\n          sql = 'INSERT INTO ' + ATTACH_STORE + '(digest, json) VALUES (?, ?)';\n          tx.executeSql(sql, [digest, JSON.stringify(newAtt)], function() {\n            call(callback, null);\n          });\n        } else {\n          newAtt.refs = JSON.parse(result.rows.item(0).json).refs;\n          sql = 'UPDATE ' + ATTACH_STORE + ' SET json=? WHERE digest=?';\n          tx.executeSql(sql, [JSON.stringify(newAtt), digest], function() {\n            call(callback, null);\n          });\n        }\n      });\n    }\n\n    function metadataFetched(tx, results) {\n      for (var j=0; j<results.rows.length; j++) {\n        var row = results.rows.item(j);\n        fetchedDocs[row.id] = JSON.parse(row.json);\n      }\n      processDocs();\n    }\n\n    db.transaction(function(txn) {\n      tx = txn;\n      var ids = '(' + docs.map(function(d) {\n        return quote(d.metadata.id);\n      }).join(',') + ')';\n      var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id IN ' + ids;\n      tx.executeSql(sql, [], metadataFetched);\n    }, unknownError(callback));\n  };\n\n  api.put = function(doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!doc || !('_id' in doc)) {\n      return call(callback, Pouch.Errors.MISSING_ID);\n    }\n    return api.bulkDocs({docs: [doc]}, opts, yankError(callback));\n  };\n\n  api.post = function idb_put(doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return api.bulkDocs({docs: [doc]}, opts, yankError(callback));\n  };\n\n  api.revsDiff = function idb_revsDiff(req, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ids = Object.keys(req);\n    var count = 0;\n    var missing = {};\n\n    function readDoc(err, doc, id) {\n      req[id].map(function(revId) {\n        var matches = function(x) { return x.rev !== revId; };\n        if (!doc || doc._revs_info.every(matches)) {\n          if (!missing[id]) {\n            missing[id] = {missing: []};\n          }\n          missing[id].missing.push(revId);\n        }\n      });\n\n      if (++count === ids.length) {\n        return call(callback, null, missing);\n      }\n    }\n\n    ids.map(function(id) {\n      api.get(id, {revs_info: true}, function(err, doc) {\n        readDoc(err, doc, id);\n      });\n    });\n  };\n\n  api.remove = function idb_remove(doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts.was_delete = true;\n    var newDoc = extend(true, {}, doc);\n    newDoc._deleted = true;\n    return api.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n  };\n\n  api.get = function(id, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    id = parseDocId(id);\n    if (id.attachmentId !== '') {\n      return api.getAttachment(id, {decode: true}, callback);\n    }\n\n    var result;\n    db.transaction(function(tx) {\n      var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id=?';\n      tx.executeSql(sql, [id.docId], function(tx, results) {\n        if (!results.rows.length) {\n          result = Pouch.Errors.MISSING_DOC;\n          return;\n        }\n        var metadata = JSON.parse(results.rows.item(0).json);\n        if (isDeleted(metadata, opts.rev) && !opts.rev) {\n          result = Pouch.Errors.MISSING_DOC;\n          return;\n        }\n\n        var rev = winningRev(metadata);\n        var key = opts.rev ? opts.rev : rev;\n        var sql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE rev=?';\n        tx.executeSql(sql, [key], function(tx, results) {\n          var doc = JSON.parse(results.rows.item(0).json);\n\n          if (opts.revs) {\n            var path = arrayFirst(rootToLeaf(metadata.rev_tree), function(arr) {\n              return arr.ids.indexOf(doc._rev.split('-')[1]) !== -1;\n            });\n            path.ids.reverse();\n            doc._revisions = {\n              start: (path.pos + path.ids.length) - 1,\n              ids: path.ids\n            };\n          }\n          if (opts.revs_info) {\n            doc._revs_info = metadata.rev_tree.reduce(function(prev, current) {\n              return prev.concat(collectRevs(current));\n            }, []);\n          }\n          if (opts.conflicts) {\n            var conflicts = collectConflicts(metadata.rev_tree);\n            if (conflicts.length) {\n              doc._conflicts = conflicts;\n            }\n          }\n\n          if (opts.attachments && doc._attachments) {\n            var attachments = Object.keys(doc._attachments);\n            var recv = 0;\n            attachments.forEach(function(key) {\n              api.getAttachment(doc._id + '/' + key, {txn: tx}, function(err, data) {\n                doc._attachments[key].data = data;\n                if (++recv === attachments.length) {\n                  result = doc;\n                }\n              });\n            });\n          } else {\n            if (doc._attachments){\n              for (var key in doc._attachments) {\n                doc._attachments[key].stub = true;\n              }\n            }\n            result = doc;\n          }\n        });\n      });\n    }, unknownError(callback), function() {\n      if ('error' in result) {\n        call(callback, result);\n      } else {\n        call(callback, null, result);\n      }\n    });\n  };\n\n  api.allDocs = function(opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    var results = [];\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\n      BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\n      BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\n      DOC_STORE + '.winningseq';\n\n    if (start) {\n      sql += ' WHERE ' + DOC_STORE + '.id >= \"' + start + '\"';\n    }\n    if (end) {\n      sql += (start ? ' AND ' : ' WHERE ') + DOC_STORE + '.id <= \"' + end + '\"';\n    }\n\n    sql += ' ORDER BY ' + DOC_STORE + '.id ' + (descending ? 'DESC' : 'ASC');\n\n    db.transaction(function(tx) {\n      tx.executeSql(sql, [], function(tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++ ) {\n          var doc = result.rows.item(i);\n          var metadata = JSON.parse(doc.metadata);\n          var data = JSON.parse(doc.data);\n          if (!(/_local/.test(metadata.id) || isDeleted(metadata))) {\n            var doc = {\n              id: metadata.id,\n              key: metadata.id,\n              value: {rev: winningRev(metadata)}\n            };\n            if (opts.include_docs) {\n              doc.doc = data;\n              doc.doc._rev = winningRev(metadata);\n              if (opts.conflicts) {\n                doc.doc._conflicts = collectConflicts(metadata.rev_tree);\n              }\n            }\n            results.push(doc);\n          }\n        }\n      });\n    }, unknownError(callback), function() {\n      call(callback, null, {\n        total_rows: results.length,\n        rows: results\n      });\n    });\n  }\n\n  api.changes = function idb_changes(opts) {\n\n    if (!opts.seq) {\n      opts.seq = 0;\n    }\n    if (opts.since) {\n      opts.seq = opts.since;\n    }\n\n    if (Pouch.DEBUG)\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    var results = [], resultIndices = {}, dedupResults = [];\n    var id = name + ':' + Math.uuid();\n    var txn;\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      var filterName = opts.filter.split('/');\n      api.get('_design/' + filterName[0], function(err, ddoc) {\n        var filter = eval('(function() { return ' +\n                          ddoc.filters[filterName[1]] + ' })()');\n        opts.filter = filter;\n        fetchChanges();\n      });\n    } else {\n      fetchChanges();\n    }\n\n    function fetchChanges() {\n      var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\n        BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\n        BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\n        DOC_STORE + '.winningseq WHERE ' + DOC_STORE + '.seq > ' + opts.seq +\n        ' ORDER BY ' + DOC_STORE + '.seq ' + (descending ? 'DESC' : 'ASC');\n\n      db.transaction(function(tx) {\n        tx.executeSql(sql, [], function(tx, result) {\n          for (var i = 0, l = result.rows.length; i < l; i++ ) {\n            var doc = result.rows.item(i);\n            var metadata = JSON.parse(doc.metadata);\n            if (!/_local/.test(metadata.id)) {\n              var change = {\n                id: metadata.id,\n                seq: doc.seq,\n                changes: collectLeaves(metadata.rev_tree),\n                doc: JSON.parse(doc.data),\n              };\n              change.doc._rev = winningRev(metadata);\n              if (isDeleted(metadata, change.doc._rev)) {\n                change.deleted = true;\n              }\n              if (opts.conflicts) {\n                change.doc._conflicts = collectConflicts(metadata.rev_tree);\n              }\n              results.push(change);\n            }\n          }\n          for (var i = 0, l = results.length; i < l; i++ ) {\n            var result = results[i];\n            if (result) dedupResults.push(result);\n          }\n          dedupResults.map(function(c) {\n            if (opts.filter && !opts.filter.apply(this, [c.doc])) {\n              return;\n            }\n            if (!opts.include_docs) {\n              delete c.doc;\n            }\n            call(opts.onChange, c);\n          });\n          \n          if (opts.continuous && !opts.cancelled) {\n            webSqlPouch.Changes.addListener(name, id, opts);\n          }\n          else {\n              call(opts.complete, null, {results: dedupResults});\n          }\n        });\n      });\n    }\n\n    if (opts.continuous) {\n      return {\n        cancel: function() {\n          if (Pouch.DEBUG)\n            console.log(name + ': Cancel Changes Feed');\n          opts.cancelled = true;\n          webSqlPouch.Changes.removeListener(name, id);\n        }\n      }\n    }\n  };\n\n  api.getAttachment = function(id, opts, callback) {\n    if (opts instanceof Function) {\n      callback = opts;\n      opts = {};\n    }\n    if (typeof id === 'string') {\n      id = parseDocId(id);\n    }\n\n    var res;\n    // This can be called while we are in a current transaction, pass the context\n    // along and dont wait for the transaction to complete here.\n    if ('txn' in opts) {\n      fetchAttachment(opts.txn);\n    } else {\n      db.transaction(fetchAttachment, unknownError(callback), function() {\n        call(callback, null, res);\n      });\n    }\n\n    function postProcessDoc(data) {\n      if (opts.decode) {\n        return atob(data);\n      }\n      return data;\n    }\n\n    function fetchAttachment(tx) {\n      var sql = 'SELECT ' + BY_SEQ_STORE + '.json AS data FROM ' + DOC_STORE +\n        ' JOIN ' + BY_SEQ_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' + DOC_STORE +\n        '.seq WHERE ' + DOC_STORE + '.id = \"' + id.docId + '\"' ;\n      tx.executeSql(sql, [], function(tx, result) {\n        var doc = JSON.parse(result.rows.item(0).data);\n        var attachment = doc._attachments[id.attachmentId];\n        var digest = attachment.digest;\n        var type = attachment.content_type;\n        var sql = 'SELECT * FROM ' + ATTACH_STORE + ' WHERE digest=?';\n        tx.executeSql(sql, [digest], function(tx, result) {\n          var data = JSON.parse(result.rows.item(0).json).body;\n          res = postProcessDoc(data);\n          if ('txn' in opts) {\n            call(callback, null, res);\n          }\n        });\n      });\n    }\n  }\n\n  // Everything below this are not dependant on the storage implementation\n  // and can be shared between the adapters instead of reimplemented in each\n  api.putAttachment = function idb_putAttachment(id, rev, doc, type, callback) {\n    id = parseDocId(id);\n    api.get(id.docId, {attachments: true}, function(err, obj) {\n      obj._attachments || (obj._attachments = {});\n      obj._attachments[id.attachmentId] = {\n        content_type: type,\n        data: btoa(doc)\n      }\n      api.put(obj, callback);\n    });\n  };\n\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\n    id = parseDocId(id);\n    api.get(id.docId, function(err, obj) {\n      if (err) {\n        call(callback, err);\n        return;\n      }\n\n      if (obj._rev != rev) {\n        call(callback, Pouch.Errors.REV_CONFLICT);\n        return;\n      }\n\n      obj._attachments || (obj._attachments = {});\n      delete obj._attachments[id.attachmentId];\n      api.put(obj, callback);\n    });\n  };\n\n  api.replicate = {};\n\n  api.replicate.from = function idb_replicate_from(url, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(url, api, opts, callback);\n  };\n\n  api.replicate.to = function idb_replicate_to(dbName, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return Pouch.replicate(api, dbName, opts, callback);\n  };\n}\n\nwebSqlPouch.valid = function() {\n  return !!window.openDatabase;\n};\n\nwebSqlPouch.destroy = function(name, callback) {\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\n  localJSON.set(name + '_id', null);\n  db.transaction(function (tx) {\n    tx.executeSql('DROP TABLE IF EXISTS ' + DOC_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + BY_SEQ_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + ATTACH_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + META_STORE, []);\n  }, unknownError(callback), function() {\n    call(callback, null);\n  });\n};\n\n\n// This is shared exactly with the idb adapter, extract into utils\nwebSqlPouch.Changes = (function() {\n\n  var api = {};\n  var listeners = {};\n\n  api.addListener = function(db, id, opts) {\n    if (!listeners[db]) {\n      listeners[db] = {};\n    }\n    listeners[db][id] = opts;\n  }\n\n  api.removeListener = function(db, id) {\n    delete listeners[db][id];\n  }\n\n  api.clearListeners = function(db) {\n    delete listeners[db];\n  }\n\n  api.emitChange = function(db, change) {\n    if (!listeners[db]) {\n      return;\n    }\n    for (var i in listeners[db]) {\n      var opts = listeners[db][i];\n      if (opts.filter && !opts.filter.apply(this, [change.doc])) {\n        return;\n      }\n      if (!opts.include_docs) {\n        delete change.doc;\n      }\n      opts.onChange.apply(opts.onChange, [change]);\n    }\n  }\n\n  return api;\n})();\n\nPouch.adapter('websql', webSqlPouch);\n\n/*global Pouch: true */\n\n\"use strict\";\n\n// This is the first implementation of a basic plugin, we register the\n// plugin object with pouch and it is mixin'd to each database created\n// (regardless of adapter), adapters can override plugins by providing\n// their own implementation. functions on the plugin object that start\n// with _ are reserved function that are called by pouchdb for special\n// notifications.\n\n// If we wanted to store incremental views we can do it here by listening\n// to the changes feed (keeping track of our last update_seq between page loads)\n// and storing the result of the map function (possibly using the upcoming\n// extracted adapter functions)\n\nvar MapReduce = function(db) {\n\n  function viewQuery(fun, options) {\n    if (!options.complete) {\n      return;\n    }\n\n    function sum(values) {\n      return values.reduce(function(a, b) { return a + b; }, 0);\n    }\n\n    var results = [];\n    var current = null;\n    var num_started= 0;\n    var completed= false;\n\n    var emit = function(key, val) {\n      var viewRow = {\n        id: current.doc._id,\n        key: key,\n        value: val\n      }; \n\n      if (options.startkey && Pouch.collate(key, options.startkey) < 0) return;\n      if (options.endkey && Pouch.collate(key, options.endkey) > 0) return;\n      if (options.key && Pouch.collate(key, options.key) !== 0) return;\n      num_started++;\n      if (options.include_docs) {\n        //in this special case, join on _id (issue #106)\n        if (val && typeof val === 'object' && val._id){\n          db.get(val._id,\n              function(_, joined_doc){\n                if (joined_doc) {\n                  viewRow.doc = joined_doc;\n                }\n                results.push(viewRow);\n                checkComplete();\n              });\n          return;\n        } else {\n          viewRow.doc = current.doc;\n        }\n      }\n      results.push(viewRow);\n    };\n\n    // ugly way to make sure references to 'emit' in map/reduce bind to the\n    // above emit\n    eval('fun.map = ' + fun.map.toString() + ';');\n    if (fun.reduce) {\n      eval('fun.reduce = ' + fun.reduce.toString() + ';');\n    }\n\n    // exclude  _conflicts key by default\n    // or to use options.conflicts if it's set when called by db.query\n    var conflicts = ('conflicts' in options ? options.conflicts : false);\n\n    //only proceed once all documents are mapped and joined\n    var checkComplete= function(){\n      if (completed && results.length == num_started){\n        results.sort(function(a, b) {\n          return Pouch.collate(a.key, b.key);\n        });\n        if (options.descending) {\n          results.reverse();\n        }\n        if (options.reduce === false) {\n          return options.complete(null, {rows: results});\n        }\n\n        var groups = [];\n        results.forEach(function(e) {\n          var last = groups[groups.length-1] || null;\n          if (last && Pouch.collate(last.key[0][0], e.key) === 0) {\n            last.key.push([e.key, e.id]);\n            last.value.push(e.value);\n            return;\n          }\n          groups.push({key: [[e.key, e.id]], value: [e.value]});\n        });\n        groups.forEach(function(e) {\n          e.value = fun.reduce(e.key, e.value) || null;\n          e.key = e.key[0][0];\n        });\n        options.complete(null, {rows: groups});\n      }\n    }\n\n    db.changes({\n      conflicts: conflicts,\n      include_docs: true,\n      onChange: function(doc) {\n        if (!('deleted' in doc)) {\n          current = {doc: doc.doc};\n          fun.map.call(this, doc.doc);\n        }\n      },\n      complete: function() {\n        completed= true;\n        checkComplete();\n      }\n    });\n  }\n\n  function httpQuery(fun, opts, callback) {\n\n    // List of parameters to add to the PUT request\n    var params = [];\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    if (typeof opts.reduce !== 'undefined') {\n      params.push('reduce=' + opts.reduce);\n    }\n    if (typeof opts.include_docs !== 'undefined') {\n      params.push('include_docs=' + opts.include_docs);\n    }\n    if (typeof opts.limit !== 'undefined') {\n      params.push('limit=' + opts.limit);\n    }\n    if (typeof opts.descending !== 'undefined') {\n      params.push('descending=' + opts.descending);\n    }\n    if (typeof opts.startkey !== 'undefined') {\n      params.push('startkey=' + encodeURIComponent(JSON.stringify(opts.startkey)));\n    }\n    if (typeof opts.endkey !== 'undefined') {\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\n    }\n    if (typeof opts.key !== 'undefined') {\n      params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = fun.split('/');\n      db.request({\n        method:'GET',\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params\n      }, callback);\n      return;\n    }\n\n    // We are using a temporary view, terrible for performance but good for testing\n    var queryObject = JSON.parse(JSON.stringify(fun, function(key, val) {\n      if (typeof val === 'function') {\n        return val + ''; // implicitly `toString` it\n      }\n      return val;\n    }));\n\n    db.request({\n      method:'POST',\n      url: '_temp_view' + params,\n      body: queryObject\n    }, callback);\n  }\n\n  function query(fun, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (callback) {\n      opts.complete = callback;\n    }\n\n    if (db.type() === 'http') {\n      return httpQuery(fun, opts, callback);\n    }\n\n    if (typeof fun === 'object') {\n      return viewQuery(fun, opts);\n    }\n\n    var parts = fun.split('/');\n    db.get('_design/' + parts[0], function(err, doc) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n      viewQuery({\n        map: doc.views[parts[1]].map,\n        reduce: doc.views[parts[1]].reduce\n      }, opts);\n    });\n  }\n\n  return {'query': query};\n};\n\n// Deletion is a noop since we dont store the results of the view\nMapReduce._delete = function() { };\n\nPouch.plugin('mapreduce', MapReduce);\n\n/*global Pouch: true */\n\n\"use strict\";\n\n// If we wanted to store incremental views we can do it here by listening\n// to the changes feed (keeping track of our last update_seq between page loads)\n// and storing the result of the map function (possibly using the upcoming\n// extracted adapter functions)\n\nvar Spatial = function(db) {\n\n  function viewQuery(fun, options) {\n    if (!options.complete) {\n      return;\n    }\n\n    var results = [];\n    var current = null;\n    var num_started= 0;\n    var completed= false;\n\n    // NOTE vmx 2013-01-27: I wouldn't guarantee that this function is\n    // flawless\n    var calculateBbox = function (geom) {\n      var coords = geom.coordinates;\n      if (geom.type === 'Point') {\n        return [[coords[0], coords[0]], [coords[1], coords[1]]];\n      }\n      if (geom.type === 'GeometryCollection') {\n        coords = geom.geometries.map(function(g) {\n          return calculateBbox(g);\n        });\n        return coords.reduce(function (a, b) {\n          var minX = Math.min(a[0], b[0]);\n          var minY = Math.min(a[1], b[1]);\n          var maxX = Math.max(a[2], b[0]);\n          var maxY = Math.max(a[3], b[1]);\n          return [[minX, maxX], [minY, maxY]];\n        });\n      }\n\n      // Flatten coords as much as possible\n      while (Array.isArray(coords[0][0])) {\n        coords = coords.reduce(function(a, b) {\n          return a.concat(b);\n        });\n      };\n\n      return coords.reduce(function (acc, coord) {\n        // The first element isn't a bbox yet\n        if (typeof acc[0] === \"number\") {//acc will never be of length 1\n          acc = [[acc[0], acc[0]], [acc[1], acc[1]]];\n        }\n        var minX = Math.min(acc[0][0], coord[0]);\n        var minY = Math.min(acc[1][0], coord[1]);\n        var maxX = Math.max(acc[0][1], coord[0]);\n        var maxY = Math.max(acc[1][1], coord[1]);\n        return [[minX, maxX], [minY, maxY]];\n      });\n    };\n\n    // Make the key a proper one. If a value is a single point, transform it\n    // to a range. If the first element (or the whole key) is a geometry,\n    // calculate its bounding box.\n    // The geometry is also returned (`null` if there is none).\n    var normalizeKey = function(key) {\n      var newKey = [];\n      var geometry = null;\n\n      // Whole key is one geometry\n      if (isPlainObject(key)) {\n        return {\n          key: calculateBbox(key),\n          geometry: key\n        };\n      }\n\n      if (isPlainObject(key[0])) {\n        newKey = calculateBbox(key[0]);\n        geometry = key[0];\n        key = key.slice(1);\n      }\n\n      for(var i=0; i<key.length; i++) {\n        if(isArray(key[i])) {\n          newKey.push(key[i]);\n        // If only a single point, not a range was emitted\n        } else {\n          newKey.push([key[i], key[i]]);\n        }\n      }\n      return {\n        key: newKey,\n        geometry: geometry\n      };\n    };\n\n    var within = function(key, start_range, end_range) {\n      var start;\n      var end;\n\n      for(var i=0; i<key.length; i++) {\n        start = key[i][0];\n        end = key[i][1];\n        if (\n          // Wildcard at the start\n          ((start_range[i] === null && (start <= end_range[i] || end_range[i] === null))\n           // Start is set\n           || (start <= end_range[i] || end_range[i] === null))\n          &&\n            // Wildcard at the end\n            ((end_range[i] === null && (end >= start_range[i] || start_range[i] === null))\n             // End is set\n             || (end >= start_range[i] || start_range[i] === null))) {\n          continue;\n        } else {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    var emit = function(key, val) {\n      var keyGeom = normalizeKey(key);\n      var viewRow = {\n        id: current.doc._id,\n        key: keyGeom.key,\n        value: val,\n        geometry: keyGeom.geometry\n      };\n\n      // If no range is given, return everything\n      if (options.start_range !== undefined &&\n          options.end_range !== undefined) {\n        if (!within(keyGeom.key, options.start_range, options.end_range)) {\n          return;\n        }\n      }\n\n      num_started++;\n      if (options.include_docs) {\n        //in this special case, join on _id (issue #106)\n        if (val && typeof val === 'object' && val._id){\n          db.get(val._id,\n              function(_, joined_doc){\n                if (joined_doc) {\n                  viewRow.doc = joined_doc;\n                }\n                results.push(viewRow);\n                checkComplete();\n              });\n          return;\n        } else {\n          viewRow.doc = current.doc;\n        }\n      }\n      results.push(viewRow);\n    };\n\n    // ugly way to make sure references to 'emit' in map/reduce bind to the\n    // above emit\n    eval('fun = ' + fun.toString() + ';');\n\n    // exclude  _conflicts key by default\n    // or to use options.conflicts if it's set when called by db.query\n    var conflicts = ('conflicts' in options ? options.conflicts : false);\n\n    // only proceed once all documents are mapped and joined\n    var checkComplete= function() {\n      if (completed && results.length == num_started){\n        return options.complete(null, {rows: results});\n      }\n    }\n\n    db.changes({\n      conflicts: conflicts,\n      include_docs: true,\n      onChange: function(doc) {\n        // Don't index deleted or design documents\n        if (!('deleted' in doc) && doc.id.indexOf('_design/') !== 0) {\n          current = {doc: doc.doc};\n          fun.call(this, doc.doc);\n        }\n      },\n      complete: function() {\n        completed= true;\n        checkComplete();\n      }\n    });\n  }\n\n  function httpQuery(location, opts, callback) {\n\n    // List of parameters to add to the PUT request\n    var params = [];\n\n    // TODO vmx 2013-01-27: Support skip and limit\n\n    if (typeof opts.start_range !== 'undefined') {\n      params.push('start_range=' + encodeURIComponent(JSON.stringify(\n        opts.start_range)));\n    }\n    if (typeof opts.end_range !== 'undefined') {\n      params.push('end_range=' + encodeURIComponent(JSON.stringify(\n        opts.end_range)));\n    }\n    if (typeof opts.key !== 'undefined') {\n      params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // We are referencing a query defined in the design doc\n    var parts = location.split('/');\n    db.request({\n      method: 'GET',\n      url: '_design/' + parts[0] + '/_spatial/' + parts[1] + params\n    }, callback);\n  }\n\n  function query(fun, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (callback) {\n      opts.complete = callback;\n    }\n\n    if (typeof fun !== 'string') {\n        var error = extend({reason: 'Querying with a function is not ' +\n         'supported for Spatial Views'}, Pouch.Errors.INVALID_REQUEST);\n      return call(callback, error);\n    }\n\n    if (db.type() === 'http') {\n      return httpQuery(fun, opts, callback);\n    }\n\n    var parts = fun.split('/');\n    db.get('_design/' + parts[0], function(err, doc) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n      viewQuery(doc.spatial[parts[1]], opts);\n    });\n  }\n\n  return {spatial: query};\n};\n\n// Deletion is a noop since we dont store the results of the view\nSpatial._delete = function() { };\n\nPouch.plugin('spatial', Spatial);\n"]],"start1":0,"start2":0,"length1":0,"length2":138163}]],"length":138163,"saved":false}
