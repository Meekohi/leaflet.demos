{"ts":1357844768327,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1357844771569,"patch":[[{"diffs":[[1,"/*! jQuery v1.7.1 jquery.com | jquery.org/license */\r\n(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f(\"<\"+a+\">\").appendTo(b),e=d.css(\"display\");d.remove();if(e===\"none\"||e===\"\"){cl||(cl=c.createElement(\"iframe\"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode===\"CSS1Compat\"?\"<!doctype html>\":\"\")+\"<html><body>\"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,\"display\"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h==\"string\"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k===\"*\")k=l;else if(l!==\"*\"&&l!==k){m=l+\" \"+k,n=e[m]||e[\"* \"+k];if(!n){p=b;for(o in e){j=o.split(\" \");if(j[0]===l||j[0]===\"*\"){p=e[j[1]+\" \"+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error(\"No conversion from \"+m.replace(\" \",\" to \")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function cb(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]===\"*\")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader(\"content-type\"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+\" \"+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function ca(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bE.test(a)?d(a,e):ca(a+\"[\"+(typeof e==\"object\"||f.isArray(e)?b:\"\")+\"]\",e,c,d)});else if(!c&&b!=null&&typeof b==\"object\")for(var e in b)ca(a+\"[\"+e+\"]\",b[e],c,d);else d(a,b)}function b_(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function b$(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bT,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l==\"string\"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=b$(a,c,d,e,l,g)));(k||!l)&&!g[\"*\"]&&(l=b$(a,c,d,e,\"*\",g));return l}function bZ(a){return function(b,c){typeof b!=\"string\"&&(c=b,b=\"*\");if(f.isFunction(c)){var d=b.toLowerCase().split(bP),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\\+/.test(h),j&&(h=h.substr(1)||\"*\"),i=a[h]=a[h]||[],i[j?\"unshift\":\"push\"](c)}}}function bC(a,b,c){var d=b===\"width\"?a.offsetWidth:a.offsetHeight,e=b===\"width\"?bx:by,g=0,h=e.length;if(d>0){if(c!==\"border\")for(;g<h;g++)c||(d-=parseFloat(f.css(a,\"padding\"+e[g]))||0),c===\"margin\"?d+=parseFloat(f.css(a,c+e[g]))||0:d-=parseFloat(f.css(a,\"border\"+e[g]+\"Width\"))||0;return d+\"px\"}d=bz(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0;if(c)for(;g<h;g++)d+=parseFloat(f.css(a,\"padding\"+e[g]))||0,c!==\"padding\"&&(d+=parseFloat(f.css(a,\"border\"+e[g]+\"Width\"))||0),c===\"margin\"&&(d+=parseFloat(f.css(a,c+e[g]))||0);return d+\"px\"}function bp(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:\"script\"}):f.globalEval((b.text||b.textContent||b.innerHTML||\"\").replace(bf,\"/*$0*/\")),b.parentNode&&b.parentNode.removeChild(b)}function bo(a){var b=c.createElement(\"div\");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||\"\").toLowerCase();b===\"input\"?bm(a):b!==\"script\"&&typeof a.getElementsByTagName!=\"undefined\"&&f.grep(a.getElementsByTagName(\"input\"),bm)}function bm(a){if(a.type===\"checkbox\"||a.type===\"radio\")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!=\"undefined\"?a.getElementsByTagName(\"*\"):typeof a.querySelectorAll!=\"undefined\"?a.querySelectorAll(\"*\"):[]}function bk(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c===\"object\")b.outerHTML=a.outerHTML;else if(c!==\"input\"||a.type!==\"checkbox\"&&a.type!==\"radio\"){if(c===\"option\")b.selected=a.defaultSelected;else if(c===\"input\"||c===\"textarea\")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c+(i[c][d].namespace?\".\":\"\")+i[c][d].namespace,i[c][d],i[c][d].data)}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,\"table\")?a.getElementsByTagName(\"tbody\")[0]||a.appendChild(a.ownerDocument.createElement(\"tbody\")):a}function U(a){var b=V.split(\"|\"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b==\"string\"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+\"defer\",e=b+\"queue\",g=b+\"mark\",h=f._data(a,d);h&&(c===\"queue\"||!f._data(a,e))&&(c===\"mark\"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b===\"data\"&&f.isEmptyObject(a[b]))continue;if(b!==\"toJSON\")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e=\"data-\"+c.replace(k,\"-$1\").toLowerCase();d=a.getAttribute(e);if(typeof d==\"string\"){try{d=d===\"true\"?!0:d===\"false\"?!1:d===\"null\"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll(\"left\")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,j=/\\S/,k=/^\\s+/,l=/\\s+$/,m=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,n=/^[\\],:{}\\s]*$/,o=/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,q=/(?:^|:|,)(?:\\s*\\[)+/g,r=/(webkit)[ \\/]([\\w.]+)/,s=/(opera)(?:.*version)?[ \\/]([\\w.]+)/,t=/(msie) ([\\w.]+)/,u=/(mozilla)(?:.*? rv:([\\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+\"\").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a===\"body\"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a==\"string\"){a.charAt(0)!==\"<\"||a.charAt(a.length-1)!==\">\"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:\"\",jquery:\"1.7.1\",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b===\"find\"?d.selector=this.selector+(this.selector?\" \":\"\")+c:b&&(d.selector=this.selector+\".\"+b+\"(\"+c+\")\");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),\"slice\",F.call(arguments).join(\",\"))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i==\"boolean\"&&(l=i,i=arguments[1]||{},j=2),typeof i!=\"object\"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger(\"ready\").off(\"ready\")}},bindReady:function(){if(!A){A=e.Callbacks(\"once memory\");if(c.readyState===\"complete\")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener(\"DOMContentLoaded\",B,!1),a.addEventListener(\"load\",e.ready,!1);else if(c.attachEvent){c.attachEvent(\"onreadystatechange\",B),a.attachEvent(\"onload\",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)===\"function\"},isArray:Array.isArray||function(a){return e.type(a)===\"array\"},isWindow:function(a){return a&&typeof a==\"object\"&&\"setInterval\"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||\"object\"},isPlainObject:function(a){if(!a||e.type(a)!==\"object\"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,\"constructor\")&&!D.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!=\"string\"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,\"@\").replace(p,\"]\").replace(q,\"\")))return(new Function(\"return \"+b))();e.error(\"Invalid JSON: \"+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,\"text/xml\")):(d=new ActiveXObject(\"Microsoft.XMLDOM\"),d.async=\"false\",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName(\"parsererror\").length)&&e.error(\"Invalid XML: \"+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,\"ms-\").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?\"\":G.call(a)}:function(a){return a==null?\"\":(a+\"\").replace(k,\"\").replace(l,\"\")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d===\"string\"||d===\"function\"||d===\"regexp\"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length==\"number\")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j==\"number\"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c==\"string\"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c==\"object\"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf(\"compatible\")<0&&u.exec(a)||[];return{browser:b[1]||\"\",version:b[2]||\"0\"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"),function(a,b){I[\"[object \"+b+\"]\"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(\" \")&&(k=/^[\\s\\xA0]+/,l=/[\\s\\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener(\"DOMContentLoaded\",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState===\"complete\"&&(c.detachEvent(\"onreadystatechange\",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h===\"array\"?m(g):h===\"function\"&&(!a.unique||!o.has(g))&&c.push(g)},n=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,l=j||0,j=0,k=c.length;for(;c&&l<k;l++)if(c[l].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}i=!1,c&&(a.once?e===!0?o.disable():c=[]:d&&d.length&&(e=d.shift(),o.fireWith(e[0],e[1])))},o={add:function(){if(c){var a=c.length;m(arguments),i?k=c.length:e&&e!==!0&&(j=a,n(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){i&&f<=k&&(k--,f<=l&&l--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&o.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(i?a.once||d.push([b,c]):(!a.once||!e)&&n(b,c));return this},fire:function(){o.fireWith(this,arguments);return this},fired:function(){return!!e}};return o};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks(\"once memory\"),c=f.Callbacks(\"once memory\"),d=f.Callbacks(\"memory\"),e=\"pending\",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,\"resolve\"],fail:[b,\"reject\"],progress:[c,\"notify\"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+\"With\"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+\"With\"]=g[j].fireWith;i.done(function(){e=\"resolved\"},c.disable,d.lock).fail(function(){e=\"rejected\"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p,q=c.createElement(\"div\"),r=c.documentElement;q.setAttribute(\"className\",\"t\"),q.innerHTML=\"   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>\",d=q.getElementsByTagName(\"*\"),e=q.getElementsByTagName(\"a\")[0];if(!d||!d.length||!e)return{};g=c.createElement(\"select\"),h=g.appendChild(c.createElement(\"option\")),i=q.getElementsByTagName(\"input\")[0],b={leadingWhitespace:q.firstChild.nodeType===3,tbody:!q.getElementsByTagName(\"tbody\").length,htmlSerialize:!!q.getElementsByTagName(\"link\").length,style:/top/.test(e.getAttribute(\"style\")),hrefNormalized:e.getAttribute(\"href\")===\"/a\",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value===\"on\",optSelected:h.selected,getSetAttribute:q.className!==\"t\",enctype:!!c.createElement(\"form\").enctype,html5Clone:c.createElement(\"nav\").cloneNode(!0).outerHTML!==\"<:nav></:nav>\",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete q.test}catch(s){b.deleteExpando=!1}!q.addEventListener&&q.attachEvent&&q.fireEvent&&(q.attachEvent(\"onclick\",function(){b.noCloneEvent=!1}),q.cloneNode(!0).fireEvent(\"onclick\")),i=c.createElement(\"input\"),i.value=\"t\",i.setAttribute(\"type\",\"radio\"),b.radioValue=i.value===\"t\",i.setAttribute(\"checked\",\"checked\"),q.appendChild(i),k=c.createDocumentFragment(),k.appendChild(q.lastChild),b.checkClone=k.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,k.removeChild(i),k.appendChild(q),q.innerHTML=\"\",a.getComputedStyle&&(j=c.createElement(\"div\"),j.style.width=\"0\",j.style.marginRight=\"0\",q.style.width=\"2px\",q.appendChild(j),b.reliableMarginRight=(parseInt((a.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0);if(q.attachEvent)for(o in{submit:1,change:1,focusin:1})n=\"on\"+o,p=n in q,p||(q.setAttribute(n,\"return;\"),p=typeof q[n]==\"function\"),b[o+\"Bubbles\"]=p;k.removeChild(q),k=g=h=j=q=i=null,f(function(){var a,d,e,g,h,i,j,k,m,n,o,r=c.getElementsByTagName(\"body\")[0];!r||(j=1,k=\"position:absolute;top:0;left:0;width:1px;height:1px;margin:0;\",m=\"visibility:hidden;border:0;\",n=\"style='\"+k+\"border:5px solid #000;padding:0;'\",o=\"<div \"+n+\"><div></div></div>\"+\"<table \"+n+\" cellpadding='0' cellspacing='0'>\"+\"<tr><td></td></tr></table>\",a=c.createElement(\"div\"),a.style.cssText=m+\"width:0;height:0;position:static;top:0;margin-top:\"+j+\"px\",r.insertBefore(a,r.firstChild),q=c.createElement(\"div\"),a.appendChild(q),q.innerHTML=\"<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>\",l=q.getElementsByTagName(\"td\"),p=l[0].offsetHeight===0,l[0].style.display=\"\",l[1].style.display=\"none\",b.reliableHiddenOffsets=p&&l[0].offsetHeight===0,q.innerHTML=\"\",q.style.width=q.style.paddingLeft=\"1px\",f.boxModel=b.boxModel=q.offsetWidth===2,typeof q.style.zoom!=\"undefined\"&&(q.style.display=\"inline\",q.style.zoom=1,b.inlineBlockNeedsLayout=q.offsetWidth===2,q.style.display=\"\",q.innerHTML=\"<div style='width:4px;'></div>\",b.shrinkWrapBlocks=q.offsetWidth!==2),q.style.cssText=k+m,q.innerHTML=o,d=q.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,i={doesNotAddBorder:e.offsetTop!==5,doesAddBorderForTableAndCells:h.offsetTop===5},e.style.position=\"fixed\",e.style.top=\"20px\",i.fixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top=\"\",d.style.overflow=\"hidden\",d.style.position=\"relative\",i.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,i.doesNotIncludeMarginInBodyOffset=r.offsetTop!==j,r.removeChild(a),q=a=null,f.extend(b,i))});return b}();var j=/^(?:\\{.*\\}|\\[.*\\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:\"jQuery\"+(f.fn.jquery+Math.random()).replace(/\\D/g,\"\"),noData:{embed:!0,object:\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c==\"string\",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c===\"events\";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c==\"object\"||typeof c==\"function\")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(\" \")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute(\"classid\")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h=null;if(typeof a==\"undefined\"){if(this.length){h=f.data(this[0]);if(this[0].nodeType===1&&!f._data(this[0],\"parsedAttrs\")){e=this[0].attributes;for(var i=0,j=e.length;i<j;i++)g=e[i].name,g.indexOf(\"data-\")===0&&(g=f.camelCase(g.substring(5)),l(this[0],g,h[g]));f._data(this[0],\"parsedAttrs\",!0)}}return h}if(typeof a==\"object\")return this.each(function(){f.data(this,a)});d=a.split(\".\"),d[1]=d[1]?\".\"+d[1]:\"\";if(c===b){h=this.triggerHandler(\"getData\"+d[1]+\"!\",[d[0]]),h===b&&this.length&&(h=f.data(this[0],a),h=l(this[0],a,h));return h===b&&d[1]?this.data(d[0]):h}return this.each(function(){var b=f(this),e=[d[0],c];b.triggerHandler(\"setData\"+d[1]+\"!\",e),f.data(this,a,c),b.triggerHandler(\"changeData\"+d[1]+\"!\",e)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||\"fx\")+\"mark\",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||\"fx\";var d=c+\"mark\",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,\"mark\"))}},queue:function(a,b,c){var d;if(a){b=(b||\"fx\")+\"queue\",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||\"fx\";var c=f.queue(a,b),d=c.shift(),e={};d===\"inprogress\"&&(d=c.shift()),d&&(b===\"fx\"&&c.unshift(\"inprogress\"),f._data(a,b+\".run\",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+\"queue \"+b+\".run\",!0),n(a,b,\"queue\"))}}),f.fn.extend({queue:function(a,c){typeof a!=\"string\"&&(c=a,a=\"fx\");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a===\"fx\"&&b[0]!==\"inprogress\"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||\"fx\";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||\"fx\",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!=\"string\"&&(c=a,a=b),a=a||\"fx\";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+\"defer\",j=a+\"queue\",k=a+\"mark\",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks(\"once memory\"),!0))h++,l.add(m);m();return d.promise()}});var o=/[\\n\\t\\r]/g,p=/\\s+/,q=/\\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a==\"string\"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=\" \"+e.className+\" \";for(h=0,i=b.length;h<i;h++)~g.indexOf(\" \"+b[h]+\" \")||(g+=b[h]+\" \");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a==\"string\"||a===b){c=(a||\"\").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(\" \"+g.className+\" \").replace(o,\" \");for(i=0,j=c.length;i<j;i++)h=h.replace(\" \"+c[i]+\" \",\" \");g.className=f.trim(h)}else g.className=\"\"}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b==\"boolean\";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c===\"string\"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?\"addClass\":\"removeClass\"](e)}else if(c===\"undefined\"||c===\"boolean\")this.className&&f._data(this,\"__className__\",this.className),this.className=this.className||a===!1?\"\":f._data(this,\"__className__\")||\"\"})},hasClass:function(a){var b=\" \"+a+\" \",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(\" \"+this[c].className+\" \").replace(o,\" \").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h=\"\":typeof h==\"number\"?h+=\"\":f.isArray(h)&&(h=f.map(h,function(a){return a==null?\"\":a+\"\"})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!(\"set\"in c)||c.set(this,h,\"value\")===b)this.value=h}})}if(g){c=f.valHooks[g.nodeName.toLowerCase()]||f.valHooks[g.type];if(c&&\"get\"in c&&(d=c.get(g,\"value\"))!==b)return d;d=g.value;return typeof d==\"string\"?d.replace(q,\"\"):d==null?\"\":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type===\"select-one\";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute(\"disabled\")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,\"optgroup\"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find(\"option\").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute==\"undefined\")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&\"set\"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,\"\"+d);return d}if(h&&\"get\"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;h<g;h++)e=d[h],e&&(c=f.propFix[e]||e,f.attr(a,e,\"\"),a.removeAttribute(v?e:c),u.test(e)&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error(\"type property can't be changed\");else if(!f.support.radioValue&&b===\"radio\"&&f.nodeName(a,\"input\")){var c=a.value;a.setAttribute(\"type\",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,\"button\"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,\"button\"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:\"tabIndex\",readonly:\"readOnly\",\"for\":\"htmlFor\",\"class\":\"className\",maxlength:\"maxLength\",cellspacing:\"cellSpacing\",cellpadding:\"cellPadding\",rowspan:\"rowSpan\",colspan:\"colSpan\",usemap:\"useMap\",frameborder:\"frameBorder\",contenteditable:\"contentEditable\"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&\"set\"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&\"get\"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode(\"tabindex\");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!=\"boolean\"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!==\"\":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+\"\"}},f.attrHooks.tabindex.set=w.set,f.each([\"width\",\"height\"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===\"\"){a.setAttribute(b,\"auto\");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===\"\"&&(b=\"false\"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each([\"href\",\"src\",\"width\",\"height\"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=\"\"+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype=\"encoding\"),f.support.checkOn||f.each([\"radio\",\"checkbox\"],function(){f.valHooks[this]={get:function(a){return a.getAttribute(\"value\")===null?\"on\":a.value}}}),f.each([\"radio\",\"checkbox\"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\\.]*)?(?:\\.(.+))?$/,B=/\\bhover(\\.\\S+)?\\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\\w*)(?:#([\\w\\-]+))?(?:\\.([\\w\\-]+))?$/,G=function(a){var b=F.exec(a);b&&(b[1]=(b[1]||\"\").toLowerCase(),b[3]=b[3]&&new RegExp(\"(?:^|\\\\s)\"+b[3]+\"(?:\\\\s|$)\"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c[\"class\"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,\"mouseenter$1 mouseleave$1\")};\r\nf.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!=\"undefined\"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(\" \");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||\"\").split(\".\").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:G(g),namespace:n.join(\".\")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent(\"on\"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||\"\")).split(\" \");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp(\"(^|\\\\.)\"+l.split(\".\").sort().join(\"\\\\.(?:.*\\\\.)?\")+\"(\\\\.|$)\"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d===\"**\"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,[\"events\",\"handle\"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf(\"!\")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(\".\")>=0&&(i=h.split(\".\"),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c==\"object\"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join(\".\"),c.namespace_re=c.namespace?new RegExp(\"(^|\\\\.)\"+i.join(\"\\\\.(?:.*\\\\.)?\")+\"(\\\\.|$)\"):null,o=h.indexOf(\":\")<0?\"on\"+h:\"\";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,\"events\")||{})[c.type]&&f._data(m,\"handle\"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!==\"click\"||!f.nodeName(e,\"a\"))&&f.acceptData(e)&&o&&e[h]&&(h!==\"focus\"&&h!==\"blur\"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,\"events\")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=[],j,k,l,m,n,o,p,q,r,s,t;g[0]=c,c.delegateTarget=this;if(e&&!c.target.disabled&&(!c.button||c.type!==\"click\")){m=f(this),m.context=this.ownerDocument||this;for(l=c.target;l!=this;l=l.parentNode||this){o={},q=[],m[0]=l;for(j=0;j<e;j++)r=d[j],s=r.selector,o[s]===b&&(o[s]=r.quick?H(l,r.quick):m.is(s)),o[s]&&q.push(r);q.length&&i.push({elem:l,matches:q})}}d.length>e&&i.push({elem:this,matches:d.slice(e)});for(j=0;j<i.length&&!c.isPropagationStopped();j++){p=i[j],c.currentTarget=p.elem;for(k=0;k<p.matches.length&&!c.isImmediatePropagationStopped();k++){r=p.matches[k];if(h||!c.namespace&&!r.namespace||c.namespace_re&&c.namespace_re.test(r.namespace))c.data=r.data,c.handleObj=r,n=((f.event.special[r.origType]||{}).handle||r.handler).apply(p.elem,g),n!==b&&(c.result=n,n===!1&&(c.preventDefault(),c.stopPropagation()))}}return c.result},props:\"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),fixHooks:{},keyHooks:{props:\"char charCode key keyCode\".split(\" \"),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:\"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:\"focusin\"},blur:{delegateType:\"focusout\"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent(\"on\"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,\"form\"))return!1;f.event.add(this,\"click._submit keypress._submit\",function(a){var c=a.target,d=f.nodeName(c,\"input\")||f.nodeName(c,\"button\")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,\"submit._submit\",function(a){this.parentNode&&!a.isTrigger&&f.event.simulate(\"submit\",this.parentNode,a,!0)}),d._submit_attached=!0)})},teardown:function(){if(f.nodeName(this,\"form\"))return!1;f.event.remove(this,\"._submit\")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type===\"checkbox\"||this.type===\"radio\")f.event.add(this,\"propertychange._change\",function(a){a.originalEvent.propertyName===\"checked\"&&(this._just_changed=!0)}),f.event.add(this,\"click._change\",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate(\"change\",this,a,!0))});return!1}f.event.add(this,\"beforeactivate._change\",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,\"change._change\",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate(\"change\",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!==\"radio\"&&b.type!==\"checkbox\")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,\"._change\");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:\"focusin\",blur:\"focusout\"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a==\"object\"){typeof c!=\"string\"&&(d=c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c==\"string\"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on.call(this,a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.type+\".\"+e.namespace:e.type,e.selector,e.handler);return this}if(typeof a==\"object\"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c==\"function\")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||\"**\",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,\"**\"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,\"lastToggle\"+a.guid)||0)%d;f._data(this,\"lastToggle\"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!=\"string\"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,d=\"sizcache\"+(Math.random()+\"\").replace(\".\",\"\"),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\\\/g,k=/\\r\\n/g,l=/\\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!=\"string\")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(\"\"),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]===\"~\"||w[0]===\"+\")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q=\"\",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)===\"[object Array]\")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!==\"\\\\\"){g[1]=(g[1]||\"\").replace(j,\"\"),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],\"\");break}}}}d||(d=typeof b.getElementsByTagName!=\"undefined\"?b.getElementsByTagName(\"*\"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)===\"\\\\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],\"\");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error(\"Syntax error, unrecognized expression: \"+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e=\"\";if(d){if(d===1||d===9){if(typeof a.textContent==\"string\")return a.textContent;if(typeof a.innerText==\"string\")return a.innerText.replace(k,\"\");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:[\"ID\",\"NAME\",\"TAG\"],match:{ID:/#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,CLASS:/\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,NAME:/\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/,ATTR:/\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(?:(['\"])(.*?)\\3|(#?(?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)*)|)|)\\s*\\]/,TAG:/^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\\(\\s*(even|odd|(?:[+\\-]?\\d+|(?:[+\\-]?\\d*)?n\\s*(?:[+\\-]\\s*\\d+)?))\\s*\\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/,PSEUDO:/:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/},leftMatch:{},attrMap:{\"class\":\"className\",\"for\":\"htmlFor\"},attrHandle:{href:function(a){return a.getAttribute(\"href\")},type:function(a){return a.getAttribute(\"type\")}},relative:{\"+\":function(a,b){var c=typeof b==\"string\",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},\">\":function(a,b){var c,d=typeof b==\"string\",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},\"\":function(a,b,c){var d,f=e++,g=x;typeof b==\"string\"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g(\"parentNode\",b,f,a,d,c)},\"~\":function(a,b,c){var d,f=e++,g=x;typeof b==\"string\"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g(\"previousSibling\",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!=\"undefined\"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!=\"undefined\"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute(\"name\")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!=\"undefined\")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=\" \"+a[1].replace(j,\"\")+\" \";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(\" \"+h.className+\" \").replace(/[\\t\\n\\r]/g,\" \").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,\"\")},TAG:function(a,b){return a[1].replace(j,\"\").toLowerCase()},CHILD:function(a){if(a[1]===\"nth\"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\\+|\\s*/g,\"\");var b=/(-?)(\\d*)(?:n([+\\-]?\\d*))?/.exec(a[2]===\"even\"&&\"2n\"||a[2]===\"odd\"&&\"2n+1\"||!/\\D/.test(a[2])&&\"0n+\"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,\"\");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||\"\").replace(j,\"\"),a[2]===\"~=\"&&(a[4]=\" \"+a[4]+\" \");return a},PSEUDO:function(b,c,d,e,f){if(b[1]===\"not\")if((a.exec(b[3])||\"\").length>1||/^\\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!==\"hidden\"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute(\"type\"),c=a.type;return a.nodeName.toLowerCase()===\"input\"&&\"text\"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"radio\"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"checkbox\"===a.type},file:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"file\"===a.type},password:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"password\"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b===\"input\"||b===\"button\")&&\"submit\"===a.type},image:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"image\"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b===\"input\"||b===\"button\")&&\"reset\"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b===\"input\"&&\"button\"===a.type||b===\"button\"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e===\"contains\")return(a.textContent||a.innerText||n([a])||\"\").indexOf(b[3])>=0;if(e===\"not\"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case\"only\":case\"first\":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k===\"first\")return!0;l=a;case\"last\":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case\"nth\":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute(\"id\")===b},TAG:function(a,b){return b===\"*\"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(\" \"+(a.className||a.getAttribute(\"class\"))+\" \").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+\"\",f=b[2],g=b[4];return d==null?f===\"!=\":!f&&m.attr?d!=null:f===\"=\"?e===g:f===\"*=\"?e.indexOf(g)>=0:f===\"~=\"?(\" \"+e+\" \").indexOf(g)>=0:g?f===\"!=\"?e!==g:f===\"^=\"?e.indexOf(g)===0:f===\"$=\"?e.substr(e.length-g.length)===g:f===\"|=\"?e===g||e.substr(0,g.length+1)===g+\"-\":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return\"\\\\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\\[]*\\])(?![^\\(]*\\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\\r|\\n)*?)/.source+o.match[r].source.replace(/\\\\(\\d+)/g,q));var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)===\"[object Array]\")Array.prototype.push.apply(d,a);else if(typeof a.length==\"number\")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement(\"div\"),d=\"script\"+(new Date).getTime(),e=c.documentElement;a.innerHTML=\"<a name='\"+d+\"'/>\",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!=\"undefined\"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!=\"undefined\"&&e.getAttributeNode(\"id\").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!=\"undefined\"&&a.getAttributeNode(\"id\");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement(\"div\");a.appendChild(c.createComment(\"\")),a.getElementsByTagName(\"*\").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]===\"*\"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML=\"<a href='#'></a>\",a.firstChild&&typeof a.firstChild.getAttribute!=\"undefined\"&&a.firstChild.getAttribute(\"href\")!==\"#\"&&(o.attrHandle.href=function(a){return a.getAttribute(\"href\",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement(\"div\"),d=\"__sizzle__\";b.innerHTML=\"<p class='TEST'></p>\";if(!b.querySelectorAll||b.querySelectorAll(\".TEST\").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\\w+$)|^\\.([\\w\\-]+$)|^#([\\w\\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b===\"body\"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!==\"object\"){var k=e,l=e.getAttribute(\"id\"),n=l||d,p=e.parentNode,q=/^\\s*[+~]/.test(b);l?n=n.replace(/'/g,\"\\\\$&\"):e.setAttribute(\"id\",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll(\"[id='\"+n+\"'] \"+b),f)}catch(r){}finally{l||k.removeAttribute(\"id\")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement(\"div\"),\"div\"),e=!1;try{b.call(c.documentElement,\"[test!='']:sizzle\")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\\=\\s*([^'\"\\]]*)\\s*\\]/g,\"='$1']\");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement(\"div\");a.innerHTML=\"<div class='test e'></div><div class='test'></div>\";if(!!a.getElementsByClassName&&a.getElementsByClassName(\"e\").length!==0){a.lastChild.className=\"e\";if(a.getElementsByClassName(\"e\").length===1)return;o.order.splice(1,0,\"CLASS\"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!=\"undefined\"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!==\"HTML\":!1};var y=function(a,b,c){var d,e=[],f=\"\",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,\"\");a=o.relative[a]?a+\"*\":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[\":\"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\\[\\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.POS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!=\"string\")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack(\"\",\"find\",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),\"not\",a)},filter:function(a){return this.pushStack(T(this,a,!0),\"filter\",a)},is:function(a){return!!a&&(typeof a==\"string\"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!=\"string\"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,\"closest\",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a==\"string\")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a==\"string\"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,\"parentNode\")},parentsUntil:function(a,b,c){return f.dir(a,\"parentNode\",c)},next:function(a){return f.nth(a,2,\"nextSibling\")},prev:function(a){return f.nth(a,2,\"previousSibling\")},nextAll:function(a){return f.dir(a,\"nextSibling\")},prevAll:function(a){return f.dir(a,\"previousSibling\")},nextUntil:function(a,b,c){return f.dir(a,\"nextSibling\",c)},prevUntil:function(a,b,c){return f.dir(a,\"previousSibling\",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,\"iframe\")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d==\"string\"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(\",\"))}}),f.extend({filter:function(a,b,c){c&&(a=\":not(\"+a+\")\");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V=\"abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",W=/ jQuery\\d+=\"(?:\\d+|null)\"/g,X=/^\\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,Z=/<([\\w:]+)/,$=/<tbody/i,_=/<|&#?\\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp(\"<(?:\"+V+\")\",\"i\"),bd=/checked\\s*(?:[^=]|=\\s*.checked.)/i,be=/\\/(java|ecma)script/i,bf=/^\\s*<!(?:\\[CDATA\\[|\\-\\-)/,bg={option:[1,\"<select multiple='multiple'>\",\"</select>\"],legend:[1,\"<fieldset>\",\"</fieldset>\"],thead:[1,\"<table>\",\"</table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],col:[2,\"<table><tbody></tbody><colgroup>\",\"</colgroup></table>\"],area:[1,\"<map>\",\"</map>\"],_default:[0,\"\",\"\"]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,\"div<div>\",\"</div>\"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!=\"object\"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,\"body\")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,\"before\",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,\"after\",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName(\"*\")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function()\r\n{for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName(\"*\"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,\"\"):null;if(typeof a==\"string\"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||[\"\",\"\"])[1].toLowerCase()]){a=a.replace(Y,\"<$1></$2>\");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName(\"*\")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!=\"string\"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),\"replaceWith\",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j==\"string\"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,\"tr\");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bp)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j==\"string\"&&j.length<512&&i===c&&j.charAt(0)===\"<\"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||!bc.test(\"<\"+a.nodeName)?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement==\"undefined\"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k==\"number\"&&(k+=\"\");if(!k)continue;if(typeof k==\"string\")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,\"<$1></$2>\");var l=(Z.exec(k)||[\"\",\"\"])[1].toLowerCase(),m=bg[l]||bg._default,n=m[0],o=b.createElement(\"div\");b===c?bh.appendChild(o):U(b).appendChild(o),o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l===\"table\"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]===\"<table>\"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],\"tbody\")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)==\"number\")for(i=0;i<r;i++)bn(k[i]);else bn(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||be.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],\"script\")&&(!h[j].type||h[j].type.toLowerCase()===\"text/javascript\"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName(\"script\"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bq=/alpha\\([^)]*\\)/i,br=/opacity=([^)]*)/,bs=/([A-Z]|^ms)/g,bt=/^-?\\d+(?:px)?$/i,bu=/^-?\\d/,bv=/^([\\-+])=([\\-+.\\de]+)/,bw={position:\"absolute\",visibility:\"hidden\",display:\"block\"},bx=[\"Left\",\"Right\"],by=[\"Top\",\"Bottom\"],bz,bA,bB;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bz(a,\"opacity\",\"opacity\");return c===\"\"?\"1\":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":f.support.cssFloat?\"cssFloat\":\"styleFloat\"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&\"get\"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h===\"string\"&&(g=bv.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h=\"number\");if(d==null||h===\"number\"&&isNaN(d))return;h===\"number\"&&!f.cssNumber[i]&&(d+=\"px\");if(!k||!(\"set\"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c===\"cssFloat\"&&(c=\"float\");if(g&&\"get\"in g&&(e=g.get(a,!0,d))!==b)return e;if(bz)return bz(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each([\"height\",\"width\"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return bC(a,b,d);f.swap(a,bw,function(){e=bC(a,b,d)});return e}},set:function(a,b){if(!bt.test(b))return b;b=parseFloat(b);if(b>=0)return b+\"px\"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return br.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||\"\")?parseFloat(RegExp.$1)/100+\"\":b?\"1\":\"\"},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?\"alpha(opacity=\"+b*100+\")\":\"\",g=d&&d.filter||c.filter||\"\";c.zoom=1;if(b>=1&&f.trim(g.replace(bq,\"\"))===\"\"){c.removeAttribute(\"filter\");if(d&&!d.filter)return}c.filter=bq.test(g)?g.replace(bq,e):g+\" \"+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:\"inline-block\"},function(){b?c=bz(a,\"margin-right\",\"marginRight\"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bA=function(a,b){var c,d,e;b=b.replace(bs,\"-$1\").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===\"\"&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b)));return c}),c.documentElement.currentStyle&&(bB=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f===null&&g&&(e=g[b])&&(f=e),!bt.test(f)&&bu.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b===\"fontSize\"?\"1em\":f||0,f=g.pixelLeft+\"px\",g.left=c,d&&(a.runtimeStyle.left=d));return f===\"\"?\"auto\":f}),bz=bA||bB,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,\"display\"))===\"none\"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bD=/%20/g,bE=/\\[\\]$/,bF=/\\r?\\n/g,bG=/#.*$/,bH=/^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,bI=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bJ=/^(?:about|app|app\\-storage|.+\\-extension|file|res|widget):$/,bK=/^(?:GET|HEAD)$/,bL=/^\\/\\//,bM=/\\?/,bN=/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,bO=/^(?:select|textarea)/i,bP=/\\s+/,bQ=/([?&])_=[^&]*/,bR=/^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/,bS=f.fn.load,bT={},bU={},bV,bW,bX=[\"*/\"]+[\"*\"];try{bV=e.href}catch(bY){bV=c.createElement(\"a\"),bV.href=\"\",bV=bV.href}bW=bR.exec(bV.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!=\"string\"&&bS)return bS.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(\" \");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h=\"GET\";c&&(f.isFunction(c)?(d=c,c=b):typeof c==\"object\"&&(c=f.param(c,f.ajaxSettings.traditional),h=\"POST\"));var i=this;f.ajax({url:a,type:h,dataType:\"html\",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f(\"<div>\").append(c.replace(bN,\"\")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bO.test(this.nodeName)||bI.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bF,\"\\r\\n\")}}):{name:b.name,value:c.replace(bF,\"\\r\\n\")}}).get()}}),f.each(\"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split(\" \"),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each([\"get\",\"post\"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,\"script\")},getJSON:function(a,b,c){return f.get(a,b,c,\"json\")},ajaxSetup:function(a,b){b?b_(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b_(a,b);return a},ajaxSettings:{url:bV,isLocal:bJ.test(bW[1]),global:!0,type:\"GET\",contentType:\"application/x-www-form-urlencoded\",processData:!0,async:!0,accepts:{xml:\"application/xml, text/xml\",html:\"text/html\",text:\"text/plain\",json:\"application/json, text/javascript\",\"*\":bX},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\"responseXML\",text:\"responseText\"},converters:{\"* text\":a.String,\"text html\":!0,\"text json\":f.parseJSON,\"text xml\":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bZ(bT),ajaxTransport:bZ(bU),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||\"\",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?cb(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader(\"Last-Modified\"))f.lastModified[k]=y;if(z=v.getResponseHeader(\"Etag\"))f.etag[k]=z}if(a===304)w=\"notmodified\",o=!0;else try{r=cc(d,x),w=\"success\",o=!0}catch(A){w=\"parsererror\",u=A}}else{u=w;if(!w||a)w=\"error\",a<0&&(a=0)}v.status=a,v.statusText=\"\"+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger(\"ajax\"+(o?\"Success\":\"Error\"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger(\"ajaxComplete\",[v,d]),--f.active||f.event.trigger(\"ajaxStop\"))}}typeof a==\"object\"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks(\"once memory\"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bH.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||\"abort\",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+\"\").replace(bG,\"\").replace(bL,bW[1]+\"//\"),d.dataTypes=f.trim(d.dataType||\"*\").toLowerCase().split(bP),d.crossDomain==null&&(r=bR.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bW[1]&&r[2]==bW[2]&&(r[3]||(r[1]===\"http:\"?80:443))==(bW[3]||(bW[1]===\"http:\"?80:443)))),d.data&&d.processData&&typeof d.data!=\"string\"&&(d.data=f.param(d.data,d.traditional)),b$(bT,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bK.test(d.type),t&&f.active++===0&&f.event.trigger(\"ajaxStart\");if(!d.hasContent){d.data&&(d.url+=(bM.test(d.url)?\"&\":\"?\")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bQ,\"$1_=\"+x);d.url=y+(y===d.url?(bM.test(d.url)?\"&\":\"?\")+\"_=\"+x:\"\")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader(\"Content-Type\",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader(\"If-Modified-Since\",f.lastModified[k]),f.etag[k]&&v.setRequestHeader(\"If-None-Match\",f.etag[k])),v.setRequestHeader(\"Accept\",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!==\"*\"?\", \"+bX+\"; q=0.01\":\"\"):d.accepts[\"*\"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=b$(bU,d,c,v);if(!p)w(-1,\"No Transport\");else{v.readyState=1,t&&g.trigger(\"ajaxSend\",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort(\"timeout\")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+\"=\"+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)ca(g,a[g],c,e);return d.join(\"&\").replace(bD,\"+\")}}),f.extend({active:0,lastModified:{},etag:{}});var cd=f.now(),ce=/(\\=)\\?(&|$)|\\?\\?/i;f.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){return f.expando+\"_\"+cd++}}),f.ajaxPrefilter(\"json jsonp\",function(b,c,d){var e=b.contentType===\"application/x-www-form-urlencoded\"&&typeof b.data==\"string\";if(b.dataTypes[0]===\"jsonp\"||b.jsonp!==!1&&(ce.test(b.url)||e&&ce.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l=\"$1\"+h+\"$2\";b.jsonp!==!1&&(j=j.replace(ce,l),b.url===j&&(e&&(k=k.replace(ce,l)),b.data===k&&(j+=(/\\?/.test(j)?\"&\":\"?\")+b.jsonp+\"=\"+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters[\"script json\"]=function(){g||f.error(h+\" was not called\");return g[0]},b.dataTypes[0]=\"json\";return\"script\"}}),f.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/javascript|ecmascript/},converters:{\"text script\":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter(\"script\",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type=\"GET\",a.global=!1)}),f.ajaxTransport(\"script\",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName(\"head\")[0]||c.documentElement;return{send:function(f,g){d=c.createElement(\"script\"),d.async=\"async\",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,\"success\")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cf=a.ActiveXObject?function(){for(var a in ch)ch[a](0,1)}:!1,cg=0,ch;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ci()||cj()}:ci,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&\"withCredentials\"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e[\"X-Requested-With\"]&&(e[\"X-Requested-With\"]=\"XMLHttpRequest\");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cf&&delete ch[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=\"\"}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cg,cf&&(ch||(ch={},f(a).unload(cf)),ch[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var ck={},cl,cm,cn=/^(?:toggle|show|hide)$/,co=/^([+\\-]=)?([\\d+.\\-]+)([a-z%]*)$/i,cp,cq=[[\"height\",\"marginTop\",\"marginBottom\",\"paddingTop\",\"paddingBottom\"],[\"width\",\"marginLeft\",\"marginRight\",\"paddingLeft\",\"paddingRight\"],[\"opacity\"]],cr;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cu(\"show\",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,\"olddisplay\")&&e===\"none\"&&(e=d.style.display=\"\"),e===\"\"&&f.css(d,\"display\")===\"none\"&&f._data(d,\"olddisplay\",cv(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===\"\"||e===\"none\")d.style.display=f._data(d,\"olddisplay\")||\"\"}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cu(\"hide\",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,\"display\"),e!==\"none\"&&!f._data(d,\"olddisplay\")&&f._data(d,\"olddisplay\",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display=\"none\");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a==\"boolean\";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(\":hidden\");f(this)[b?\"show\":\"hide\"]()}):this.animate(cu(\"toggle\",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(\":hidden\").css(\"opacity\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(\":hidden\"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||\"swing\";if(h===\"hide\"&&d||h===\"show\"&&!d)return b.complete.call(this);c&&(g===\"height\"||g===\"width\")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,\"display\")===\"inline\"&&f.css(this,\"float\")===\"none\"&&(!f.support.inlineBlockNeedsLayout||cv(this.nodeName)===\"inline\"?this.style.display=\"inline-block\":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow=\"hidden\");for(i in a)j=new f.fx(this,b,i),h=a[i],cn.test(h)?(o=f._data(this,\"toggle\"+i)||(h===\"toggle\"?d?\"show\":\"hide\":0),o?(f._data(this,\"toggle\"+i,o===\"show\"?\"hide\":\"show\"),j[o]()):j[h]()):(k=co.exec(h),l=j.cur(),k?(m=parseFloat(k[2]),n=k[3]||(f.cssNumber[i]?\"\":\"px\"),n!==\"px\"&&(f.style(this,i,(m||1)+n),l=(m||1)/j.cur()*l,f.style(this,i,l+n)),k[1]&&(m=(k[1]===\"-=\"?-1:1)*m+l),j.custom(l,m,n)):j.custom(l,h,\"\"));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!=\"string\"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||\"fx\",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(\".run\")===b.length-4&&h(this,g,b);else g[b=a+\".run\"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:cu(\"show\",1),slideUp:cu(\"hide\",1),slideToggle:cu(\"toggle\",1),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a==\"object\"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration==\"number\"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue=\"fx\";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b===\"auto\"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cr||cs(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?\"\":\"px\"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){e.options.hide&&f._data(e.elem,\"fxshow\"+e.prop)===b&&f._data(e.elem,\"fxshow\"+e.prop,e.start)},h()&&f.timers.push(h)&&!cp&&(cp=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,\"fxshow\"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop===\"width\"||this.prop===\"height\"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,\"fxshow\"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cr||cs(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each([\"\",\"X\",\"Y\"],function(a,b){h.style[\"overflow\"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,\"fxshow\"+b,!0),f.removeData(h,\"toggle\"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cp),cp=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,\"opacity\",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each([\"width\",\"height\"],function(a,b){f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;\"getBoundingClientRect\"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cy(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.support.fixedPosition&&k.position===\"fixed\")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&c.overflow!==\"visible\"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position===\"relative\"||k.position===\"static\")l+=i.offsetTop,m+=i.offsetLeft;f.support.fixedPosition&&k.position===\"fixed\"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,\"marginTop\"))||0,c+=parseFloat(f.css(a,\"marginLeft\"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,\"position\");d===\"static\"&&(a.style.position=\"relative\");var e=f(a),g=e.offset(),h=f.css(a,\"top\"),i=f.css(a,\"left\"),j=(d===\"absolute\"||d===\"fixed\")&&f.inArray(\"auto\",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),\"using\"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,\"marginTop\"))||0,c.left-=parseFloat(f.css(a,\"marginLeft\"))||0,d.top+=parseFloat(f.css(b[0],\"borderTopWidth\"))||0,d.left+=parseFloat(f.css(b[0],\"borderLeftWidth\"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,\"position\")===\"static\")a=a.offsetParent;return a})}}),f.each([\"Left\",\"Top\"],function(a,c){var d=\"scroll\"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cy(e);return g?\"pageXOffset\"in g?g[a?\"pageYOffset\":\"pageXOffset\"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cy(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each([\"Height\",\"Width\"],function(a,c){var d=c.toLowerCase();f.fn[\"inner\"+c]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,d,\"padding\")):this[d]():null},f.fn[\"outer\"+c]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,d,a?\"margin\":\"border\")):this[d]():null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement[\"client\"+c],h=e.document.body;return e.document.compatMode===\"CSS1Compat\"&&g||h&&h[\"client\"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement[\"client\"+c],e.body[\"scroll\"+c],e.documentElement[\"scroll\"+c],e.body[\"offset\"+c],e.documentElement[\"offset\"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNumeric(j)?j:i}return this.css(d,typeof a==\"string\"?a:a+\"px\")}}),a.jQuery=a.$=f,typeof define==\"function\"&&define.amd&&define.amd.jQuery&&define(\"jquery\",[],function(){return f})})(window);\r\n// BEGIN Math.uuid.js\r\n\r\n/*!\r\nMath.uuid.js (v1.4)\r\nhttp://www.broofa.com\r\nmailto:robert@broofa.com\r\n\r\nCopyright (c) 2010 Robert Kieffer\r\nDual licensed under the MIT and GPL licenses.\r\n*/\r\n\r\n/*\r\n * Generate a random uuid.\r\n *\r\n * USAGE: Math.uuid(length, radix)\r\n *   length - the desired number of characters\r\n *   radix  - the number of allowable values for each character.\r\n *\r\n * EXAMPLES:\r\n *   // No arguments  - returns RFC4122, version 4 ID\r\n *   >>> Math.uuid()\r\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\r\n *\r\n *   // One argument - returns ID of the specified length\r\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\r\n *   \"VcydxgltxrVZSTV\"\r\n *\r\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\r\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\r\n *   \"01001010\"\r\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\r\n *   \"47473046\"\r\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\r\n *   \"098F4D35\"\r\n */\r\n(function() {\r\n  // Private array of chars to use\r\n  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\r\n\r\n  Math.uuid = function (len, radix) {\r\n    var chars = CHARS, uuid = [];\r\n    radix = radix || chars.length;\r\n\r\n    if (len) {\r\n      // Compact form\r\n      for (var i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];\r\n    } else {\r\n      // rfc4122, version 4 form\r\n      var r;\r\n\r\n      // rfc4122 requires these characters\r\n      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\r\n      uuid[14] = '4';\r\n\r\n      // Fill in random data.  At i==19 set the high bits of clock sequence as\r\n      // per rfc4122, sec. 4.1.5\r\n      for (var i = 0; i < 36; i++) {\r\n        if (!uuid[i]) {\r\n          r = 0 | Math.random()*16;\r\n          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n        }\r\n      }\r\n    }\r\n\r\n    return uuid.join('');\r\n  };\r\n\r\n  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance\r\n  // by minimizing calls to random()\r\n  Math.uuidFast = function() {\r\n    var chars = CHARS, uuid = new Array(36), rnd=0, r;\r\n    for (var i = 0; i < 36; i++) {\r\n      if (i==8 || i==13 ||  i==18 || i==23) {\r\n        uuid[i] = '-';\r\n      } else if (i==14) {\r\n        uuid[i] = '4';\r\n      } else {\r\n        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\r\n        r = rnd & 0xf;\r\n        rnd = rnd >> 4;\r\n        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n      }\r\n    }\r\n    return uuid.join('');\r\n  };\r\n\r\n  // A more compact, but less performant, RFC4122v4 solution:\r\n  Math.uuidCompact = function() {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\r\n      return v.toString(16);\r\n    }).toUpperCase();\r\n  };\r\n})();\r\n\r\n// END Math.uuid.js\r\n\r\n/**\r\n*\r\n*  MD5 (Message-Digest Algorithm)\r\n*\r\n*  For original source see http://www.webtoolkit.info/\r\n*  Download: 15.02.2009 from http://www.webtoolkit.info/javascript-md5.html\r\n*\r\n*  Licensed under CC-BY 2.0 License\r\n*  (http://creativecommons.org/licenses/by/2.0/uk/)\r\n*\r\n**/\r\n\r\nvar Crypto = {};\r\n(function() {\r\n  Crypto.MD5 = function(string) {\r\n\r\n    function RotateLeft(lValue, iShiftBits) {\r\n      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\r\n    }\r\n\r\n    function AddUnsigned(lX,lY) {\r\n      var lX4,lY4,lX8,lY8,lResult;\r\n      lX8 = (lX & 0x80000000);\r\n      lY8 = (lY & 0x80000000);\r\n      lX4 = (lX & 0x40000000);\r\n      lY4 = (lY & 0x40000000);\r\n      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\r\n      if (lX4 & lY4) {\r\n        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\r\n      }\r\n      if (lX4 | lY4) {\r\n        if (lResult & 0x40000000) {\r\n          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\r\n        } else {\r\n          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\r\n        }\r\n      } else {\r\n        return (lResult ^ lX8 ^ lY8);\r\n      }\r\n    }\r\n\r\n    function F(x,y,z) { return (x & y) | ((~x) & z); }\r\n    function G(x,y,z) { return (x & z) | (y & (~z)); }\r\n    function H(x,y,z) { return (x ^ y ^ z); }\r\n    function I(x,y,z) { return (y ^ (x | (~z))); }\r\n\r\n    function FF(a,b,c,d,x,s,ac) {\r\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\r\n      return AddUnsigned(RotateLeft(a, s), b);\r\n    };\r\n\r\n    function GG(a,b,c,d,x,s,ac) {\r\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\r\n      return AddUnsigned(RotateLeft(a, s), b);\r\n    };\r\n\r\n    function HH(a,b,c,d,x,s,ac) {\r\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\r\n      return AddUnsigned(RotateLeft(a, s), b);\r\n    };\r\n\r\n    function II(a,b,c,d,x,s,ac) {\r\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\r\n      return AddUnsigned(RotateLeft(a, s), b);\r\n    };\r\n\r\n    function ConvertToWordArray(string) {\r\n      var lWordCount;\r\n      var lMessageLength = string.length;\r\n      var lNumberOfWords_temp1=lMessageLength + 8;\r\n      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\r\n      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\r\n      var lWordArray=Array(lNumberOfWords-1);\r\n      var lBytePosition = 0;\r\n      var lByteCount = 0;\r\n      while ( lByteCount < lMessageLength ) {\r\n        lWordCount = (lByteCount-(lByteCount % 4))/4;\r\n        lBytePosition = (lByteCount % 4)*8;\r\n        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\r\n        lByteCount++;\r\n      }\r\n      lWordCount = (lByteCount-(lByteCount % 4))/4;\r\n      lBytePosition = (lByteCount % 4)*8;\r\n      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\r\n      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\r\n      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\r\n      return lWordArray;\r\n    };\r\n\r\n    function WordToHex(lValue) {\r\n      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\r\n      for (lCount = 0;lCount<=3;lCount++) {\r\n        lByte = (lValue>>>(lCount*8)) & 255;\r\n        WordToHexValue_temp = \"0\" + lByte.toString(16);\r\n        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\r\n      }\r\n      return WordToHexValue;\r\n    };\r\n\r\n    //**    function Utf8Encode(string) removed. Aready defined in pidcrypt_utils.js\r\n\r\n    var x=Array();\r\n    var k,AA,BB,CC,DD,a,b,c,d;\r\n    var S11=7, S12=12, S13=17, S14=22;\r\n    var S21=5, S22=9 , S23=14, S24=20;\r\n    var S31=4, S32=11, S33=16, S34=23;\r\n    var S41=6, S42=10, S43=15, S44=21;\r\n\r\n    //\tstring = Utf8Encode(string); #function call removed\r\n\r\n    x = ConvertToWordArray(string);\r\n\r\n    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\r\n\r\n    for (k=0;k<x.length;k+=16) {\r\n      AA=a; BB=b; CC=c; DD=d;\r\n      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\r\n      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\r\n      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\r\n      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\r\n      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\r\n      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\r\n      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\r\n      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\r\n      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\r\n      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\r\n      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\r\n      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\r\n      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\r\n      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\r\n      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\r\n      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\r\n      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\r\n      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\r\n      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\r\n      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\r\n      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\r\n      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\r\n      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\r\n      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\r\n      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\r\n      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\r\n      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\r\n      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\r\n      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\r\n      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\r\n      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\r\n      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\r\n      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\r\n      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\r\n      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\r\n      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\r\n      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\r\n      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\r\n      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\r\n      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\r\n      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\r\n      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\r\n      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\r\n      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\r\n      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\r\n      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\r\n      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\r\n      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\r\n      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\r\n      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\r\n      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\r\n      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\r\n      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\r\n      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\r\n      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\r\n      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\r\n      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\r\n      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\r\n      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\r\n      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\r\n      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\r\n      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\r\n      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\r\n      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\r\n      a=AddUnsigned(a,AA);\r\n      b=AddUnsigned(b,BB);\r\n      c=AddUnsigned(c,CC);\r\n      d=AddUnsigned(d,DD);\r\n    }\r\n    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\r\n    return temp.toLowerCase();\r\n  }\r\n})();\r\n\r\n// END Crypto.md5.js\r\n\r\n//----------------------------------------------------------------------\r\n//\r\n// ECMAScript 5 Polyfills\r\n//  from www.calocomrmen./polyfill/\r\n//\r\n//----------------------------------------------------------------------\r\n\r\n//----------------------------------------------------------------------\r\n// ES5 15.2 Object Objects\r\n//----------------------------------------------------------------------\r\n\r\n\r\n\r\n// ES 15.2.3.6 Object.defineProperty ( O, P, Attributes )\r\n// Partial support for most common case - getters, setters, and values\r\n(function() {\r\n  if (!Object.defineProperty ||\r\n      !(function () { try { Object.defineProperty({}, 'x', {}); return true; } catch (e) { return false; } } ())) {\r\n    var orig = Object.defineProperty;\r\n    Object.defineProperty = function (o, prop, desc) {\r\n      \"use strict\";\r\n\r\n      // In IE8 try built-in implementation for defining properties on DOM prototypes.\r\n      if (orig) { try { return orig(o, prop, desc); } catch (e) {} }\r\n\r\n      if (o !== Object(o)) { throw new TypeError(\"Object.defineProperty called on non-object\"); }\r\n      if (Object.prototype.__defineGetter__ && ('get' in desc)) {\r\n        Object.prototype.__defineGetter__.call(o, prop, desc.get);\r\n      }\r\n      if (Object.prototype.__defineSetter__ && ('set' in desc)) {\r\n        Object.prototype.__defineSetter__.call(o, prop, desc.set);\r\n      }\r\n      if ('value' in desc) {\r\n        o[prop] = desc.value;\r\n      }\r\n      return o;\r\n    };\r\n  }\r\n}());\r\n\r\n\r\n\r\n// ES5 15.2.3.14 Object.keys ( O )\r\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\r\nif (!Object.keys) {\r\n  Object.keys = function (o) {\r\n    if (o !== Object(o)) { throw new TypeError('Object.keys called on non-object'); }\r\n    var ret = [], p;\r\n    for (p in o) {\r\n      if (Object.prototype.hasOwnProperty.call(o, p)) {\r\n        ret.push(p);\r\n      }\r\n    }\r\n    return ret;\r\n  };\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// ES5 15.4 Array Objects\r\n//----------------------------------------------------------------------\r\n\r\n\r\n\r\n// ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )\r\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\r\nif (!Array.prototype.forEach) {\r\n  Array.prototype.forEach = function (fun /*, thisp */) {\r\n    \"use strict\";\r\n\r\n    if (this === void 0 || this === null) { throw new TypeError(); }\r\n\r\n    var t = Object(this);\r\n    var len = t.length >>> 0;\r\n    if (typeof fun !== \"function\") { throw new TypeError(); }\r\n\r\n    var thisp = arguments[1], i;\r\n    for (i = 0; i < len; i++) {\r\n      if (i in t) {\r\n        fun.call(thisp, t[i], i, t);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n\r\n// ES5 15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] )\r\n// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map\r\nif (!Array.prototype.map) {\r\n  Array.prototype.map = function (fun /*, thisp */) {\r\n    \"use strict\";\r\n\r\n    if (this === void 0 || this === null) { throw new TypeError(); }\r\n\r\n    var t = Object(this);\r\n    var len = t.length >>> 0;\r\n    if (typeof fun !== \"function\") { throw new TypeError(); }\r\n\r\n    var res = []; res.length = len;\r\n    var thisp = arguments[1], i;\r\n    for (i = 0; i < len; i++) {\r\n      if (i in t) {\r\n        res[i] = fun.call(thisp, t[i], i, t);\r\n      }\r\n    }\r\n\r\n    return res;\r\n  };\r\n}\r\n\r\n\r\n\"use strict\";\r\n\r\nvar Pouch = function Pouch(name, opts, callback) {\r\n\r\n  if (!(this instanceof Pouch)) {\r\n    return new Pouch(name, opts, callback);\r\n  }\r\n\r\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n\r\n  var backend = Pouch.parseAdapter(opts.name || name);\r\n  opts.name = backend.name;\r\n  opts.adapter = opts.adapter || backend.adapter;\r\n\r\n  if (!Pouch.adapters[backend.adapter]) {\r\n    throw 'Adapter is missing';\r\n  }\r\n\r\n  if (!Pouch.adapters[backend.adapter].valid()) {\r\n    throw 'Invalid Adapter';\r\n  }\r\n\r\n  var adapter = Pouch.adapters[backend.adapter](opts, function(err, db) {\r\n    if (err) {\r\n      if (callback) callback(err);\r\n      return;\r\n    }\r\n    for (var plugin in Pouch.plugins) {\r\n      // In future these will likely need to be async to allow the plugin\r\n      // to initialise\r\n      var pluginObj = Pouch.plugins[plugin](db);\r\n      for (var api in pluginObj) {\r\n        // We let things like the http adapter use its own implementation\r\n        // as it shares a lot of code\r\n        if (!(api in db)) {\r\n          db[api] = pluginObj[api];\r\n        }\r\n      }\r\n    }\r\n    callback(null, db);\r\n  });\r\n  for (var j in adapter) {\r\n    this[j] = adapter[j];\r\n  }\r\n};\r\n\r\nPouch.DEBUG = false;\r\n\r\nPouch.adapters = {};\r\nPouch.plugins = {};\r\n\r\nPouch.parseAdapter = function(name) {\r\n\r\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\r\n  if (match) {\r\n    // the http adapter expects the fully qualified name\r\n    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\r\n    var adapter = match[1];\r\n    if (!Pouch.adapters[adapter].valid()) {\r\n      throw 'Invalid adapter';\r\n    }\r\n    return {name: name, adapter: match[1]};\r\n  }\r\n\r\n  var rank = {'idb': 1, 'leveldb': 2, 'websql': 3, 'http': 4, 'https': 4};\r\n  var rankedAdapter = Object.keys(Pouch.adapters).sort(function(a, b) {\r\n    return rank[a] - rank[b];\r\n  })[0];\r\n\r\n  return {\r\n    name: name,\r\n    adapter: rankedAdapter\r\n  };\r\n\r\n  throw 'No Valid Adapter.';\r\n};\r\n\r\n\r\nPouch.destroy = function(name, callback) {\r\n  for (var plugin in Pouch.plugins) {\r\n    Pouch.plugins[plugin]._delete(name);\r\n  }\r\n  var opts = Pouch.parseAdapter(name);\r\n  Pouch.adapters[opts.adapter].destroy(opts.name, callback);\r\n};\r\n\r\nPouch.adapter = function (id, obj) {\r\n  if (obj.valid()) {\r\n    Pouch.adapters[id] = obj;\r\n  }\r\n};\r\n\r\nPouch.plugin = function(id, obj) {\r\n  Pouch.plugins[id] = obj;\r\n};\r\n\r\n// Enumerate errors, add the status code so we can reflect the HTTP api\r\n// in future\r\nPouch.Errors = {\r\n  MISSING_BULK_DOCS: {\r\n    status: 400,\r\n    error: 'bad_request',\r\n    reason: \"Missing JSON list of 'docs'\"\r\n  },\r\n  MISSING_DOC: {\r\n    status: 404,\r\n    error: 'not_found',\r\n    reason: 'missing'\r\n  },\r\n  REV_CONFLICT: {\r\n    status: 409,\r\n    error: 'conflict',\r\n    reason: 'Document update conflict'\r\n  },\r\n  INVALID_ID: {\r\n    status: 400,\r\n    error: 'invalid_id',\r\n    reason: '_id field must contain a string'\r\n  },\r\n  MISSING_ID: {\r\n    status: 412,\r\n    error: 'missing_id',\r\n    reason: '_id is required for puts'\r\n  },\r\n  RESERVED_ID: {\r\n    status: 400,\r\n    error: 'bad_request',\r\n    reason: 'Only reserved document ids may start with underscore.'\r\n  },\r\n  NOT_OPEN: {\r\n    status: 412,\r\n    error: 'precondition_failed',\r\n    reason: 'Database not open so cannot close'\r\n  },\r\n  UNKNOWN_ERROR: {\r\n    status: 500,\r\n    error: 'unknown_error',\r\n    reason: 'Database encountered an unknown error'\r\n  }\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  global.Pouch = Pouch;\r\n  Pouch.merge = require('./pouch.merge.js').merge;\r\n  Pouch.collate = require('./pouch.collate.js').collate;\r\n  Pouch.replicate = require('./pouch.replicate.js').replicate;\r\n  Pouch.utils = require('./pouch.utils.js');\r\n  module.exports = Pouch;\r\n\r\n  // load adapters known to work under node\r\n  var adapters = ['leveldb', 'http'];\r\n  adapters.map(function(adapter) {\r\n    var adapter_path = './adapters/pouch.'+adapter+'.js';\r\n    require(adapter_path);\r\n  });\r\n  require('./plugins/pouchdb.mapreduce.js');\r\n} else {\r\n  this.Pouch = Pouch;\r\n}\r\n\r\n(function() {\r\n  // a few hacks to get things in the right place for node.js\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = Pouch;\r\n  }\r\n\r\n  Pouch.collate = function(a, b) {\r\n    var ai = collationIndex(a);\r\n    var bi = collationIndex(b);\r\n    if ((ai - bi) !== 0) {\r\n      return ai - bi;\r\n    }\r\n    if (a === null) {\r\n      return 0;\r\n    }\r\n    if (typeof a === 'number') {\r\n      return a - b;\r\n    }\r\n    if (typeof a === 'boolean') {\r\n      return a < b ? -1 : 1;\r\n    }\r\n    if (typeof a === 'string') {\r\n      return stringCollate(a, b);\r\n    }\r\n    if (Array.isArray(a)) {\r\n      return arrayCollate(a, b)\r\n    }\r\n    if (typeof a === 'object') {\r\n      return objectCollate(a, b);\r\n    }\r\n  }\r\n\r\n  var stringCollate = function(a, b) {\r\n    // See: https://github.com/daleharvey/pouchdb/issues/40\r\n    // This is incompatible with the CouchDB implementation, but its the\r\n    // best we can do for now\r\n    return (a === b) ? 0 : ((a > b) ? 1 : -1);\r\n  }\r\n\r\n  var objectCollate = function(a, b) {\r\n    var ak = Object.keys(a), bk = Object.keys(b);\r\n    var len = Math.min(ak.length, bk.length);\r\n    for (var i = 0; i < len; i++) {\r\n      // First sort the keys\r\n      var sort = Pouch.collate(ak[i], bk[i]);\r\n      if (sort !== 0) {\r\n        return sort;\r\n      }\r\n      // if the keys are equal sort the values\r\n      sort = Pouch.collate(a[ak[i]], b[bk[i]]);\r\n      if (sort !== 0) {\r\n        return sort;\r\n      }\r\n\r\n    }\r\n    return (ak.length === bk.length) ? 0 :\r\n      (ak.length > bk.length) ? 1 : -1;\r\n  }\r\n\r\n  var arrayCollate = function(a, b) {\r\n    var len = Math.min(a.length, b.length);\r\n    for (var i = 0; i < len; i++) {\r\n      var sort = Pouch.collate(a[i], b[i]);\r\n      if (sort !== 0) {\r\n        return sort;\r\n      }\r\n    }\r\n    return (a.length === b.length) ? 0 :\r\n      (a.length > b.length) ? 1 : -1;\r\n  }\r\n\r\n  // The collation is defined by erlangs ordered terms\r\n  // the atoms null, true, false come first, then numbers, strings,\r\n  // arrays, then objects\r\n  var collationIndex = function(x) {\r\n    var id = ['boolean', 'number', 'string', 'object'];\r\n    if (id.indexOf(typeof x) !== -1) {\r\n      if (x === null) {\r\n        return 1;\r\n      }\r\n      return id.indexOf(typeof x) + 2;\r\n    }\r\n    if (Array.isArray(x)) {\r\n      return 4.5;\r\n    }\r\n  }\r\n\r\n}).call(this);\r\n\r\n(function() {\r\n  // a few hacks to get things in the right place for node.js\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = Pouch;\r\n    var utils = require('./pouch.utils.js');\r\n    for (var k in utils) {\r\n      global[k] = utils[k];\r\n    }\r\n  }\r\n\r\n  // for a better overview of what this is doing, read:\r\n  // https://github.com/apache/couchdb/blob/master/src/couchdb/couch_key_tree.erl\r\n  //\r\n  // But for a quick intro, CouchDB uses a revision tree to store a documents\r\n  // history, A -> B -> C, when a document has conflicts, that is a branch in the\r\n  // tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\r\n  //\r\n  // KeyTree = [Path ... ]\r\n  // Path = {pos: position_from_root, ids: Tree}\r\n  // Tree = [Key, Tree]\r\n\r\n  // Turn a path as a flat array into a tree with a single branch\r\n  function pathToTree(path) {\r\n    var root = [path.shift(), []];\r\n    var leaf = root;\r\n    while (path.length) {\r\n      nleaf = [path.shift(), []];\r\n      leaf[1].push(nleaf);\r\n      leaf = nleaf;\r\n    }\r\n    return root;\r\n  }\r\n\r\n  // To ensure we dont grow the revision tree infinitely, we stem old revisions\r\n  function stem(tree, depth) {\r\n    // First we break out the tree into a complete list of root to leaf paths,\r\n    // we cut off the start of the path and generate a new set of flat trees\r\n    var stemmedPaths = rootToLeaf(tree).map(function(path) {\r\n      var stemmed = path.ids.slice(-depth);\r\n      return {\r\n        pos: path.pos + (path.ids.length - stemmed.length),\r\n        ids: pathToTree(stemmed)\r\n      };\r\n    });\r\n    // Then we remerge all those flat trees together, ensuring that we dont\r\n    // connect trees that would go beyond the depth limit\r\n    return stemmedPaths.reduce(function(prev, current, i, arr) {\r\n      return doMerge(prev, current, true).tree;\r\n    }, [stemmedPaths.shift()]);\r\n  }\r\n\r\n  // Merge two trees together\r\n  // The roots of tree1 and tree2 must be the same revision\r\n  function mergeTree(tree1, tree2) {\r\n    var conflicts = false;\r\n    for (var i = 0; i < tree2[1].length; i++) {\r\n      if (!tree1[1][0]) {\r\n        conflicts = 'new_leaf';\r\n        tree1[1][0] = tree2[1][i];\r\n      }\r\n\r\n      var merged = false;\r\n      for (var j = 0; j < tree1[1].length; j++) {\r\n        if (tree1[1][j][0] == tree2[1][i][0]) {\r\n          var result = mergeTree(tree1[1][j], tree2[1][i]);\r\n          conflicts = result.conflicts || conflicts;\r\n          tree1[1][j] = result.tree;\r\n          merged = true;\r\n        }\r\n      }\r\n      if (!merged) {\r\n        conflicts = 'new_branch';\r\n        tree1[1].push(tree2[1][i]);\r\n        tree1[1].sort();\r\n      }\r\n    }\r\n\r\n    return {conflicts: conflicts, tree: tree1};\r\n  }\r\n\r\n  function doMerge(tree, path, dontExpand) {\r\n    var restree = [];\r\n    var conflicts = false;\r\n    var merged = false;\r\n    var res, branch;\r\n\r\n    if (!tree.length) {\r\n      return {tree: [path], conflicts: 'new_leaf'};\r\n    }\r\n\r\n    tree.forEach(function(branch) {\r\n      if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\r\n        // Paths start at the same position and have the same root, so they need\r\n        // merged\r\n        res = mergeTree(branch.ids, path.ids);\r\n        restree.push({pos: branch.pos, ids: res.tree});\r\n        conflicts = conflicts || res.conflicts;\r\n        merged = true;\r\n      } else if (dontExpand !== true) {\r\n        // The paths start at a different position, take the earliest path and\r\n        // traverse up until it as at the same point from root as the path we want to\r\n        // merge.  If the keys match we return the longer path with the other merged\r\n        // After stemming we dont want to expand the trees\r\n\r\n        var t1 = branch.pos < path.pos ? branch : path;\r\n        var t2 = branch.pos < path.pos ? path : branch;\r\n        var diff = t2.pos - t1.pos;\r\n\r\n        var candidateParents = [];\r\n        function treeWalk(ids, diff, parent, parentIdx) {\r\n          if (diff == 0) {\r\n            if (ids[0] == t2.ids[0]) {\r\n              candidateParents.push({parent: parent, ids: ids, parentIdx: parentIdx});\r\n            }\r\n            return;\r\n          }\r\n          if (!ids) return;\r\n          ids[1].forEach(function(el, idx) {\r\n            treeWalk(el, diff-1, ids, idx);\r\n          });\r\n        }\r\n\r\n        treeWalk(t1.ids, diff, undefined);\r\n\r\n        var el = candidateParents[0];\r\n\r\n        if (!el) {\r\n          restree.push(branch);\r\n        } else {\r\n          res = mergeTree(el.ids, t2.ids);\r\n          el.parent[1][el.parentIdx] = res.tree;\r\n          restree.push({pos: t1.pos, ids: t1.ids});\r\n          conflicts = conflicts || res.conflicts;\r\n          merged = true;\r\n        }\r\n      } else {\r\n        restree.push(branch);\r\n      }\r\n    });\r\n\r\n    // We didnt find\r\n    if (!merged) {\r\n      restree.push(path);\r\n    }\r\n\r\n    restree.sort(function(a, b) {\r\n      return a.pos - b.pos;\r\n    });\r\n\r\n    return {\r\n      tree: restree,\r\n      conflicts: conflicts || 'internal_node'\r\n    };\r\n  }\r\n\r\n  Pouch.merge = function(tree, path, depth) {\r\n    // Ugh, nicer way to not modify arguments in place?\r\n    tree = JSON.parse(JSON.stringify(tree));\r\n    path = JSON.parse(JSON.stringify(path));\r\n    var newTree = doMerge(tree, path);\r\n    return {\r\n      tree: stem(newTree.tree, depth),\r\n      conflicts: newTree.conflicts\r\n    };\r\n  };\r\n\r\n}).call(this);\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = Pouch;\r\n}\r\n\r\n(function() {\r\n\r\n  function replicate(src, target, opts, callback, replicateRet) {\r\n\r\n    fetchCheckpoint(src, target, function(checkpoint) {\r\n      var results = [];\r\n      var completed = false;\r\n      var pending = 0;\r\n      var last_seq = checkpoint;\r\n      var continuous = opts.continuous || false;\r\n      var result = {\r\n        ok: true,\r\n        start_time: new Date(),\r\n        docs_read: 0,\r\n        docs_written: 0\r\n      };\r\n\r\n      function isCompleted() {\r\n        if (completed && pending === 0) {\r\n          result.end_time = new Date();\r\n          writeCheckpoint(src, target, last_seq, function() {\r\n            call(callback, null, result);\r\n          });\r\n        }\r\n      }\r\n\r\n      if (replicateRet.cancelled) {\r\n        return;\r\n      }\r\n\r\n      var repOpts = {\r\n        continuous: continuous,\r\n        since: checkpoint,\r\n        onChange: function(change) {\r\n          last_seq = change.seq;\r\n          results.push(change);\r\n          result.docs_read++;\r\n          pending++;\r\n          var diff = {};\r\n          diff[change.id] = change.changes.map(function(x) { return x.rev; });\r\n          target.revsDiff(diff, function(err, diffs) {\r\n            if (err) {\r\n              if (continuous)\r\n                replicateRet.cancel();\r\n              call(callback, err, null);\r\n              return;\r\n            }\r\n            if (Object.keys(diffs).length === 0) {\r\n              pending--;\r\n              isCompleted();\r\n              return;\r\n            }\r\n            for (var id in diffs) {\r\n              diffs[id].missing.map(function(rev) {\r\n                src.get(id, {revs: true, rev: rev, attachments: true}, function(err, doc) {\r\n                  target.bulkDocs({docs: [doc]}, {new_edits: false}, function() {\r\n                    if (opts.onChange) {\r\n                      opts.onChange.apply(this, [result]);\r\n                    }\r\n                    result.docs_written++;\r\n                    pending--;\r\n                    isCompleted();\r\n                  });\r\n                });\r\n              });\r\n            }\r\n          });\r\n        },\r\n        complete: function(err, res) {\r\n          completed = true;\r\n          isCompleted();\r\n        }\r\n      };\r\n\r\n      if (opts.filter) {\r\n        repOpts.filter = opts.filter;\r\n      }\r\n\r\n      if (opts.query_params) {\r\n        repOpts.query_params = opts.query_params;\r\n      }\r\n\r\n      var changes = src.changes(repOpts);\r\n      if (opts.continuous) {\r\n        replicateRet.cancel = changes.cancel;\r\n      }\r\n    });\r\n  }\r\n\r\n  function toPouch(db, callback) {\r\n    if (typeof db === 'string') {\r\n      return new Pouch(db, callback);\r\n    }\r\n    callback(null, db);\r\n  }\r\n\r\n  Pouch.replicate = function(src, target, opts, callback) {\r\n    // TODO: This needs some cleaning up, from the replicate call I want\r\n    // to return a promise in which I can cancel continuous replications\r\n    // this will just proxy requests to cancel the changes feed but only\r\n    // after we start actually running the changes feed\r\n    if (opts instanceof Function) {\r\n      callback = opts;\r\n      opts = {}\r\n    }\r\n    if (opts === undefined) {\r\n      opts = {};\r\n    }\r\n\r\n    var ret = function() {\r\n      this.cancelled = false;\r\n      this.cancel = function() {\r\n        this.cancelled = true;\r\n      }\r\n    }\r\n    var replicateRet = new ret();\r\n    toPouch(src, function(err, src) {\r\n      if (err) {\r\n        return call(callback, err);\r\n      }\r\n      toPouch(target, function(err, target) {\r\n        if (err) {\r\n          return call(callback, err);\r\n        }\r\n        replicate(src, target, opts, callback, replicateRet);\r\n      });\r\n    });\r\n    return replicateRet;\r\n  };\r\n\r\n}).call(this);\r\n\r\n// Pretty dumb name for a function, just wraps callback calls so we dont\r\n// to if (callback) callback() everywhere\r\nvar call = function(fun) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  if (typeof fun === typeof Function) {\r\n    fun.apply(this, args);\r\n  }\r\n}\r\n\r\n// Wrapper for functions that call the bulkdocs api with a single doc,\r\n// if the first result is an error, return an error\r\nvar yankError = function(callback) {\r\n  return function(err, results) {\r\n    if (err || results[0].error) {\r\n      call(callback, err || results[0]);\r\n    } else {\r\n      call(callback, null, results[0]);\r\n    }\r\n  };\r\n};\r\n\r\nvar isAttachmentId = function(id) {\r\n  return (/\\//.test(id)\r\n      && !/^_local/.test(id)\r\n      && !/^_design/.test(id));\r\n}\r\n\r\n// Parse document ids: docid[/attachid]\r\n//   - /attachid is optional, and can have slashes in it too\r\n//   - int ids and strings beginning with _design or _local are not split\r\n// returns an object: { docId: docid, attachmentId: attachid }\r\nvar parseDocId = function(id) {\r\n  var ids = (typeof id === 'string') && !(/^_(design|local)\\//.test(id))\r\n    ? id.split('/')\r\n    : [id]\r\n  return {\r\n    docId: ids[0],\r\n    attachmentId: ids.splice(1).join('/').replace(/^\\/+/, '')\r\n  }\r\n}\r\n\r\n// check if a specific revision of a doc has been deleted\r\n//  - metadata: the metadata object from the doc store\r\n//  - rev: (optional) the revision to check. defaults to metadata.rev\r\nvar isDeleted = function(metadata, rev) {\r\n  if (!metadata || !metadata.deletions) return false;\r\n  if (!rev) {\r\n    rev = winningRev(metadata);\r\n  }\r\n  if (rev.indexOf('-') >= 0) {\r\n    rev = rev.split('-')[1];\r\n  }\r\n\r\n  return metadata.deletions[rev] === true;\r\n}\r\n\r\n// Determine id an ID is valid\r\n//   - invalid IDs begin with an underescore that does not begin '_design' or '_local'\r\n//   - any other string value is a valid id\r\nvar isValidId = function(id) {\r\n  if (/^_/.test(id)) {\r\n    return /^_(design|local)/.test(id);\r\n  }\r\n  return true;\r\n}\r\n\r\n// Preprocess documents, parse their revisions, assign an id and a\r\n// revision for new writes that are missing them, etc\r\nvar parseDoc = function(doc, newEdits) {\r\n  var error = null;\r\n\r\n  // check for an attachment id and add attachments as needed\r\n  if (doc._id) {\r\n    var id = parseDocId(doc._id);\r\n    if (id.attachmentId !== '') {\r\n      var attachment = btoa(JSON.stringify(doc));\r\n      doc = {\r\n        _id: id.docId,\r\n      }\r\n      if (!doc._attachments) {\r\n        doc._attachments = {};\r\n      }\r\n      doc._attachments[id.attachmentId] = {\r\n        content_type: 'application/json',\r\n        data: attachment\r\n      }\r\n    }\r\n  }\r\n\r\n  if (newEdits) {\r\n    if (!doc._id) {\r\n      doc._id = Math.uuid();\r\n    }\r\n    var newRevId = Math.uuid(32, 16).toLowerCase();\r\n    var nRevNum;\r\n    if (doc._rev) {\r\n      var revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\r\n      if (!revInfo) {\r\n        throw \"invalid value for property '_rev'\";\r\n      }\r\n      doc._rev_tree = [{\r\n        pos: parseInt(revInfo[1], 10),\r\n        ids: [revInfo[2], [[newRevId, []]]]\r\n      }];\r\n      nRevNum = parseInt(revInfo[1], 10) + 1;\r\n    } else {\r\n      doc._rev_tree = [{\r\n        pos: 1,\r\n        ids : [newRevId, []]\r\n      }];\r\n      nRevNum = 1;\r\n    }\r\n  } else {\r\n    if (doc._revisions) {\r\n      doc._rev_tree = [{\r\n        pos: doc._revisions.start - doc._revisions.ids.length + 1,\r\n        ids: doc._revisions.ids.reduce(function(acc, x) {\r\n          if (acc === null) {\r\n            return [x, []];\r\n          } else {\r\n            return [x, [acc]];\r\n          }\r\n        }, null)\r\n      }];\r\n      nRevNum = doc._revisions.start;\r\n      newRevId = doc._revisions.ids[0];\r\n    }\r\n    if (!doc._rev_tree) {\r\n      var revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\r\n      nRevNum = parseInt(revInfo[1], 10);\r\n      newRevId = revInfo[2];\r\n      doc._rev_tree = [{\r\n        pos: parseInt(revInfo[1], 10),\r\n        ids: [revInfo[2], []]\r\n      }];\r\n    }\r\n  }\r\n\r\n  if (typeof doc._id !== 'string') {\r\n    error = Pouch.Errors.INVALID_ID;\r\n  }\r\n  else if (!isValidId(doc._id)) {\r\n    error = Pouch.Errors.RESERVED_ID;\r\n  }\r\n\r\n  doc._id = decodeURIComponent(doc._id);\r\n  doc._rev = [nRevNum, newRevId].join('-');\r\n\r\n  if (error) {\r\n    return error;\r\n  }\r\n\r\n  return Object.keys(doc).reduce(function(acc, key) {\r\n    if (/^_/.test(key) && key !== '_attachments') {\r\n      acc.metadata[key.slice(1)] = doc[key];\r\n    } else {\r\n      acc.data[key] = doc[key];\r\n    }\r\n    return acc;\r\n  }, {metadata : {}, data : {}});\r\n};\r\n\r\nvar compareRevs = function(a, b) {\r\n  // Sort by id\r\n  if (a.id !== b.id) {\r\n    return (a.id < b.id ? -1 : 1);\r\n  }\r\n  // Then by deleted\r\n  if (a.deleted ^ b.deleted) {\r\n    return (a.deleted ? -1 : 1);\r\n  }\r\n  // Then by rev id\r\n  if (a.rev_tree[0].pos === b.rev_tree[0].pos) {\r\n    return (a.rev_tree[0].ids < b.rev_tree[0].ids ? -1 : 1);\r\n  }\r\n  // Then by depth of edits\r\n  return (a.rev_tree[0].start < b.rev_tree[0].start ? -1 : 1);\r\n};\r\n\r\n// Pretty much all below can be combined into a higher order function to\r\n// traverse revisions\r\n// Turn a tree into a list of rootToLeaf paths\r\nvar expandTree = function(all, i, tree) {\r\n  all.push({rev: i + '-' + tree[0], status: 'available'});\r\n  tree[1].forEach(function(child) {\r\n    expandTree(all, i + 1, child);\r\n  });\r\n}\r\n\r\nvar collectRevs = function(path) {\r\n  var revs = [];\r\n  expandTree(revs, path.pos, path.ids);\r\n  return revs;\r\n}\r\n\r\nvar collectLeavesInner = function(all, pos, tree) {\r\n  if (!tree[1].length) {\r\n    all.push({rev: pos + '-' + tree[0]});\r\n  }\r\n  tree[1].forEach(function(child) {\r\n    collectLeavesInner(all, pos+1, child);\r\n  });\r\n}\r\n\r\nvar collectLeaves = function(revs) {\r\n  var leaves = [];\r\n  revs.forEach(function(tree) {\r\n    collectLeavesInner(leaves, tree.pos, tree.ids);\r\n  });\r\n  return leaves;\r\n}\r\n\r\nvar collectConflicts = function(revs) {\r\n  var leaves = collectLeaves(revs);\r\n  // First is current rev\r\n  leaves.shift();\r\n  return leaves.map(function(x) { return x.rev; });\r\n}\r\n\r\nvar fetchCheckpoint = function(src, target, callback) {\r\n  var id = Crypto.MD5(src.id() + target.id());\r\n  src.get('_local/' + id, function(err, doc) {\r\n    if (err && err.status === 404) {\r\n      callback(0);\r\n    } else {\r\n      callback(doc.last_seq);\r\n    }\r\n  });\r\n};\r\n\r\nvar writeCheckpoint = function(src, target, checkpoint, callback) {\r\n  var check = {\r\n    _id: '_local/' + Crypto.MD5(src.id() + target.id()),\r\n    last_seq: checkpoint\r\n  };\r\n  src.get(check._id, function(err, doc) {\r\n    if (doc && doc._rev) {\r\n      check._rev = doc._rev;\r\n    }\r\n    src.put(check, function(err, doc) {\r\n      callback();\r\n    });\r\n  });\r\n};\r\n\r\n// Turn a tree into a list of rootToLeaf paths\r\nfunction expandTree2(all, current, pos, arr) {\r\n  current = current.slice(0);\r\n  current.push(arr[0]);\r\n  if (!arr[1].length) {\r\n    all.push({pos: pos, ids: current});\r\n  }\r\n  arr[1].forEach(function(child) {\r\n    expandTree2(all, current, pos, child);\r\n  });\r\n}\r\n\r\n// We fetch all leafs of the revision tree, and sort them based on tree length\r\n// and whether they were deleted, undeleted documents with the longest revision\r\n// tree (most edits) win\r\n// The final sort algorithm is slightly documented in a sidebar here:\r\n// http://guide.couchdb.org/draft/conflicts.html\r\nvar winningRev = function(metadata) {\r\n  var deletions = metadata.deletions || {};\r\n  var leafs = [];\r\n\r\n  function treeLeaf(pos, tree) {\r\n    if (!tree[1].length) {\r\n      leafs.push({pos: pos, id: tree[0]});\r\n    }\r\n    tree[1].forEach(function(branch) {\r\n      treeLeaf(pos + 1, branch);\r\n    });\r\n  }\r\n\r\n  metadata.rev_tree.forEach(function(tree) {\r\n    treeLeaf(tree.pos, tree.ids);\r\n  });\r\n\r\n  leafs.forEach(function(leaf) {\r\n    leaf.deleted = leaf.id in deletions;\r\n  });\r\n\r\n  leafs.sort(function(a, b) {\r\n    if (a.deleted !== b.deleted) {\r\n      return a.deleted > b.deleted ? 1 : -1;\r\n    }\r\n    if (a.pos !== b.pos) {\r\n      return b.pos - a.pos;\r\n    }\r\n    return a.id < b.id ? 1 : -1;\r\n  });\r\n  return leafs[0].pos + '-' + leafs[0].id;\r\n}\r\n\r\nvar rootToLeaf = function(tree) {\r\n  var all = [];\r\n  tree.forEach(function(path) {\r\n    expandTree2(all, [], path.pos, path.ids);\r\n  });\r\n  return all;\r\n}\r\n\r\nvar arrayFirst = function(arr, callback) {\r\n  for (var i = 0; i < arr.length; i++) {\r\n    if (callback(arr[i], i) === true) {\r\n      return arr[i];\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nvar filterChange = function(opts) {\r\n  return function(change) {\r\n    if (opts.filter && !opts.filter.call(this, change.doc)) {\r\n      return;\r\n    }\r\n    if (!opts.include_docs) {\r\n      delete change.doc;\r\n    }\r\n    call(opts.onChange, change);\r\n  }\r\n}\r\n\r\nvar ajax = function ajax(options, callback) {\r\n  if (options.success && callback === undefined) {\r\n    callback = options.success;\r\n  }\r\n\r\n  var success = function sucess(obj, _, xhr) {\r\n    // Chrome will parse some attachments that are JSON. We don't want that.\r\n    if (options.dataType === false && typeof obj !== 'string') {\r\n      obj = JSON.stringify(obj);\r\n    }\r\n    call(callback, null, obj, xhr);\r\n  };\r\n  var error = function error(err) {\r\n    if (err) {\r\n      var errObj = err.responseText\r\n        ? {status: err.status}\r\n        : err\r\n      try {\r\n        errObj = $.extend({}, errObj, JSON.parse(err.responseText));\r\n      } catch (e) {}\r\n      call(callback, errObj);\r\n    } else {\r\n      call(callback, true);\r\n    }\r\n  };\r\n\r\n  var defaults = {\r\n    success: success,\r\n    error: error,\r\n    headers: {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n    },\r\n    dataType: 'json',\r\n    timeout: 10000\r\n  };\r\n  options = $.extend({}, defaults, options);\r\n\r\n  if (options.data && typeof options.data !== 'string') {\r\n    options.data = JSON.stringify(options.data);\r\n  }\r\n  if (options.auth) {\r\n    options.beforeSend = function(xhr) {\r\n      var token = btoa(options.auth.username + \":\" + options.auth.password);\r\n      xhr.setRequestHeader(\"Authorization\", \"Basic \" + token);\r\n    }\r\n  }\r\n\r\n  if ($.ajax) {\r\n    return $.ajax(options);\r\n  }\r\n  else {\r\n    // convert options from xhr api to request api\r\n    if (options.data) {\r\n      options.body = options.data;\r\n      delete options.data;\r\n    }\r\n    if (options.type) {\r\n      options.method = options.type;\r\n      delete options.type;\r\n    }\r\n    if (options.auth) {\r\n      var token = btoa(options.auth.username + ':' + options.auth.password);\r\n      options.headers['Authorization'] = 'Basic ' + token;\r\n    }\r\n\r\n    return request(options, function(err, response, body) {\r\n      if (err) {\r\n        err.status = response ? response.statusCode : 400;\r\n        return call(options.error, err);\r\n      }\r\n\r\n      var content_type = response.headers['content-type']\r\n        , data = (body || '');\r\n\r\n      // CouchDB doesn't always return the right content-type for JSON data, so\r\n      // we check for ^{ and }$ (ignoring leading/trailing whitespace)\r\n      if (options.dataType && (/json/.test(content_type)\r\n          || (/^[\\s]*{/.test(data) && /}[\\s]*$/.test(data)))) {\r\n        data = JSON.parse(data);\r\n      }\r\n\r\n      if (data.error) {\r\n        data.status = response.statusCode;\r\n        call(options.error, data);\r\n      }\r\n      else {\r\n        call(options.success, data, 'OK', response);\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n// Basic wrapper for localStorage\r\nvar win = this;\r\nvar localJSON = (function(){\r\n  if (!win.localStorage) {\r\n    return false;\r\n  }\r\n  return {\r\n    set: function(prop, val) {\r\n      localStorage.setItem(prop, JSON.stringify(val));\r\n    },\r\n    get: function(prop, def) {\r\n      try {\r\n        if (localStorage.getItem(prop) === null) {\r\n          return def;\r\n        }\r\n        return JSON.parse((localStorage.getItem(prop) || 'false'));\r\n      } catch(err) {\r\n        return def;\r\n      }\r\n    },\r\n    remove: function(prop) {\r\n      localStorage.removeItem(prop);\r\n    }\r\n  };\r\n})();\r\n\r\n// btoa and atob don't exist in node. see https://developer.mozilla.org/en-US/docs/DOM/window.btoa\r\nif (typeof btoa === 'undefined') {\r\n  btoa = function(str) {\r\n    return new Buffer(unescape(encodeURIComponent(str)), 'binary').toString('base64');\r\n  }\r\n}\r\nif (typeof atob === 'undefined') {\r\n  atob = function(str) {\r\n    return decodeURIComponent(escape(new Buffer(str, 'base64').toString('binary')));\r\n  }\r\n}\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  // use node.js's crypto library instead of the Crypto object created by deps/uuid.js\r\n  var crypto = require('crypto');\r\n  var Crypto = {\r\n    MD5: function(str) {\r\n      return crypto.createHash('md5').update(str).digest('hex');\r\n    }\r\n  }\r\n  request = require('request');\r\n  _ = require('underscore');\r\n  $ = _;\r\n\r\n  module.exports = {\r\n    Crypto: Crypto,\r\n    call: call,\r\n    yankError: yankError,\r\n    isAttachmentId: isAttachmentId,\r\n    parseDocId: parseDocId,\r\n    parseDoc: parseDoc,\r\n    isDeleted: isDeleted,\r\n    compareRevs: compareRevs,\r\n    expandTree: expandTree,\r\n    collectRevs: collectRevs,\r\n    collectLeavesInner: collectLeavesInner,\r\n    collectLeaves: collectLeaves,\r\n    collectConflicts: collectConflicts,\r\n    fetchCheckpoint: fetchCheckpoint,\r\n    writeCheckpoint: writeCheckpoint,\r\n    winningRev: winningRev,\r\n    rootToLeaf: rootToLeaf,\r\n    arrayFirst: arrayFirst,\r\n    filterChange: filterChange,\r\n    ajax: ajax,\r\n    atob: atob,\r\n    btoa: btoa,\r\n  }\r\n}\r\n\r\n\"use strict\";\r\n\r\nvar HTTP_TIMEOUT = 10000;\r\n\r\n// parseUri 1.2.2\r\n// (c) Steven Levithan <stevenlevithan.com>\r\n// MIT License\r\nfunction parseUri (str) {\r\n  var o = parseUri.options;\r\n  var m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\r\n  var uri = {};\r\n  var i = 14;\r\n\r\n  while (i--) uri[o.key[i]] = m[i] || \"\";\r\n\r\n  uri[o.q.name] = {};\r\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\r\n    if ($1) uri[o.q.name][$1] = $2;\r\n  });\r\n\r\n  return uri;\r\n}\r\n\r\nparseUri.options = {\r\n  strictMode: false,\r\n  key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\r\n        \"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\r\n  q:   {\r\n    name:   \"queryKey\",\r\n    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\r\n  },\r\n  parser: {\r\n    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\r\n    loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\r\n  }\r\n};\r\n\r\n// Get all the information you possibly can about the URI given by name and\r\n// return it as a suitable object.\r\nfunction getHost(name) {\r\n  // If the given name contains \"http:\"\r\n  if (/http(s?):/.test(name)) {\r\n    // Prase the URI into all its little bits\r\n    var uri = parseUri(name);\r\n\r\n    // Store the fact that it is a remote URI\r\n    uri.remote = true;\r\n\r\n    // Store the user and password as a separate auth object\r\n    if (uri.user || uri.password) {\r\n      uri.auth = {username: uri.user, password: uri.password};\r\n    }\r\n\r\n    // Split the path part of the URI into parts using '/' as the delimiter\r\n    // after removing any leading '/' and any trailing '/'\r\n    var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\r\n\r\n    // Store the first part as the database name and remove it from the parts\r\n    // array\r\n    uri.db = parts.pop();\r\n\r\n    // Restore the path by joining all the remaining parts (all the parts\r\n    // except for the database name) with '/'s\r\n    uri.path = parts.join('/');\r\n\r\n    return uri;\r\n  }\r\n\r\n  // If the given name does not contain 'http:' then return a very basic object\r\n  // with no host, the current path, the given name as the database name and no\r\n  // username/password\r\n  return {host: '', path: '/', db: name, auth: false};\r\n}\r\n\r\n// Generate a URL with the host data given by opts and the given path\r\nfunction genDBUrl(opts, path) {\r\n  // If the host is remote\r\n  if (opts.remote) {\r\n    // If the host already has a path, then we need to have a path delimiter\r\n    // Otherwise, the path delimiter is the empty string\r\n    var pathDel = !opts.path ? '' : '/';\r\n\r\n    // Return the URL made up of all the host's information and the given path\r\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' +\r\n      opts.path + pathDel + opts.db + '/' + path;\r\n  }\r\n\r\n  // If the host is not remote, then return the URL made up of just the\r\n  // database name and the given path\r\n  return '/' + opts.db + '/' + path;\r\n}\r\n\r\n// Generate a URL with the host data given by opts and the given path\r\nfunction genUrl(opts, path) {\r\n  if (opts.remote) {\r\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' + path;\r\n  }\r\n  return '/' + path;\r\n}\r\n\r\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\r\nvar HttpPouch = function(opts, callback) {\r\n\r\n  // Parse the URI given by opts.name into an easy-to-use object\r\n  var host = getHost(opts.name);\r\n\r\n  // Generate the database URL based on the host\r\n  var db_url = genDBUrl(host, '');\r\n\r\n  // The functions that will be publically available for HttpPouch\r\n  var api = {};\r\n\r\n  var uuids = {\r\n    list: [],\r\n    get: function(opts, callback) {\r\n      if (typeof opts === 'function') {\r\n        callback = opts;\r\n        opts = {count: 10};\r\n      }\r\n      var cb = function(err, body) {\r\n        if (err || !('uuids' in body)) {\r\n          call(callback, err || Pouch.Errors.UNKNOWN_ERROR);\r\n        } else {\r\n          uuids.list = uuids.list.concat(body.uuids);\r\n          call(callback, null, \"OK\");\r\n        }\r\n      };\r\n      var params = '?count=' + opts.count;\r\n      ajax({\r\n        auth: host.auth,\r\n        type: 'GET',\r\n        url: genUrl(host, '_uuids') + params\r\n      }, cb);\r\n    }\r\n  };\r\n\r\n  // Create a new CouchDB database based on the given opts\r\n  var createDB = function(){\r\n    ajax({auth: host.auth, type: 'PUT', url: db_url}, function(err, ret) {\r\n      // If we get an \"Unauthorized\" error\r\n      if (err && err.status === 401) {\r\n        // Test if the database already exists\r\n        ajax({auth: host.auth, type: 'HEAD', url: db_url}, function (err, ret) {\r\n          // If there is still an error\r\n          if (err) {\r\n            // Give the error to the callback to deal with\r\n            call(callback, err);\r\n          } else {\r\n            // Continue as if there had been no errors\r\n            call(callback, null, api);\r\n          }\r\n        });\r\n        // If there were no errros or if the only error is \"Precondition Failed\"\r\n        // (note: \"Precondition Failed\" occurs when we try to create a database\r\n        // that already exists)\r\n      } else if (!err || err.status === 412) {\r\n        // Continue as if there had been no errors\r\n        call(callback, null, api);\r\n      } else {\r\n        call(callback, Pouch.Errors.UNKNOWN_ERROR);\r\n      }\r\n    });\r\n  };\r\n  ajax({auth: host.auth, type: 'GET', url: db_url}, function(err, ret) {\r\n    //check if the db exists\r\n    if (err) {\r\n      if (err.status === 404) {\r\n        //if it doesn't, create it\r\n        createDB();\r\n      } else {\r\n        call(callback, err);\r\n      }\r\n    } else {\r\n      //go do stuff with the db\r\n      call(callback, null, api);\r\n      }\r\n  });\r\n\r\n  api.type = function() {\r\n    return 'http';\r\n  };\r\n\r\n  // The HttpPouch's ID is its URL\r\n  api.id = function() {\r\n    return genDBUrl(host, '');\r\n  };\r\n\r\n  api.request = function(options, callback) {\r\n    options.auth = host.auth;\r\n    options.url = genDBUrl(host, options.url);\r\n    ajax(options, callback);\r\n  };\r\n\r\n  // Calls GET on the host, which gets back a JSON string containing\r\n  //    couchdb: A welcome string\r\n  //    version: The version of CouchDB it is running\r\n  api.info = function(callback) {\r\n    ajax({\r\n      auth: host.auth,\r\n      type:'GET',\r\n      url: genDBUrl(host, ''),\r\n    }, callback);\r\n  };\r\n\r\n  // Get the document with the given id from the database given by host.\r\n  // The id could be solely the _id in the database, or it may be a\r\n  // _design/ID or _local/ID path\r\n  api.get = function(id, opts, callback) {\r\n    // If no options were given, set the callback to the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // List of parameters to add to the GET request\r\n    var params = [];\r\n\r\n    // If it exists, add the opts.revs value to the list of parameters.\r\n    // If revs=true then the resulting JSON will include a field\r\n    // _revisions containing an array of the revision IDs.\r\n    if (opts.revs) {\r\n      params.push('revs=true');\r\n    }\r\n\r\n    // If it exists, add the opts.revs_info value to the list of parameters.\r\n    // If revs_info=true then the resulting JSON will include the field\r\n    // _revs_info containing an array of objects in which each object\r\n    // representing an available revision.\r\n    if (opts.revs_info) {\r\n      params.push('revs_info=true');\r\n    }\r\n\r\n    // If it exists, add the opts.attachments value to the list of parameters.\r\n    // If attachments=true the resulting JSON will include the base64-encoded\r\n    // contents in the \"data\" property of each attachment.\r\n    if (opts.attachments) {\r\n      params.push('attachments=true');\r\n    }\r\n\r\n    // If it exists, add the opts.rev value to the list of parameters.\r\n    // If rev is given a revision number then get the specified revision.\r\n    if (opts.rev) {\r\n      params.push('rev=' + opts.rev);\r\n    }\r\n\r\n    // If it exists, add the opts.conflicts value to the list of parameters.\r\n    // If conflicts=true then the resulting JSON will include the field\r\n    // _conflicts containing all the conflicting revisions.\r\n    if (opts.conflicts) {\r\n      params.push('conflicts=' + opts.conflicts);\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    params = params === '' ? '' : '?' + params;\r\n\r\n    // Set the options for the ajax call\r\n    var options = {\r\n      auth: host.auth,\r\n      type: 'GET',\r\n      url: genDBUrl(host, id + params)\r\n    };\r\n\r\n    // If the given id contains at least one '/' and the part before the '/'\r\n    // is NOT \"_design\" and is NOT \"_local\"\r\n    // OR\r\n    // If the given id contains at least two '/' and the part before the first\r\n    // '/' is \"_design\".\r\n    // TODO This second condition seems strange since if parts[0] === '_design'\r\n    // then we already know that parts[0] !== '_local'.\r\n    var parts = id.split('/');\r\n    if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||\r\n        (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {\r\n      // Nothing is expected back from the server\r\n      options.dataType = false;\r\n    }\r\n\r\n    // Get the document\r\n    ajax(options, function(err, doc, xhr) {\r\n      // If the document does not exist, send an error to the callback\r\n      if (err) {\r\n        return call(callback, Pouch.Errors.MISSING_DOC);\r\n      }\r\n\r\n      // Send the document to the callback\r\n      call(callback, null, doc, xhr);\r\n    });\r\n  };\r\n\r\n  // Delete the document given by doc from the database given by host.\r\n  api.remove = function(doc, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // Delete the document\r\n    ajax({\r\n      auth: host.auth,\r\n      type:'DELETE',\r\n      url: genDBUrl(host, doc._id) + '?rev=' + doc._rev\r\n    }, callback);\r\n  };\r\n\r\n  // Remove the attachment given by the id and rev\r\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\r\n    ajax({\r\n      auth: host.auth,\r\n      type: 'DELETE',\r\n      url: genDBUrl(host, id) + '?rev=' + rev,\r\n    }, callback);\r\n  };\r\n\r\n  // Add the attachment given by doc and the content type given by type\r\n  // to the document with the given id, the revision given by rev, and\r\n  // add it to the database given by host.\r\n  api.putAttachment = function(id, rev, doc, type, callback) {\r\n    // Add the attachment\r\n    ajax({\r\n      auth: host.auth,\r\n      type:'PUT',\r\n      url: genDBUrl(host, id) + '?rev=' + rev,\r\n      headers: {'Content-Type': type},\r\n      data: doc\r\n    }, callback);\r\n  };\r\n\r\n  // Add the document given by doc (in JSON string format) to the database\r\n  // given by host. This fails if the doc has no _id field.\r\n  api.put = function(doc, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    if (!doc || !('_id' in doc)) {\r\n      return call(callback, Pouch.Errors.MISSING_ID);\r\n    }\r\n\r\n    // List of parameter to add to the PUT request\r\n    var params = [];\r\n\r\n    // If it exists, add the opts.new_edits value to the list of parameters.\r\n    // If new_edits = false then the database will NOT assign this document a\r\n    // new revision number\r\n    if (opts && typeof opts.new_edits !== 'undefined') {\r\n      params.push('new_edits=' + opts.new_edits);\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    if (params !== '') {\r\n      params = '?' + params;\r\n    }\r\n\r\n    // Add the document\r\n    ajax({\r\n      auth: host.auth,\r\n      type: 'PUT',\r\n      url: genDBUrl(host, doc._id) + params,\r\n      data: doc\r\n    }, callback);\r\n  };\r\n\r\n  // Add the document given by doc (in JSON string format) to the database\r\n  // given by host. This does not assume that doc is a new document (i.e. does not\r\n  // have a _id or a _rev field.\r\n  api.post = function(doc, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (! (\"_id\" in doc)) {\r\n      if (uuids.list.length > 0) {\r\n        doc._id = uuids.list.pop();\r\n        api.put(doc, opts, callback);\r\n      }else {\r\n        uuids.get(function(err, resp) {\r\n          if (err) {\r\n            return call(callback, Pouch.Errors.UNKNOWN_ERROR);\r\n          }\r\n          doc._id = uuids.list.pop();\r\n          api.put(doc, opts, callback);\r\n        });\r\n      }\r\n    } else {\r\n      api.put(doc, opts, callback);\r\n    }\r\n  };\r\n\r\n  // Update/create multiple documents given by req in the database\r\n  // given by host.\r\n  api.bulkDocs = function(req, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (!opts) {\r\n      opts = {}\r\n    }\r\n\r\n    // If opts.new_edits exists add it to the document data to be\r\n    // send to the database.\r\n    // If new_edits=false then it prevents the database from creating\r\n    // new revision numbers for the documents. Instead it just uses\r\n    // the old ones. This is used in database replication.\r\n    if (typeof opts.new_edits !== 'undefined') {\r\n      req.new_edits = opts.new_edits;\r\n    }\r\n\r\n    // Update/create the documents\r\n    ajax({\r\n      auth: host.auth,\r\n      type:'POST',\r\n      url: genDBUrl(host, '_bulk_docs'),\r\n      data: req\r\n    }, callback);\r\n  };\r\n\r\n  // Get a listing of the documents in the database given\r\n  // by host and ordered by increasing id.\r\n  api.allDocs = function(opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // List of parameters to add to the GET request\r\n    var params = [];\r\n\r\n    // TODO I don't see conflicts as a valid parameter for a\r\n    // _all_docs request (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)\r\n    if (opts.conflicts) {\r\n      params.push('conflicts=true');\r\n    }\r\n\r\n    // If opts.include_docs exists, add the include_docs value to the\r\n    // list of parameters.\r\n    // If include_docs=true then include the associated document with each\r\n    // result.\r\n    if (opts.include_docs) {\r\n      params.push('include_docs=true');\r\n    }\r\n\r\n    // If opts.startkey exists, add the startkey value to the list of\r\n    // parameters.\r\n    // If startkey is given then the returned list of documents will\r\n    // start with the document whose id is startkey.\r\n    if (opts.startkey) {\r\n      params.push('startkey=' +\r\n                  encodeURIComponent(JSON.stringify(opts.startkey)));\r\n    }\r\n\r\n    // If opts.endkey exists, add the endkey value to the list of parameters.\r\n    // If endkey is given then the returned list of docuemnts will\r\n    // end with the document whose id is endkey.\r\n    if (opts.endkey) {\r\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    if (params !== '') {\r\n      params = '?' + params;\r\n    }\r\n\r\n    // Get the document listing\r\n    ajax({\r\n      auth: host.auth,\r\n      type:'GET',\r\n      url: genDBUrl(host, '_all_docs' + params)\r\n    }, callback);\r\n  };\r\n  // Get a list of changes made to documents in the database given by host.\r\n  // TODO According to the README, there should be two other methods here,\r\n  // api.changes.addListener and api.changes.removeListener.\r\n  api.changes = function(opts, callback) {\r\n    // If no options were given, set the callback to the first parameter\r\n    if (typeof opts === 'function') {\r\n      opts = {complete: opts};\r\n    }\r\n\r\n    // If a callback was provided outside of opts, then it is the one that\r\n    // will be called upon completion\r\n    if (callback) {\r\n      opts.complete = callback;\r\n    }\r\n\r\n    if (Pouch.DEBUG)\r\n      console.log(db_url + ': Start Changes Feed: continuous=' + opts.continuous);\r\n\r\n    // Query string of all the parameters to add to the GET request\r\n    var params = '?style=all_docs';\r\n\r\n    // If opts.include_docs exists, opts.filter exists, and opts.filter is a\r\n    // function, add the include_docs value to the query string.\r\n    // If include_docs=true then include the associated document with each\r\n    // result.\r\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\r\n      params += '&include_docs=true';\r\n    }\r\n\r\n    // If opts.continuous exists, add the feed value to the query string.\r\n    // If feed=longpoll then it waits for either a timeout or a change to\r\n    // occur before returning.\r\n    if (opts.continuous) {\r\n      params += '&feed=longpoll';\r\n    }\r\n\r\n    // If opts.conflicts exists, add the conflicts value to the query string.\r\n    // TODO I can't find documentation of what conflicts=true does. See\r\n    // http://wiki.apache.org/couchdb/HTTP_database_API#Changes\r\n    if (opts.conflicts) {\r\n      params += '&conflicts=true';\r\n    }\r\n\r\n    // If opts.descending exists, add the descending value to the query string.\r\n    // if descending=true then the change results are returned in\r\n    // descending order (most recent change first).\r\n    if (opts.descending) {\r\n      params += '&descending=true';\r\n    }\r\n\r\n    // If opts.filter exists and is a string then add the filter value\r\n    // to the query string.\r\n    // If filter is given a string containing the name of a filter in\r\n    // the design, then only documents passing through the filter will\r\n    // be returned.\r\n    if (opts.filter && typeof opts.filter === 'string') {\r\n      params += '&filter=' + opts.filter;\r\n    }\r\n\r\n    // If opts.query_params exists, pass it through to the changes request.\r\n    // These parameters may be used by the filter on the source database.\r\n    if (opts.query_params && typeof opts.query_params === 'object') {\r\n      for (var param_name in opts.query_params) {\r\n        if (opts.query_params.hasOwnProperty(param_name)) {\r\n          params += '&'+param_name+'='+opts.query_params[param_name];\r\n        }\r\n      }\r\n    }\r\n\r\n    var xhr;\r\n    var last_seq;\r\n\r\n    // Get all the changes starting wtih the one immediately after the\r\n    // sequence number given by since.\r\n    var fetch = function(since, callback) {\r\n      // Set the options for the ajax call\r\n      var xhrOpts = {\r\n        auth: host.auth, type:'GET',\r\n        url: genDBUrl(host, '_changes' + params + '&since=' + since),\r\n        timeout: null          // _changes can take a long time to generate, especially when filtered\r\n      };\r\n      last_seq = since;\r\n\r\n      if (opts.aborted) {\r\n        return;\r\n      }\r\n\r\n      // Get the changes\r\n      xhr = ajax(xhrOpts, callback);\r\n    };\r\n\r\n    // If opts.since exists, get all the changes from the sequence\r\n    // number given by opts.since. Otherwise, get all the changes\r\n    // from the sequence number 0.\r\n    var fetchTimeout = 10;\r\n    var fetchRetryCount = 0;\r\n    var fetched = function(err, res) {\r\n      // If the result of the ajax call (res) contains changes (res.results)\r\n      if (res && res.results) {\r\n        // For each change\r\n        res.results.forEach(function(c) {\r\n          var hasFilter = opts.filter && typeof opts.filter === 'function';\r\n          if (opts.aborted || hasFilter && !opts.filter.apply(this, [c.doc])) {\r\n            return;\r\n          }\r\n\r\n          // Process the change\r\n          call(opts.onChange, c);\r\n        });\r\n      }\r\n      // The changes feed may have timed out with no results\r\n      // if so reuse last update sequence\r\n      if (res && res.last_seq) {\r\n        last_seq = res.last_seq;\r\n      }\r\n\r\n      if (opts.continuous) {\r\n        // Increase retry delay exponentially as long as errors persist\r\n        if (err) fetchRetryCount += 1;\r\n        else fetchRetryCount = 0;\r\n        var timeoutMultiplier = 1 << fetchRetryCount;       // i.e. Math.pow(2, fetchRetryCount)\r\n        \r\n        var retryWait = fetchTimeout * timeoutMultiplier;\r\n        var maximumWait = opts.maximumWait || 30000;\r\n        if (retryWait > maximumWait) {\r\n          call(opts.complete, err || Pouch.Errors.UNKNOWN_ERROR, null);\r\n        }\r\n        \r\n        // Queue a call to fetch again with the newest sequence number\r\n        setTimeout(function () {\r\n          fetch(last_seq, fetched);\r\n        }, retryWait);\r\n      } else {\r\n        // We're done, call the callback\r\n        call(opts.complete, null, res);\r\n      }\r\n    };\r\n\r\n    fetch(opts.since || 0, fetched);\r\n\r\n    // Return a method to cancel this method from processing any more\r\n    return {\r\n      cancel: function() {\r\n        if (Pouch.DEBUG)\r\n          console.log(db_url + ': Cancel Changes Feed');\r\n        opts.aborted = true;\r\n        xhr.abort();\r\n      }\r\n    };\r\n  };\r\n\r\n  // Given a set of document/revision IDs (given by req), tets the subset of\r\n  // those that do NOT correspond to revisions stored in the database.\r\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\r\n  api.revsDiff = function(req, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // Get the missing document/revision IDs\r\n    ajax({\r\n      auth: host.auth,\r\n      type:'POST',\r\n      url: genDBUrl(host, '_revs_diff'),\r\n      data: req\r\n    }, function(err, res) {\r\n      call(callback, null, res);\r\n    });\r\n  };\r\n\r\n  api.replicate = {};\r\n\r\n  // Replicate from the database given by url to this HttpPouch\r\n  api.replicate.from = function(url, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return Pouch.replicate(url, api, opts, callback);\r\n  };\r\n\r\n  // Replicate to the database given by dbName from this HttpPouch\r\n  api.replicate.to = function(dbName, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return Pouch.replicate(api, dbName, opts, callback);\r\n  };\r\n\r\n  api.close = function(callback) {\r\n    call(callback, null);\r\n  };\r\n\r\n  return api;\r\n};\r\n\r\n// Delete the HttpPouch specified by the given name.\r\nHttpPouch.destroy = function(name, callback) {\r\n  var host = getHost(name);\r\n  ajax({auth: host.auth, type: 'DELETE', url: genDBUrl(host, '')}, callback);\r\n};\r\n\r\n// HttpPouch is a valid adapter.\r\nHttpPouch.valid = function() {\r\n  return true;\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  // running in node\r\n  var pouchdir = '../';\r\n  this.Pouch = require(pouchdir + 'pouch.js')\r\n  this.ajax = Pouch.utils.ajax;\r\n}\r\n\r\n// Set HttpPouch to be the adapter used with the http scheme.\r\nPouch.adapter('http', HttpPouch);\r\nPouch.adapter('https', HttpPouch);\r\n\r\n// While most of the IDB behaviors match between implementations a\r\n// lot of the names still differ. This section tries to normalize the\r\n// different objects & methods.\r\nwindow.indexedDB = window.indexedDB ||\r\n  window.mozIndexedDB ||\r\n  window.webkitIndexedDB;\r\n\r\n// still needed for R/W transactions in Android Chrome. follow MDN example:\r\n// https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#transaction\r\nwindow.IDBTransaction = window.IDBTransaction ||\r\n  window.webkitIDBTransaction ||\r\n  { READ_WRITE: 'readwrite' };\r\n\r\nwindow.IDBKeyRange = window.IDBKeyRange ||\r\n  window.webkitIDBKeyRange;\r\n\r\nwindow.storageInfo = window.storageInfo ||\r\n  window.webkitStorageInfo;\r\n\r\nwindow.requestFileSystem = window.requestFileSystem ||\r\n    window.webkitRequestFileSystem;\r\n\r\nvar idbError = function(callback) {\r\n  return function(event) {\r\n    call(callback, {\r\n      status: 500,\r\n      error: event.type,\r\n      reason: event.target\r\n    });\r\n  };\r\n};\r\n\r\nvar IdbPouch = function(opts, callback) {\r\n\r\n  // IndexedDB requires a versioned database structure, this is going to make\r\n  // it hard to dynamically create object stores if we needed to for things\r\n  // like views\r\n  var POUCH_VERSION = 1;\r\n\r\n  // The object stores created for each database\r\n  // DOC_STORE stores the document meta data, its revision history and state\r\n  var DOC_STORE = 'document-store';\r\n  // BY_SEQ_STORE stores a particular version of a document, keyed by its\r\n  // sequence id\r\n  var BY_SEQ_STORE = 'by-sequence';\r\n  // Where we store attachments\r\n  var ATTACH_STORE = 'attach-store';\r\n\r\n  var name = opts.name;\r\n  var req = indexedDB.open(name, POUCH_VERSION);\r\n  var update_seq = 0;\r\n\r\n\r\n  // var storeAttachmentsInIDB = !(window.storageInfo && window.requestFileSystem);\r\n  // We cant store attachments on the filesystem due to a limitation in the\r\n  // indexeddb api, it will close a transaction when we yield to the event loop\r\n  var storeAttachmentsInIDB = true;\r\n\r\n  var api = {};\r\n  var idb = null;\r\n\r\n  if (Pouch.DEBUG)\r\n    console.log(name + ': Open Database');\r\n\r\n  // TODO: before we release, make sure we write upgrade needed\r\n  // in a way that supports a future upgrade path\r\n  req.onupgradeneeded = function(e) {\r\n    var db = e.target.result;\r\n    db.createObjectStore(DOC_STORE, {keyPath : 'id'})\r\n      .createIndex('seq', 'seq', {unique: true});\r\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement : true})\r\n      .createIndex('_rev', '_rev', {unique: true});\r\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\r\n  };\r\n\r\n  req.onsuccess = function(e) {\r\n\r\n    idb = e.target.result;\r\n\r\n    idb.onversionchange = function() {\r\n      idb.close();\r\n    };\r\n\r\n    // polyfill the new onupgradeneeded api for chrome. can get rid of when\r\n    // saucelabs moves to chrome 23\r\n    if (idb.setVersion && Number(idb.version) !== POUCH_VERSION) {\r\n      var versionReq = idb.setVersion(POUCH_VERSION);\r\n      versionReq.onsuccess = function(evt) {\r\n        function setVersionComplete() {\r\n          req.onsuccess(e);\r\n        }\r\n        evt.target.result.oncomplete = setVersionComplete;\r\n        req.onupgradeneeded(e);\r\n      };\r\n      return;\r\n    }\r\n\r\n    // TODO: This is a really inneficient way of finding the last\r\n    // update sequence, cant think of an alterative right now\r\n    api.changes(function(err, changes) {\r\n      if (changes.results.length) {\r\n        update_seq = changes.results[changes.results.length - 1].seq;\r\n      }\r\n      call(callback, null, api);\r\n    });\r\n\r\n  };\r\n\r\n  req.onerror = idbError(callback);\r\n\r\n  api.type = function() {\r\n    return 'idb';\r\n  };\r\n\r\n  // Each database needs a unique id so that we can store the sequence\r\n  // checkpoint without having other databases confuse itself, since\r\n  // localstorage is per host this shouldnt conflict, if localstorage\r\n  // gets wiped it isnt fatal, replications will just start from scratch\r\n  api.id = function idb_id() {\r\n    var id = localJSON.get(name + '_id', null);\r\n    if (id === null) {\r\n      id = Math.uuid();\r\n      localJSON.set(name + '_id', id);\r\n    }\r\n    return id;\r\n  };\r\n\r\n  api.bulkDocs = function idb_bulkDocs(req, opts, callback) {\r\n\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (!opts) {\r\n      opts = {};\r\n    }\r\n\r\n    if (!req.docs) {\r\n      return call(callback, Pouch.Errors.MISSING_BULK_DOCS);\r\n    }\r\n\r\n    var newEdits = 'new_edits' in opts ? opts.new_edits : true;\r\n    var userDocs = JSON.parse(JSON.stringify(req.docs));\r\n\r\n    // Parse the docs, give them a sequence number for the result\r\n    var docInfos = userDocs.map(function(doc, i) {\r\n      var newDoc = parseDoc(doc, newEdits);\r\n      newDoc._bulk_seq = i;\r\n      if (doc._deleted) {\r\n        if (!newDoc.metadata.deletions) {\r\n          newDoc.metadata.deletions = {};\r\n        }\r\n        newDoc.metadata.deletions[doc._rev.split('-')[1]] = true;\r\n      }\r\n      return newDoc;\r\n    });\r\n\r\n    var results = [];\r\n    var docs = [];\r\n\r\n    // Group multiple edits to the same document\r\n    docInfos.forEach(function(docInfo) {\r\n      if (docInfo.error) {\r\n        return results.push(docInfo);\r\n      }\r\n      if (!docs.length || docInfo.metadata.id !== docs[0].metadata.id) {\r\n        return docs.unshift(docInfo);\r\n      }\r\n      // We mark subsequent bulk docs with a duplicate id as conflicts\r\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\r\n    });\r\n\r\n    function processDocs() {\r\n      if (!docs.length) {\r\n        return;\r\n      }\r\n      var currentDoc = docs.shift();\r\n      var req = txn.objectStore(DOC_STORE).get(currentDoc.metadata.id);\r\n      req.onsuccess = function process_docRead(event) {\r\n        var oldDoc = event.target.result;\r\n        if (!oldDoc) {\r\n          insertDoc(currentDoc);\r\n        } else {\r\n          updateDoc(oldDoc, currentDoc);\r\n        }\r\n      };\r\n    }\r\n\r\n    function complete(event) {\r\n      var aresults = [];\r\n      results.sort(sortByBulkSeq);\r\n      results.forEach(function(result) {\r\n        delete result._bulk_seq;\r\n        if (result.error) {\r\n          aresults.push(result);\r\n          return;\r\n        }\r\n        var metadata = result.metadata;\r\n        var rev = winningRev(metadata);\r\n\r\n        aresults.push({\r\n          ok: true,\r\n          id: metadata.id,\r\n          rev: rev\r\n        });\r\n\r\n        if (/_local/.test(metadata.id)) {\r\n          return;\r\n        }\r\n\r\n        var change = {\r\n          id: metadata.id,\r\n          seq: metadata.seq,\r\n          changes: collectLeaves(metadata.rev_tree),\r\n          doc: result.data\r\n        };\r\n        change.doc._rev = rev;\r\n        update_seq++;\r\n        IdbPouch.Changes.emitChange(name, change);\r\n      });\r\n      call(callback, null, aresults);\r\n    }\r\n\r\n    function writeDoc(docInfo, callback) {\r\n      var err = null;\r\n      var recv = 0;\r\n\r\n      docInfo.data._id = docInfo.metadata.id;\r\n      docInfo.data._rev = docInfo.metadata.rev;\r\n\r\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\r\n        docInfo.data._deleted = true;\r\n      }\r\n\r\n      var attachments = docInfo.data._attachments ?\r\n        Object.keys(docInfo.data._attachments) : [];\r\n\r\n      for (var key in docInfo.data._attachments) {\r\n        if (!docInfo.data._attachments[key].stub) {\r\n          var data = docInfo.data._attachments[key].data;\r\n          var digest = 'md5-' + Crypto.MD5(data);\r\n          delete docInfo.data._attachments[key].data;\r\n          docInfo.data._attachments[key].digest = digest;\r\n          saveAttachment(docInfo, digest, data, function(err) {\r\n            recv++;\r\n            collectResults(err);\r\n          });\r\n        } else {\r\n          recv++;\r\n          collectResults();\r\n        }\r\n      }\r\n\r\n      if (!attachments.length) {\r\n        finish();\r\n      }\r\n\r\n      function collectResults(attachmentErr) {\r\n        if (!err) {\r\n          if (attachmentErr) {\r\n            err = attachmentErr;\r\n            call(callback, err);\r\n          } else if (recv == attachments.length) {\r\n            finish();\r\n          }\r\n        }\r\n      }\r\n\r\n      function finish() {\r\n        var dataReq = txn.objectStore(BY_SEQ_STORE).put(docInfo.data);\r\n        dataReq.onsuccess = function(e) {\r\n          if (Pouch.DEBUG)\r\n            console.log(name + ': Wrote Document ', docInfo.metadata.id);\r\n          docInfo.metadata.seq = e.target.result;\r\n          // Current _rev is calculated from _rev_tree on read\r\n          delete docInfo.metadata.rev;\r\n          var metaDataReq = txn.objectStore(DOC_STORE).put(docInfo.metadata);\r\n          metaDataReq.onsuccess = function() {\r\n            results.push(docInfo);\r\n            call(callback);\r\n          };\r\n        };\r\n      }\r\n    }\r\n\r\n    function updateDoc(oldDoc, docInfo) {\r\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\r\n\r\n      var inConflict = (isDeleted(oldDoc) && isDeleted(docInfo.metadata)) ||\r\n        (!isDeleted(oldDoc) && newEdits && merged.conflicts !== 'new_leaf');\r\n\r\n      if (inConflict) {\r\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\r\n        return processDocs();\r\n      }\r\n\r\n      docInfo.metadata.rev_tree = merged.tree;\r\n      writeDoc(docInfo, processDocs);\r\n    }\r\n\r\n    function insertDoc(docInfo) {\r\n      // Cant insert new deleted documents\r\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\r\n        results.push(Pouch.Errors.MISSING_DOC);\r\n        return processDocs();\r\n      }\r\n      writeDoc(docInfo, processDocs);\r\n    }\r\n\r\n    // Insert sequence number into the error so we can sort later\r\n    function makeErr(err, seq) {\r\n      err._bulk_seq = seq;\r\n      return err;\r\n    }\r\n\r\n    function saveAttachment(docInfo, digest, data, callback) {\r\n      if (storeAttachmentsInIDB) {\r\n        var objectStore = txn.objectStore(ATTACH_STORE);\r\n        var getReq = objectStore.get(digest).onsuccess = function(e) {\r\n          var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\r\n          var newAtt = {digest: digest, body: data};\r\n\r\n          if (e.target.result) {\r\n            if (e.target.result.refs) {\r\n              // only update references if this attachment already has them\r\n              // since we cannot migrate old style attachments here without\r\n              // doing a full db scan for references\r\n              newAtt.refs = e.target.result.refs;\r\n              newAtt.refs[ref] = true;\r\n            }\r\n          } else {\r\n            newAtt.refs = {};\r\n            newAtt.refs[ref] = true;\r\n          }\r\n\r\n          var putReq = objectStore.put(newAtt).onsuccess = function(e) {\r\n            call(callback);\r\n          };\r\n          putReq.onerror = putReq.ontimeout = idbError(callback);\r\n        };\r\n        getReq.onerror = getReq.ontimeout = idbError(callback);\r\n      } else {\r\n        // right now fire and forget, needs cleaned\r\n        writeAttachmentToFile(digest,data);\r\n        call(callback);\r\n      }\r\n    }\r\n\r\n    var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], IDBTransaction.READ_WRITE);\r\n    txn.onerror = idbError(callback);\r\n    txn.ontimeout = idbError(callback);\r\n    txn.oncomplete = complete;\r\n\r\n    processDocs();\r\n\r\n  };\r\n\r\n  function sortByBulkSeq(a, b) {\r\n    return a._bulk_seq - b._bulk_seq;\r\n  }\r\n\r\n  // First we look up the metadata in the ids database, then we fetch the\r\n  // current revision(s) from the by sequence store\r\n  api.get = function idb_get(id, opts, callback) {\r\n\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    id = parseDocId(id);\r\n    if (id.attachmentId !== '') {\r\n      return api.getAttachment(id, {decode: true}, callback);\r\n    }\r\n\r\n    var result;\r\n    var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\r\n    txn.oncomplete = function() {\r\n      if ('error' in result) {\r\n        call(callback, result);\r\n      } else {\r\n        call(callback, null, result);\r\n      }\r\n    };\r\n\r\n    txn.objectStore(DOC_STORE).get(id.docId).onsuccess = function(e) {\r\n      var metadata = e.target.result;\r\n      if (!e.target.result || (isDeleted(metadata, opts.rev) && !opts.rev)) {\r\n        result = Pouch.Errors.MISSING_DOC;\r\n        return;\r\n      }\r\n\r\n      var rev = winningRev(metadata);\r\n      var key = opts.rev ? opts.rev : rev;\r\n      var index = txn.objectStore(BY_SEQ_STORE).index('_rev');\r\n\r\n      index.get(key).onsuccess = function(e) {\r\n        var doc = e.target.result;\r\n        if (opts.revs) {\r\n          var path = arrayFirst(rootToLeaf(metadata.rev_tree), function(arr) {\r\n            return arr.ids.indexOf(doc._rev.split('-')[1]) !== -1;\r\n          });\r\n          path.ids.reverse();\r\n          doc._revisions = {\r\n            start: (path.pos + path.ids.length) - 1,\r\n            ids: path.ids\r\n          };\r\n        }\r\n        if (opts.revs_info) {\r\n          doc._revs_info = metadata.rev_tree.reduce(function(prev, current) {\r\n            return prev.concat(collectRevs(current));\r\n          }, []);\r\n        }\r\n        if (opts.conflicts) {\r\n          var conflicts = collectConflicts(metadata.rev_tree);\r\n          if (conflicts.length) {\r\n            doc._conflicts = conflicts;\r\n          }\r\n        }\r\n\r\n        if (opts.attachments && doc._attachments) {\r\n          var attachments = Object.keys(doc._attachments);\r\n          var recv = 0;\r\n\r\n          attachments.forEach(function(key) {\r\n            api.getAttachment(doc._id + '/' + key, {txn: txn}, function(err, data) {\r\n              doc._attachments[key].data = data;\r\n\r\n              if (++recv === attachments.length) {\r\n                result = doc;\r\n              }\r\n            });\r\n          });\r\n        } else {\r\n          if (doc._attachments){\r\n            for (var key in doc._attachments) {\r\n              doc._attachments[key].stub = true;\r\n            }\r\n          }\r\n          result = doc;\r\n        }\r\n      };\r\n    };\r\n  };\r\n\r\n  api.getAttachment = function(id, opts, callback) {\r\n    if (opts instanceof Function) {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (typeof id === 'string') {\r\n      id = parseDocId(id);\r\n    }\r\n\r\n    var result;\r\n    var txn;\r\n\r\n    // This can be called while we are in a current transaction, pass the context\r\n    // along and dont wait for the transaction to complete here.\r\n    if ('txn' in opts) {\r\n      txn = opts.txn;\r\n    } else {\r\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\r\n      txn.oncomplete = function() { call(callback, null, result); }\r\n    }\r\n\r\n    txn.objectStore(DOC_STORE).get(id.docId).onsuccess = function(e) {\r\n      var metadata = e.target.result;\r\n      var bySeq = txn.objectStore(BY_SEQ_STORE);\r\n      bySeq.get(metadata.seq).onsuccess = function(e) {\r\n        var attachment = e.target.result._attachments[id.attachmentId];\r\n        var digest = attachment.digest;\r\n        var type = attachment.content_type\r\n\r\n        function postProcessDoc(data) {\r\n          if (opts.decode) {\r\n            data = atob(data);\r\n          }\r\n          return data;\r\n        }\r\n\r\n        if (storeAttachmentsInIDB) {\r\n          txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function(e) {\r\n            var data = e.target.result.body;\r\n            result = postProcessDoc(data);\r\n            if ('txn' in opts) {\r\n              call(callback, null, result);\r\n            }\r\n          }\r\n        } else {\r\n          // This will be buggy, it will cause the transaction to be closed\r\n          // as we will be returning to the event loop waiting on the file to\r\n          // read, switch back to idb asap\r\n          readAttachmentFromFile(digest, function(data) {\r\n            result = postProcessDoc(data);\r\n            if ('txn' in opts) {\r\n              call(callback, null, result);\r\n            }\r\n          });\r\n        }\r\n      };\r\n    }\r\n    return;\r\n  }\r\n\r\n  api.put = function(doc, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    if (!doc || !('_id' in doc)) {\r\n      return call(callback, Pouch.Errors.MISSING_ID);\r\n    }\r\n    return api.bulkDocs({docs: [doc]}, opts, yankError(callback));\r\n  }\r\n\r\n  api.post = function idb_put(doc, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return api.bulkDocs({docs: [doc]}, opts, yankError(callback));\r\n  };\r\n\r\n  api.putAttachment = function idb_putAttachment(id, rev, doc, type, callback) {\r\n    id = parseDocId(id);\r\n    api.get(id.docId, {attachments: true}, function(err, obj) {\r\n      obj._attachments || (obj._attachments = {});\r\n      obj._attachments[id.attachmentId] = {\r\n        content_type: type,\r\n        data: btoa(doc)\r\n      }\r\n      api.put(obj, callback);\r\n    });\r\n  };\r\n\r\n  api.remove = function idb_remove(doc, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    opts.was_delete = true;\r\n    var newDoc = JSON.parse(JSON.stringify(doc));\r\n    newDoc._deleted = true;\r\n    return api.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\r\n  };\r\n\r\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\r\n    id = parseDocId(id);\r\n    api.get(id.docId, function(err, obj) {\r\n      if (err) {\r\n        call(callback, err);\r\n        return;\r\n      }\r\n\r\n      if (obj._rev != rev) {\r\n        call(callback, Pouch.Errors.REV_CONFLICT);\r\n        return;\r\n      }\r\n\r\n      obj._attachments || (obj._attachments = {});\r\n      delete obj._attachments[id.attachmentId];\r\n      api.put(obj, callback);\r\n    });\r\n  };\r\n\r\n  api.allDocs = function idb_allDocs(opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    var start = 'startkey' in opts ? opts.startkey : false;\r\n    var end = 'endkey' in opts ? opts.endkey : false;\r\n\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n    descending = descending ? 'prev' : null;\r\n\r\n    var keyRange = start && end ? IDBKeyRange.bound(start, end, false, false)\r\n      : start ? IDBKeyRange.lowerBound(start, true)\r\n      : end ? IDBKeyRange.upperBound(end) : null;\r\n\r\n    var result;\r\n    var transaction = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');\r\n    transaction.oncomplete = function() { callback(null, result); };\r\n\r\n    var oStore = transaction.objectStore(DOC_STORE);\r\n    var oCursor = descending ? oStore.openCursor(keyRange, descending)\r\n      : oStore.openCursor(keyRange);\r\n    var results = [];\r\n    oCursor.onsuccess = function(e) {\r\n      if (!e.target.result) {\r\n        result = {\r\n          total_rows: results.length,\r\n          rows: results\r\n        };\r\n        return;\r\n      }\r\n      var cursor = e.target.result;\r\n      function allDocsInner(metadata, data) {\r\n        if (/_local/.test(metadata.id)) {\r\n          return cursor['continue']();\r\n        }\r\n        if (!isDeleted(metadata)) {\r\n          var doc = {\r\n            id: metadata.id,\r\n            key: metadata.id,\r\n            value: {\r\n              rev: winningRev(metadata)\r\n            }\r\n          };\r\n          if (opts.include_docs) {\r\n            doc.doc = data;\r\n            doc.doc._rev = winningRev(metadata);\r\n            if (opts.conflicts) {\r\n              doc.doc._conflicts = collectConflicts(metadata.rev_tree);\r\n            }\r\n          }\r\n          results.push(doc);\r\n        }\r\n        cursor['continue']();\r\n      }\r\n\r\n      if (!opts.include_docs) {\r\n        allDocsInner(cursor.value);\r\n      } else {\r\n        var index = transaction.objectStore(BY_SEQ_STORE);\r\n        index.get(cursor.value.seq).onsuccess = function(event) {\r\n          allDocsInner(cursor.value, event.target.result);\r\n        };\r\n      }\r\n    }\r\n  };\r\n\r\n  // Looping through all the documents in the database is a terrible idea\r\n  // easiest to implement though, should probably keep a counter\r\n  api.info = function idb_info(callback) {\r\n    var count = 0;\r\n    var result;\r\n    var txn = idb.transaction([DOC_STORE], 'readonly');\r\n\r\n    txn.oncomplete = function() {\r\n      callback(null, result);\r\n    };\r\n\r\n    txn.objectStore(DOC_STORE).openCursor().onsuccess = function(e) {\r\n        var cursor = e.target.result;\r\n        if (!cursor) {\r\n          result = {\r\n            db_name: name,\r\n            doc_count: count,\r\n            update_seq: update_seq\r\n          };\r\n          return;\r\n        }\r\n        if (cursor.value.deleted !== true) {\r\n          count++;\r\n        }\r\n        cursor['continue']();\r\n      };\r\n  };\r\n\r\n  api.revsDiff = function idb_revsDiff(req, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    var ids = Object.keys(req);\r\n    var count = 0;\r\n    var missing = {};\r\n\r\n    function readDoc(err, doc, id) {\r\n      req[id].map(function(revId) {\r\n        var matches = function(x) { return x.rev !== revId; };\r\n        if (!doc || doc._revs_info.every(matches)) {\r\n          if (!missing[id]) {\r\n            missing[id] = {missing: []};\r\n          }\r\n          missing[id].missing.push(revId);\r\n        }\r\n      });\r\n\r\n      if (++count === ids.length) {\r\n        return call(callback, null, missing);\r\n      }\r\n    }\r\n\r\n    ids.map(function(id) {\r\n      api.get(id, {revs_info: true}, function(err, doc) {\r\n        readDoc(err, doc, id);\r\n      });\r\n    });\r\n  };\r\n\r\n  api.changes = function idb_changes(opts, callback) {\r\n\r\n    if (typeof opts === 'function') {\r\n      opts = {complete: opts};\r\n    }\r\n    if (callback) {\r\n      opts.complete = callback;\r\n    }\r\n    if (!opts.seq) {\r\n      opts.seq = 0;\r\n    }\r\n    if (opts.since) {\r\n      opts.seq = opts.since;\r\n    }\r\n\r\n    if (Pouch.DEBUG)\r\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\r\n\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n    descending = descending ? 'prev' : null;\r\n\r\n    var results = [], resultIndices = {}, dedupResults = [];\r\n    var id = name + ':' + Math.uuid();\r\n    var txn;\r\n\r\n    if (opts.filter && typeof opts.filter === 'string') {\r\n      var filterName = opts.filter.split('/');\r\n      api.get('_design/' + filterName[0], function(err, ddoc) {\r\n        var filter = eval('(function() { return ' +\r\n                          ddoc.filters[filterName[1]] + ' })()');\r\n        opts.filter = filter;\r\n        fetchChanges();\r\n      });\r\n    } else {\r\n      fetchChanges();\r\n    }\r\n\r\n    function fetchChanges() {\r\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE]);\r\n      txn.oncomplete = onTxnComplete;\r\n      var req = descending\r\n        ? txn.objectStore(BY_SEQ_STORE)\r\n          .openCursor(IDBKeyRange.lowerBound(opts.seq, true), descending)\r\n        : txn.objectStore(BY_SEQ_STORE)\r\n          .openCursor(IDBKeyRange.lowerBound(opts.seq, true));\r\n      req.onsuccess = onsuccess;\r\n      req.onerror = onerror;\r\n    }\r\n\r\n    function onsuccess(event) {\r\n      if (!event.target.result) {\r\n        if (opts.continuous && !opts.cancelled) {\r\n          IdbPouch.Changes.addListener(name, id, opts);\r\n        }\r\n\r\n        // Filter out null results casued by deduping\r\n        for (var i = 0, l = results.length; i < l; i++ ) {\r\n          var result = results[i];\r\n          if (result) dedupResults.push(result);\r\n        }\r\n        return false;\r\n      }\r\n      var cursor = event.target.result;\r\n      var index = txn.objectStore(DOC_STORE);\r\n      index.get(cursor.value._id).onsuccess = function(event) {\r\n        var metadata = event.target.result;\r\n        if (/_local/.test(metadata.id)) {\r\n          return cursor['continue']();\r\n        }\r\n\r\n        var change = {\r\n          id: metadata.id,\r\n          seq: cursor.key,\r\n          changes: collectLeaves(metadata.rev_tree),\r\n          doc: cursor.value,\r\n        };\r\n\r\n        change.doc._rev = winningRev(metadata);\r\n\r\n        if (isDeleted(metadata, change.doc._rev)) {\r\n          change.deleted = true;\r\n        }\r\n        if (opts.conflicts) {\r\n          change.doc._conflicts = collectConflicts(metadata.rev_tree);\r\n        }\r\n\r\n        // Dedupe the changes feed\r\n        var changeId = change.id, changeIdIndex = resultIndices[changeId];\r\n        if (changeIdIndex !== undefined) {\r\n          results[changeIdIndex] = null;\r\n        }\r\n        results.push(change);\r\n        resultIndices[changeId] = results.length - 1;\r\n        cursor['continue']();\r\n      };\r\n    };\r\n\r\n    function onTxnComplete() {\r\n      dedupResults.map(function(c) {\r\n        if (opts.filter && !opts.filter.apply(this, [c.doc])) {\r\n          return;\r\n        }\r\n        if (!opts.include_docs) {\r\n          delete c.doc;\r\n        }\r\n        call(opts.onChange, c);\r\n      });\r\n      call(opts.complete, null, {results: dedupResults});\r\n    };\r\n\r\n    function onerror(error) {\r\n      if (opts.continuous) {\r\n        IdbPouch.Changes.addListener(name, id, opts);\r\n      }\r\n      call(opts.complete);\r\n    };\r\n\r\n    if (opts.continuous) {\r\n      return {\r\n        cancel: function() {\r\n          if (Pouch.DEBUG)\r\n            console.log(name + ': Cancel Changes Feed');\r\n          opts.cancelled = true;\r\n          IdbPouch.Changes.removeListener(name, id);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  api.replicate = {};\r\n\r\n  api.replicate.from = function idb_replicate_from(url, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return Pouch.replicate(url, api, opts, callback);\r\n  };\r\n\r\n  api.replicate.to = function idb_replicate_to(dbName, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return Pouch.replicate(api, dbName, opts, callback);\r\n  };\r\n\r\n  // Functions for reading and writing an attachment in the html5 file system\r\n  // instead of idb\r\n  function toArray(list) {\r\n    return Array.prototype.slice.call(list || [], 0);\r\n  }\r\n  function fileErrorHandler(e) {\r\n    console.error('File system error',e);\r\n  }\r\n\r\n  //Delete attachments that are no longer referenced by any existing documents\r\n  function deleteOrphanedFiles(currentQuota){\r\n    api.allDocs({include_docs:true},function(err, response) {\r\n      window.requestFileSystem(window.PERSISTENT, currentQuota, function(fs){\r\n      var dirReader = fs.root.createReader();\r\n      var entries = [];\r\n      var docRows = response.rows;\r\n\r\n      // Call the reader.readEntries() until no more results are returned.\r\n      var readEntries = function() {\r\n        dirReader.readEntries (function(results) {\r\n          if (!results.length) {\r\n            for (var i in entries){\r\n              var entryIsReferenced = false;\r\n              for (var k in docRows){\r\n                if (docRows[k].doc){\r\n                  var aDoc = docRows[k].doc;\r\n                  if (aDoc._attachments) {\r\n                    for (var j in aDoc._attachments) {\r\n                      if (aDoc._attachments[j].digest==entries[i].name) {\r\n                        entryIsReferenced = true;\r\n                      }\r\n                    };\r\n                  }\r\n                  if (entryIsReferenced) break;\r\n                }\r\n              };\r\n              if (!entryIsReferenced){\r\n                entries[i].remove(function() {\r\n                  if (Pouch.DEBUG)\r\n                    console.log(\"Removed orphaned attachment: \"+entries[i].name);\r\n                }, fileErrorHandler);\r\n              }\r\n            };\r\n          } else {\r\n            entries = entries.concat(toArray(results));\r\n            readEntries();\r\n          }\r\n        }, fileErrorHandler);\r\n      };\r\n\r\n      readEntries(); // Start reading dirs.\r\n\r\n      }, fileErrorHandler);\r\n    });\r\n  }\r\n\r\n  function writeAttachmentToFile(digest, data, type){\r\n    //Check the current file quota and increase it if necessary\r\n    window.storageInfo.queryUsageAndQuota(window.PERSISTENT, function(currentUsage, currentQuota) {\r\n      var newQuota = currentQuota;\r\n      if (currentQuota == 0){\r\n        newQuota = 1000*1024*1024; //start with 1GB\r\n      }else if ((currentUsage/currentQuota) > 0.8){\r\n        deleteOrphanedFiles(currentQuota); //delete old attachments when we hit 80% usage\r\n      }else if ((currentUsage/currentQuota) > 0.9){\r\n        newQuota=2*currentQuota; //double the quota when we hit 90% usage\r\n      }\r\n\r\n      if (Pouch.DEBUG)\r\n        console.log(\"Current file quota: \"+currentQuota+\", current usage:\"+currentUsage+\", new quota will be: \"+newQuota);\r\n\r\n      //Ask for file quota. This does nothing if the proper quota size has already been granted.\r\n      window.storageInfo.requestQuota(window.PERSISTENT, newQuota, function(grantedBytes) {\r\n        window.storageInfo.queryUsageAndQuota(window.PERSISTENT, function(currentUsage, currentQuota) {\r\n          window.requestFileSystem(window.PERSISTENT, currentQuota, function(fs){\r\n            fs.root.getFile(digest, {create: true}, function(fileEntry) {\r\n              fileEntry.createWriter(function(fileWriter) {\r\n                fileWriter.onwriteend = function(e) {\r\n                  if (Pouch.DEBUG)\r\n                    console.log('Wrote attachment');\r\n                };\r\n                fileWriter.onerror = function(e) {\r\n                  console.error('File write failed: ' + e.toString());\r\n                };\r\n                var blob = new Blob([data], {type: type});\r\n                fileWriter.write(blob);\r\n              }, fileErrorHandler);\r\n            }, fileErrorHandler);\r\n          }, fileErrorHandler);\r\n        }, fileErrorHandler);\r\n      }, fileErrorHandler);\r\n    },fileErrorHandler);\r\n  }\r\n\r\n  function readAttachmentFromFile(digest, callback){\r\n    window.storageInfo.queryUsageAndQuota(window.PERSISTENT, function(currentUsage, currentQuota) {\r\n      window.requestFileSystem(window.PERSISTENT, currentQuota, function(fs){\r\n        fs.root.getFile(digest, {}, function(fileEntry) {\r\n          fileEntry.file(function(file) {\r\n            var reader = new FileReader();\r\n            reader.onloadend = function(e) {\r\n              data = this.result;\r\n              if (Pouch.DEBUG)\r\n                console.log(\"Read attachment\");\r\n              callback(data);\r\n            };\r\n            reader.readAsBinaryString(file);\r\n          }, fileErrorHandler);\r\n        }, fileErrorHandler);\r\n      }, fileErrorHandler);\r\n    }, fileErrorHandler);\r\n  }\r\n\r\n  api.close = function(callback) {\r\n    if (idb === null) {\r\n      return call(callback, Pouch.Errors.NOT_OPEN);\r\n    }\r\n\r\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\r\n    // \"Returns immediately and closes the connection in a separate thread...\"\r\n    idb.close();\r\n    call(callback, null);\r\n  };\r\n\r\n  return api;\r\n};\r\n\r\nIdbPouch.valid = function idb_valid() {\r\n  if (!document.location.host) {\r\n    console.error('indexedDB cannot be used in pages served from the filesystem');\r\n  }\r\n  return !!window.indexedDB && !!document.location.host;\r\n};\r\n\r\nIdbPouch.destroy = function idb_destroy(name, callback) {\r\n  if (Pouch.DEBUG)\r\n    console.log(name + ': Delete Database');\r\n  //delete the db id from localStorage so it doesn't get reused.\r\n  delete localStorage[name+\"_id\"];\r\n  IdbPouch.Changes.clearListeners(name);\r\n  var req = indexedDB.deleteDatabase(name);\r\n\r\n  req.onsuccess = function() {\r\n    call(callback, null);\r\n  };\r\n\r\n  req.onerror = idbError(callback);\r\n};\r\n\r\nIdbPouch.Changes = (function() {\r\n\r\n  var api = {};\r\n  var listeners = {};\r\n\r\n  api.addListener = function(db, id, opts) {\r\n    if (!listeners[db]) {\r\n      listeners[db] = {};\r\n    }\r\n    listeners[db][id] = opts;\r\n  }\r\n\r\n  api.removeListener = function(db, id) {\r\n    delete listeners[db][id];\r\n  }\r\n\r\n  api.clearListeners = function(db) {\r\n    delete listeners[db];\r\n  }\r\n\r\n  api.emitChange = function(db, change) {\r\n    if (!listeners[db]) {\r\n      return;\r\n    }\r\n    for (var i in listeners[db]) {\r\n      var opts = listeners[db][i];\r\n      if (opts.filter && !opts.filter.apply(this, [change.doc])) {\r\n        return;\r\n      }\r\n      if (!opts.include_docs) {\r\n        delete change.doc;\r\n      }\r\n      opts.onChange.apply(opts.onChange, [change]);\r\n    }\r\n  }\r\n\r\n  return api;\r\n})();\r\n\r\nPouch.adapter('idb', IdbPouch);\r\n\r\n\"use strict\";\r\n\r\nfunction quote(str) {\r\n  return \"'\" + str + \"'\";\r\n}\r\n\r\nvar POUCH_VERSION = 1;\r\nvar POUCH_SIZE = 5 * 1024 * 1024;\r\n\r\n// The object stores created for each database\r\n// DOC_STORE stores the document meta data, its revision history and state\r\nvar DOC_STORE = quote('document-store');\r\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\r\n// sequence id\r\nvar BY_SEQ_STORE = quote('by-sequence');\r\n// Where we store attachments\r\nvar ATTACH_STORE = quote('attach-store');\r\nvar META_STORE = quote('metadata-store');\r\n\r\nvar unknownError = function(callback) {\r\n  return function(event) {\r\n    call(callback, {\r\n      status: 500,\r\n      error: event.type,\r\n      reason: event.target\r\n    });\r\n  };\r\n};\r\n\r\nvar webSqlPouch = function(opts, callback) {\r\n\r\n  var api = {};\r\n  var update_seq = 0;\r\n  var name = opts.name;\r\n\r\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\r\n  if (!db) {\r\n    return call(callback, Pouch.Errors.UNKNOWN_ERROR);\r\n  }\r\n\r\n  function dbCreated() {\r\n    callback(null, api);\r\n  }\r\n\r\n  db.transaction(function (tx) {\r\n    var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE +\r\n      ' (update_seq)';\r\n    var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE +\r\n      ' (digest, json)';\r\n    var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE +\r\n      ' (id unique, seq, json)';\r\n    var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE +\r\n      ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, rev UNIQUE, json)';\r\n\r\n    tx.executeSql(attach);\r\n    tx.executeSql(doc);\r\n    tx.executeSql(seq);\r\n    tx.executeSql(meta);\r\n\r\n    var sql = 'SELECT update_seq FROM ' + META_STORE;\r\n    tx.executeSql(sql, [], function(tx, result) {\r\n      if (!result.rows.length) {\r\n        var initSeq = 'INSERT INTO ' + META_STORE + ' (update_seq) VALUES (?)';\r\n        tx.executeSql(initSeq, [0]);\r\n        return;\r\n      }\r\n      update_seq = result.rows[0].update_seq;\r\n    });\r\n  }, unknownError(callback), dbCreated);\r\n\r\n  api.type = function() {\r\n    return 'websql';\r\n  };\r\n\r\n  api.id = function() {\r\n    var id = localJSON.get(name + '_id', null);\r\n    if (id === null) {\r\n      id = Math.uuid();\r\n      localJSON.set(name + '_id', id);\r\n    }\r\n    return id;\r\n  };\r\n\r\n  api.info = function(callback) {\r\n    db.transaction(function(tx) {\r\n      var sql = 'SELECT COUNT(id) AS count FROM ' + DOC_STORE;\r\n      tx.executeSql(sql, [], function(tx, result) {\r\n        callback(null, {\r\n          db_name: name,\r\n          doc_count: result.rows.item(0).count,\r\n          update_seq: update_seq\r\n        });\r\n      });\r\n    });\r\n  };\r\n\r\n  api.bulkDocs = function idb_bulkDocs(req, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (!opts) {\r\n      opts = {};\r\n    }\r\n\r\n    if (!req.docs) {\r\n      return call(callback, Pouch.Errors.MISSING_BULK_DOCS);\r\n    }\r\n\r\n    var newEdits = 'new_edits' in opts ? opts.new_edits : true;\r\n    var userDocs = JSON.parse(JSON.stringify(req.docs));\r\n\r\n    // Parse the docs, give them a sequence number for the result\r\n    var docInfos = userDocs.map(function(doc, i) {\r\n      var newDoc = parseDoc(doc, newEdits);\r\n      newDoc._bulk_seq = i;\r\n      if (doc._deleted) {\r\n        if (!newDoc.metadata.deletions) {\r\n          newDoc.metadata.deletions = {};\r\n        }\r\n        newDoc.metadata.deletions[doc._rev.split('-')[1]] = true;\r\n      }\r\n      return newDoc;\r\n    });\r\n\r\n    var tx;\r\n    var results = [];\r\n    var docs = [];\r\n    var fetchedDocs = {};\r\n\r\n    // Group multiple edits to the same document\r\n    docInfos.forEach(function(docInfo) {\r\n      if (docInfo.error) {\r\n        return results.push(docInfo);\r\n      }\r\n      if (!docs.length || docInfo.metadata.id !== docs[0].metadata.id) {\r\n        return docs.unshift(docInfo);\r\n      }\r\n      // We mark subsequent bulk docs with a duplicate id as conflicts\r\n      results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\r\n    });\r\n\r\n    function sortByBulkSeq(a, b) {\r\n      return a._bulk_seq - b._bulk_seq;\r\n    }\r\n\r\n    function complete(event) {\r\n      var aresults = [];\r\n      results.sort(sortByBulkSeq);\r\n      results.forEach(function(result) {\r\n        delete result._bulk_seq;\r\n        if (result.error) {\r\n          aresults.push(result);\r\n          return;\r\n        }\r\n        var metadata = result.metadata;\r\n        var rev = winningRev(metadata);\r\n\r\n        aresults.push({\r\n          ok: true,\r\n          id: metadata.id,\r\n          rev: rev\r\n        });\r\n\r\n        if (/_local/.test(metadata.id)) {\r\n          return;\r\n        }\r\n\r\n        var change = {\r\n          id: metadata.id,\r\n          seq: metadata.seq,\r\n          changes: collectLeaves(metadata.rev_tree),\r\n          doc: result.data\r\n        };\r\n        change.doc._rev = rev;\r\n        update_seq++;\r\n        var sql = 'UPDATE ' + META_STORE + ' SET update_seq=?';\r\n        tx.executeSql(sql, [update_seq], function() {\r\n          webSqlPouch.Changes.emitChange(name, change);\r\n        });\r\n      });\r\n      call(callback, null, aresults);\r\n    }\r\n\r\n    function writeDoc(docInfo, callback, isUpdate) {\r\n      var err = null;\r\n      var recv = 0;\r\n\r\n      docInfo.data._id = docInfo.metadata.id;\r\n      docInfo.data._rev = docInfo.metadata.rev;\r\n\r\n      if (isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\r\n        docInfo.data._deleted = true;\r\n      }\r\n\r\n      var attachments = docInfo.data._attachments ?\r\n        Object.keys(docInfo.data._attachments) : [];\r\n\r\n      for (var key in docInfo.data._attachments) {\r\n        if (!docInfo.data._attachments[key].stub) {\r\n          var data = docInfo.data._attachments[key].data;\r\n          var digest = 'md5-' + Crypto.MD5(data);\r\n          delete docInfo.data._attachments[key].data;\r\n          docInfo.data._attachments[key].digest = digest;\r\n          saveAttachment(docInfo, digest, data, function(err) {\r\n            recv++;\r\n            collectResults(err);\r\n          });\r\n        } else {\r\n          recv++;\r\n          collectResults();\r\n        }\r\n      }\r\n\r\n      if (!attachments.length) {\r\n        finish();\r\n      }\r\n\r\n      function collectResults(attachmentErr) {\r\n        if (!err) {\r\n          if (attachmentErr) {\r\n            err = attachmentErr;\r\n            call(callback, err);\r\n          } else if (recv == attachments.length) {\r\n            finish();\r\n          }\r\n        }\r\n      }\r\n\r\n      function dataWritten(tx, result) {\r\n        var seq = docInfo.metadata.seq = result.insertId;\r\n        delete docInfo.metadata.rev;\r\n        var sql = isUpdate ?\r\n          'UPDATE ' + DOC_STORE + ' SET seq=?, json=? WHERE id=?' :\r\n          'INSERT INTO ' + DOC_STORE + ' (id, seq, json) VALUES (?, ?, ?);';\r\n        var params = isUpdate ?\r\n          [seq, JSON.stringify(docInfo.metadata), docInfo.metadata.id] :\r\n          [docInfo.metadata.id, seq, JSON.stringify(docInfo.metadata)];\r\n        tx.executeSql(sql, params, function(tx, result) {\r\n          results.push(docInfo);\r\n          call(callback, null);\r\n        });\r\n      }\r\n\r\n      function finish() {\r\n        var data = docInfo.data;\r\n        var sql = 'INSERT INTO ' + BY_SEQ_STORE + ' (rev, json) VALUES (?, ?);';\r\n        tx.executeSql(sql, [data._rev, JSON.stringify(data)], dataWritten);\r\n      }\r\n    }\r\n\r\n    function updateDoc(oldDoc, docInfo) {\r\n      var merged = Pouch.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\r\n      var inConflict = (isDeleted(oldDoc) && isDeleted(docInfo.metadata)) ||\r\n        (!isDeleted(oldDoc) && newEdits && merged.conflicts !== 'new_leaf');\r\n\r\n      if (inConflict) {\r\n        results.push(makeErr(Pouch.Errors.REV_CONFLICT, docInfo._bulk_seq));\r\n        return processDocs();\r\n      }\r\n\r\n      docInfo.metadata.rev_tree = merged.tree;\r\n      writeDoc(docInfo, processDocs, true);\r\n    }\r\n\r\n    function insertDoc(docInfo) {\r\n      // Cant insert new deleted documents\r\n      if ('was_delete' in opts && isDeleted(docInfo.metadata)) {\r\n        results.push(Pouch.Errors.MISSING_DOC);\r\n        return processDocs();\r\n      }\r\n      writeDoc(docInfo, processDocs, false);\r\n    }\r\n\r\n    function processDocs() {\r\n      if (!docs.length) {\r\n        return complete();\r\n      }\r\n      var currentDoc = docs.shift();\r\n      var id = currentDoc.metadata.id;\r\n      if (id in fetchedDocs) {\r\n        updateDoc(fetchedDocs[id], currentDoc);\r\n      } else {\r\n        insertDoc(currentDoc);\r\n      }\r\n    }\r\n\r\n    // Insert sequence number into the error so we can sort later\r\n    function makeErr(err, seq) {\r\n      err._bulk_seq = seq;\r\n      return err;\r\n    }\r\n\r\n    function saveAttachment(docInfo, digest, data, callback) {\r\n      var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\r\n      var newAtt = {digest: digest, body: data};\r\n      var sql = 'SELECT * FROM ' + ATTACH_STORE + ' WHERE digest=?';\r\n      tx.executeSql(sql, [digest], function(tx, result) {\r\n        if (!result.rows.length) {\r\n          newAtt.refs = {};\r\n          newAtt.refs[ref] = true;\r\n          sql = 'INSERT INTO ' + ATTACH_STORE + '(digest, json) VALUES (?, ?)';\r\n          tx.executeSql(sql, [digest, JSON.stringify(newAtt)], function() {\r\n            call(callback, null);\r\n          });\r\n        } else {\r\n          newAtt.refs = JSON.parse(result.rows.item(0).json).refs;\r\n          sql = 'UPDATE ' + ATTACH_STORE + ' SET json=? WHERE digest=?';\r\n          tx.executeSql(sql, [JSON.stringify(newAtt), digest], function() {\r\n            call(callback, null);\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    function metadataFetched(tx, results) {\r\n      for (var j=0; j<results.rows.length; j++) {\r\n        var row = results.rows.item(j);\r\n        fetchedDocs[row.id] = JSON.parse(row.json);\r\n      }\r\n      processDocs();\r\n    }\r\n\r\n    db.transaction(function(txn) {\r\n      tx = txn;\r\n      var ids = '(' + docs.map(function(d) {\r\n        return quote(d.metadata.id);\r\n      }).join(',') + ')';\r\n      var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id IN ' + ids;\r\n      tx.executeSql(sql, [], metadataFetched);\r\n    }, unknownError(callback));\r\n  };\r\n\r\n  api.put = function(doc, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (!doc || !('_id' in doc)) {\r\n      return call(callback, Pouch.Errors.MISSING_ID);\r\n    }\r\n    return api.bulkDocs({docs: [doc]}, opts, yankError(callback));\r\n  };\r\n\r\n  api.post = function idb_put(doc, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return api.bulkDocs({docs: [doc]}, opts, yankError(callback));\r\n  };\r\n\r\n  api.revsDiff = function idb_revsDiff(req, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    var ids = Object.keys(req);\r\n    var count = 0;\r\n    var missing = {};\r\n\r\n    function readDoc(err, doc, id) {\r\n      req[id].map(function(revId) {\r\n        var matches = function(x) { return x.rev !== revId; };\r\n        if (!doc || doc._revs_info.every(matches)) {\r\n          if (!missing[id]) {\r\n            missing[id] = {missing: []};\r\n          }\r\n          missing[id].missing.push(revId);\r\n        }\r\n      });\r\n\r\n      if (++count === ids.length) {\r\n        return call(callback, null, missing);\r\n      }\r\n    }\r\n\r\n    ids.map(function(id) {\r\n      api.get(id, {revs_info: true}, function(err, doc) {\r\n        readDoc(err, doc, id);\r\n      });\r\n    });\r\n  };\r\n\r\n  api.remove = function idb_remove(doc, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    opts.was_delete = true;\r\n    var newDoc = JSON.parse(JSON.stringify(doc));\r\n    newDoc._deleted = true;\r\n    return api.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\r\n  };\r\n\r\n  api.get = function(id, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    id = parseDocId(id);\r\n    if (id.attachmentId !== '') {\r\n      return api.getAttachment(id, {decode: true}, callback);\r\n    }\r\n\r\n    var result;\r\n    db.transaction(function(tx) {\r\n      var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id=?';\r\n      tx.executeSql(sql, [id.docId], function(tx, results) {\r\n        if (!results.rows.length) {\r\n          result = Pouch.Errors.MISSING_DOC;\r\n          return;\r\n        }\r\n        var metadata = JSON.parse(results.rows.item(0).json);\r\n        if (isDeleted(metadata, opts.rev) && !opts.rev) {\r\n          result = Pouch.Errors.MISSING_DOC;\r\n          return;\r\n        }\r\n\r\n        var rev = winningRev(metadata);\r\n        var key = opts.rev ? opts.rev : rev;\r\n        var sql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE rev=?';\r\n        tx.executeSql(sql, [key], function(tx, results) {\r\n          var doc = JSON.parse(results.rows.item(0).json);\r\n\r\n          if (opts.revs) {\r\n            var path = arrayFirst(rootToLeaf(metadata.rev_tree), function(arr) {\r\n              return arr.ids.indexOf(doc._rev.split('-')[1]) !== -1;\r\n            });\r\n            path.ids.reverse();\r\n            doc._revisions = {\r\n              start: (path.pos + path.ids.length) - 1,\r\n              ids: path.ids\r\n            };\r\n          }\r\n          if (opts.revs_info) {\r\n            doc._revs_info = metadata.rev_tree.reduce(function(prev, current) {\r\n              return prev.concat(collectRevs(current));\r\n            }, []);\r\n          }\r\n          if (opts.conflicts) {\r\n            var conflicts = collectConflicts(metadata.rev_tree);\r\n            if (conflicts.length) {\r\n              doc._conflicts = conflicts;\r\n            }\r\n          }\r\n\r\n          if (opts.attachments && doc._attachments) {\r\n            var attachments = Object.keys(doc._attachments);\r\n            var recv = 0;\r\n            attachments.forEach(function(key) {\r\n              api.getAttachment(doc._id + '/' + key, {txn: tx}, function(err, data) {\r\n                doc._attachments[key].data = data;\r\n                if (++recv === attachments.length) {\r\n                  result = doc;\r\n                }\r\n              });\r\n            });\r\n          } else {\r\n            if (doc._attachments){\r\n              for (var key in doc._attachments) {\r\n                doc._attachments[key].stub = true;\r\n              }\r\n            }\r\n            result = doc;\r\n          }\r\n        });\r\n      });\r\n    }, unknownError(callback), function() {\r\n      if ('error' in result) {\r\n        call(callback, result);\r\n      } else {\r\n        call(callback, null, result);\r\n      }\r\n    });\r\n  };\r\n\r\n  api.allDocs = function(opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    var results = [];\r\n    var start = 'startkey' in opts ? opts.startkey : false;\r\n    var end = 'endkey' in opts ? opts.endkey : false;\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n    var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\r\n      BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\r\n      BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\r\n      DOC_STORE + '.seq';\r\n\r\n    if (start) {\r\n      sql += ' WHERE ' + DOC_STORE + '.id >= \"' + start + '\"';\r\n    }\r\n    if (end) {\r\n      sql += (start ? ' AND ' : ' WHERE ') + DOC_STORE + '.id <= \"' + end + '\"';\r\n    }\r\n\r\n    sql += ' ORDER BY ' + DOC_STORE + '.id ' + (descending ? 'DESC' : 'ASC');\r\n\r\n    db.transaction(function(tx) {\r\n      tx.executeSql(sql, [], function(tx, result) {\r\n        for (var i = 0, l = result.rows.length; i < l; i++ ) {\r\n          var doc = result.rows.item(i);\r\n          var metadata = JSON.parse(doc.metadata);\r\n          var data = JSON.parse(doc.data);\r\n          if (!(/_local/.test(metadata.id) || isDeleted(metadata))) {\r\n            var doc = {\r\n              id: metadata.id,\r\n              key: metadata.id,\r\n              value: {rev: winningRev(metadata)}\r\n            };\r\n            if (opts.include_docs) {\r\n              doc.doc = data;\r\n              doc.doc._rev = winningRev(metadata);\r\n              if (opts.conflicts) {\r\n                doc.doc._conflicts = collectConflicts(metadata.rev_tree);\r\n              }\r\n            }\r\n            results.push(doc);\r\n          }\r\n        }\r\n      });\r\n    }, unknownError(callback), function() {\r\n      call(callback, null, {\r\n        total_rows: results.length,\r\n        rows: results\r\n      });\r\n    });\r\n  }\r\n\r\n  api.changes = function idb_changes(opts, callback) {\r\n\r\n    if (typeof opts === 'function') {\r\n      opts = {complete: opts};\r\n    }\r\n    if (callback) {\r\n      opts.complete = callback;\r\n    }\r\n    if (!opts.seq) {\r\n      opts.seq = 0;\r\n    }\r\n    if (opts.since) {\r\n      opts.seq = opts.since;\r\n    }\r\n\r\n    if (Pouch.DEBUG)\r\n      console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\r\n\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n    descending = descending ? 'prev' : null;\r\n\r\n    var results = [], resultIndices = {}, dedupResults = [];\r\n    var id = name + ':' + Math.uuid();\r\n    var txn;\r\n\r\n    if (opts.filter && typeof opts.filter === 'string') {\r\n      var filterName = opts.filter.split('/');\r\n      api.get('_design/' + filterName[0], function(err, ddoc) {\r\n        var filter = eval('(function() { return ' +\r\n                          ddoc.filters[filterName[1]] + ' })()');\r\n        opts.filter = filter;\r\n        fetchChanges();\r\n      });\r\n    } else {\r\n      fetchChanges();\r\n    }\r\n\r\n    function fetchChanges() {\r\n      var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\r\n        BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\r\n        BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\r\n        DOC_STORE + '.seq WHERE ' + BY_SEQ_STORE + '.seq > ' + opts.seq +\r\n        ' ORDER BY ' + BY_SEQ_STORE + '.seq ' + (descending ? 'DESC' : 'ASC');\r\n\r\n      db.transaction(function(tx) {\r\n        tx.executeSql(sql, [], function(tx, result) {\r\n          for (var i = 0, l = result.rows.length; i < l; i++ ) {\r\n            var doc = result.rows.item(i);\r\n            var metadata = JSON.parse(doc.metadata);\r\n            if (!/_local/.test(metadata.id)) {\r\n              var change = {\r\n                id: metadata.id,\r\n                seq: doc.seq,\r\n                changes: collectLeaves(metadata.rev_tree),\r\n                doc: JSON.parse(doc.data),\r\n              };\r\n              change.doc._rev = winningRev(metadata);\r\n              if (isDeleted(metadata, change.doc._rev)) {\r\n                change.deleted = true;\r\n              }\r\n              if (opts.conflicts) {\r\n                change.doc._conflicts = collectConflicts(metadata.rev_tree);\r\n              }\r\n              results.push(change);\r\n            }\r\n          }\r\n          for (var i = 0, l = results.length; i < l; i++ ) {\r\n            var result = results[i];\r\n            if (result) dedupResults.push(result);\r\n          }\r\n          dedupResults.map(function(c) {\r\n            if (opts.filter && !opts.filter.apply(this, [c.doc])) {\r\n              return;\r\n            }\r\n            if (!opts.include_docs) {\r\n              delete c.doc;\r\n            }\r\n            call(opts.onChange, c);\r\n          });\r\n          call(opts.complete, null, {results: dedupResults});\r\n\r\n          if (opts.continuous && !opts.cancelled) {\r\n            webSqlPouch.Changes.addListener(name, id, opts);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    if (opts.continuous) {\r\n      return {\r\n        cancel: function() {\r\n          if (Pouch.DEBUG)\r\n            console.log(name + ': Cancel Changes Feed');\r\n          opts.cancelled = true;\r\n          webSqlPouch.Changes.removeListener(name, id);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  api.getAttachment = function(id, opts, callback) {\r\n    if (opts instanceof Function) {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (typeof id === 'string') {\r\n      id = parseDocId(id);\r\n    }\r\n\r\n    var res;\r\n    // This can be called while we are in a current transaction, pass the context\r\n    // along and dont wait for the transaction to complete here.\r\n    if ('txn' in opts) {\r\n      fetchAttachment(opts.txn);\r\n    } else {\r\n      db.transaction(fetchAttachment, unknownError(callback), function() {\r\n        call(callback, null, res);\r\n      });\r\n    }\r\n\r\n    function postProcessDoc(data) {\r\n      if (opts.decode) {\r\n        return atob(data);\r\n      }\r\n      return data;\r\n    }\r\n\r\n    function fetchAttachment(tx) {\r\n      var sql = 'SELECT ' + BY_SEQ_STORE + '.json AS data FROM ' + DOC_STORE +\r\n        ' JOIN ' + BY_SEQ_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' + DOC_STORE +\r\n        '.seq WHERE ' + DOC_STORE + '.id = \"' + id.docId + '\"' ;\r\n      tx.executeSql(sql, [], function(tx, result) {\r\n        var doc = JSON.parse(result.rows.item(0).data);\r\n        var attachment = doc._attachments[id.attachmentId];\r\n        var digest = attachment.digest;\r\n        var type = attachment.content_type;\r\n        var sql = 'SELECT * FROM ' + ATTACH_STORE + ' WHERE digest=?';\r\n        tx.executeSql(sql, [digest], function(tx, result) {\r\n          var data = JSON.parse(result.rows.item(0).json).body;\r\n          res = postProcessDoc(data);\r\n          if ('txn' in opts) {\r\n            call(callback, null, res);\r\n          }\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  // Everything below this are not dependant on the storage implementation\r\n  // and can be shared between the adapters instead of reimplemented in each\r\n  api.putAttachment = function idb_putAttachment(id, rev, doc, type, callback) {\r\n    id = parseDocId(id);\r\n    api.get(id.docId, {attachments: true}, function(err, obj) {\r\n      obj._attachments || (obj._attachments = {});\r\n      obj._attachments[id.attachmentId] = {\r\n        content_type: type,\r\n        data: btoa(doc)\r\n      }\r\n      api.put(obj, callback);\r\n    });\r\n  };\r\n\r\n  api.removeAttachment = function idb_removeAttachment(id, rev, callback) {\r\n    id = parseDocId(id);\r\n    api.get(id.docId, function(err, obj) {\r\n      if (err) {\r\n        call(callback, err);\r\n        return;\r\n      }\r\n\r\n      if (obj._rev != rev) {\r\n        call(callback, Pouch.Errors.REV_CONFLICT);\r\n        return;\r\n      }\r\n\r\n      obj._attachments || (obj._attachments = {});\r\n      delete obj._attachments[id.attachmentId];\r\n      api.put(obj, callback);\r\n    });\r\n  };\r\n\r\n  api.replicate = {};\r\n\r\n  api.replicate.from = function idb_replicate_from(url, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return Pouch.replicate(url, api, opts, callback);\r\n  };\r\n\r\n  api.replicate.to = function idb_replicate_to(dbName, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    return Pouch.replicate(api, dbName, opts, callback);\r\n  };\r\n}\r\n\r\nwebSqlPouch.valid = function() {\r\n  return !!window.openDatabase;\r\n};\r\n\r\nwebSqlPouch.destroy = function(name, callback) {\r\n  var db = openDatabase(name, POUCH_VERSION, name, POUCH_SIZE);\r\n  db.transaction(function (tx) {\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + DOC_STORE, []);\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + BY_SEQ_STORE, []);\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + ATTACH_STORE, []);\r\n  }, unknownError(callback), function() {\r\n    callback(null);\r\n  });\r\n};\r\n\r\n\r\n// This is shared exactly with the idb adapter, extract into utils\r\nwebSqlPouch.Changes = (function() {\r\n\r\n  var api = {};\r\n  var listeners = {};\r\n\r\n  api.addListener = function(db, id, opts) {\r\n    if (!listeners[db]) {\r\n      listeners[db] = {};\r\n    }\r\n    listeners[db][id] = opts;\r\n  }\r\n\r\n  api.removeListener = function(db, id) {\r\n    delete listeners[db][id];\r\n  }\r\n\r\n  api.clearListeners = function(db) {\r\n    delete listeners[db];\r\n  }\r\n\r\n  api.emitChange = function(db, change) {\r\n    if (!listeners[db]) {\r\n      return;\r\n    }\r\n    for (var i in listeners[db]) {\r\n      var opts = listeners[db][i];\r\n      if (opts.filter && !opts.filter.apply(this, [change.doc])) {\r\n        return;\r\n      }\r\n      if (!opts.include_docs) {\r\n        delete change.doc;\r\n      }\r\n      opts.onChange.apply(opts.onChange, [change]);\r\n    }\r\n  }\r\n\r\n  return api;\r\n})();\r\n\r\nPouch.adapter('websql', webSqlPouch);\r\n/*global Pouch: true */\r\n\r\n\"use strict\";\r\n\r\n// This is the first implementation of a basic plugin, we register the\r\n// plugin object with pouch and it is mixin'd to each database created\r\n// (regardless of adapter), adapters can override plugins by providing\r\n// their own implementation. functions on the plugin object that start\r\n// with _ are reserved function that are called by pouchdb for special\r\n// notifications.\r\n\r\n// If we wanted to store incremental views we can do it here by listening\r\n// to the changes feed (keeping track of our last update_seq between page loads)\r\n// and storing the result of the map function (possibly using the upcoming\r\n// extracted adapter functions)\r\n\r\nvar MapReduce = function(db) {\r\n\r\n  function viewQuery(fun, options) {\r\n    if (!options.complete) {\r\n      return;\r\n    }\r\n\r\n    function sum(values) {\r\n      return values.reduce(function(a, b) { return a + b; }, 0);\r\n    }\r\n\r\n    var results = [];\r\n    var current = null;\r\n\r\n    var emit = function(key, val) {\r\n      var viewRow = {\r\n        id: current._id,\r\n        key: key,\r\n        value: val\r\n      };\r\n      if (options.include_docs) {\r\n        viewRow.doc = current.doc;\r\n      }\r\n      if (options.startkey && Pouch.collate(key, options.startkey) < 0) return;\r\n      if (options.endkey && Pouch.collate(key, options.endkey) > 0) return;\r\n      if (options.key && Pouch.collate(key, options.key) != 0) return;\r\n      results.push(viewRow);\r\n    };\r\n\r\n    // ugly way to make sure references to 'emit' in map/reduce bind to the\r\n    // above emit\r\n    eval('fun.map = ' + fun.map.toString() + ';');\r\n    if (fun.reduce) {\r\n      eval('fun.reduce = ' + fun.reduce.toString() + ';');\r\n    }\r\n\r\n    db.changes({\r\n      include_docs: true,\r\n      onChange: function(doc) {\r\n        if (!('deleted' in doc)) {\r\n          current = {doc: doc.doc};\r\n          fun.map.call(this, doc.doc);\r\n        }\r\n      },\r\n      complete: function() {\r\n        results.sort(function(a, b) {\r\n          return Pouch.collate(a.key, b.key);\r\n        });\r\n        if (options.descending) {\r\n          results.reverse();\r\n        }\r\n        if (options.reduce === false) {\r\n          return options.complete(null, {rows: results});\r\n        }\r\n\r\n        var groups = [];\r\n        results.forEach(function(e) {\r\n          var last = groups[groups.length-1] || null;\r\n          if (last && Pouch.collate(last.key[0][0], e.key) === 0) {\r\n            last.key.push([e.key, e.id]);\r\n            last.value.push(e.value);\r\n            return;\r\n          }\r\n          groups.push({key: [[e.key, e.id]], value: [e.value]});\r\n        });\r\n        groups.forEach(function(e) {\r\n          e.value = fun.reduce(e.key, e.value) || null;\r\n          e.key = e.key[0][0];\r\n        });\r\n        options.complete(null, {rows: groups});\r\n      }\r\n    });\r\n  };\r\n\r\n  function httpQuery(fun, opts, callback) {\r\n\r\n    // List of parameters to add to the PUT request\r\n    var params = [];\r\n\r\n    // If opts.reduce exists and is defined, then add it to the list\r\n    // of parameters.\r\n    // If reduce=false then the results are that of only the map function\r\n    // not the final result of map and reduce.\r\n    if (typeof opts.reduce !== 'undefined') {\r\n      params.push('reduce=' + opts.reduce);\r\n    }\r\n    if (typeof opts.include_docs !== 'undefined') {\r\n      params.push('include_docs=' + opts.include_docs);\r\n    }\r\n    if (typeof opts.limit !== 'undefined') {\r\n      params.push('limit=' + opts.limit);\r\n    }\r\n    if (typeof opts.descending !== 'undefined') {\r\n      params.push('descending=' + opts.descending);\r\n    }\r\n    if (typeof opts.startkey !== 'undefined') {\r\n      params.push('startkey=' + encodeURIComponent(JSON.stringify(opts.startkey)));\r\n    }\r\n    if (typeof opts.endkey !== 'undefined') {\r\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\r\n    }\r\n    if (typeof opts.key !== 'undefined') {\r\n      params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    params = params === '' ? '' : '?' + params;\r\n\r\n    // We are referencing a query defined in the design doc\r\n    if (typeof fun === 'string') {\r\n      var parts = fun.split('/');\r\n      db.request({\r\n        type:'GET',\r\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\r\n      }, callback);\r\n      return;\r\n    }\r\n\r\n    // We are using a temporary view, terrible for performance but good for testing\r\n    var queryObject = JSON.stringify(fun, function(key, val) {\r\n      if (typeof val === 'function') {\r\n        return val + ''; // implicitly `toString` it\r\n      }\r\n      return val;\r\n    });\r\n\r\n    db.request({\r\n      type:'POST',\r\n      url: '_temp_view' + params,\r\n      data: queryObject\r\n    }, callback);\r\n  };\r\n\r\n  function query(fun, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    if (callback) {\r\n      opts.complete = callback;\r\n    }\r\n\r\n    if (db.type() === 'http') {\r\n      return httpQuery(fun, opts, callback);\r\n    }\r\n\r\n    if (typeof fun === 'object') {\r\n      return viewQuery(fun, opts);\r\n    }\r\n\r\n    var parts = fun.split('/');\r\n    db.get('_design/' + parts[0], function(err, doc) {\r\n      if (err) {\r\n        if (callback) callback(err);\r\n        return;\r\n      }\r\n      viewQuery({\r\n        map: doc.views[parts[1]].map,\r\n        reduce: doc.views[parts[1]].reduce\r\n      }, opts);\r\n    });\r\n  }\r\n\r\n  return {'query': query};\r\n};\r\n\r\n// Deletion is a noop since we dont store the results of the view\r\nMapReduce._delete = function() { }\r\n\r\nPouch.plugin('mapreduce', MapReduce);\r\n"]],"start1":0,"start2":0,"length1":0,"length2":221323}]],"length":221323,"saved":false}
